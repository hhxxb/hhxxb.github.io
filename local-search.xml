<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>桥和割点</title>
    <link href="/2021/04/13/%E5%9B%BE%E8%AE%BA/%E6%A1%A5%E5%92%8C%E5%89%B2%E7%82%B9/"/>
    <url>/2021/04/13/%E5%9B%BE%E8%AE%BA/%E6%A1%A5%E5%92%8C%E5%89%B2%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于无向图，如果删除了一条边导致整个图的连通分量数量发生了变化，则这条边称为桥</p><p>对于无向图，如果删除了一个顶点导致整个图的连通分量数量发生了变化，则这个点称为割点。（一条桥对应的两个顶点）</p></blockquote><h3 id="寻找桥"><a href="#寻找桥" class="headerlink" title="寻找桥"></a>寻找桥</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    如何判断 v-w 是不是桥?</span><br><span class="hljs-comment">    看通过w，能否从另外一条路回到v或者v之前的顶点。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    对于每一个顶点，记录DFS的访问顺序。</span><br><span class="hljs-comment">    ord[v]表示顶点v在DFS的访问顺序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    对于每一个顶点，记录能到达的最小ord</span><br><span class="hljs-comment">    low[v]表示DFS过程中，顶点v能到达的最小ord值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    low[w] &gt; ord[v], 则 v-w为桥</span><br><span class="hljs-comment">*/</span><br><br>visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>ord[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>low[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> parent)</span> </span>&#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    ord[v] = cnt;<br>    low[v] = ord[v];<br>    cnt++;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            dfs(w, v);<br>            low[v] = Math.min(low[v], low[w]);<br><br>            <span class="hljs-comment">// 该边为桥</span><br>            <span class="hljs-keyword">if</span> (low[w] &gt; ord[v]) &#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;v, w&#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (w != parent) &#123;<br>                low[v] = Math.min(low[v], low[w]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="寻找割点"><a href="#寻找割点" class="headerlink" title="寻找割点"></a>寻找割点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    low[w] &gt;= ord[v], 则v是割点。</span><br><span class="hljs-comment">    根节点(v == parent)另外判断，如果根节点有一个以上的孩子则根节点是割点。</span><br><span class="hljs-comment">*/</span><br><br>visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>ord[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>low[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> parent)</span> </span>&#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    ord[v] = cnt;<br>    low[v] = ord[v];<br>    cnt++;<br><br>    <span class="hljs-keyword">int</span> child = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            dfs(w, v);<br>            low[v] = Math.min(low[v], low[w]);<br><br>            <span class="hljs-comment">// 如果v不是根节点 v为割点</span><br>            <span class="hljs-keyword">if</span> (v != parent &amp;&amp; low[w] &gt;= ord[v]) &#123;<br>                res.add(v);<br>            &#125;<br><br>            <span class="hljs-comment">// 根节点单独判断</span><br>            child++;<br>            <span class="hljs-keyword">if</span> (v == parent &amp;&amp; child &gt; <span class="hljs-number">1</span>) &#123;<br>                res.add(v);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (w != parent) &#123;<br>                low[v] = Math.min(low[v], low[w]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>桥和割点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的广度优先搜索</title>
    <link href="/2021/04/12/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <url>/2021/04/12/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>广度优先遍历使用<strong>队列</strong>， 将还未访问过的节点加入到队列中并标志已访问</p><p>时间复杂度:O(V + E)</p><p>广度优先搜索的应用：</p><ul><li>求一个点到另外一个点的最短路径（典型）</li></ul></blockquote><h3 id="BFS的伪代码"><a href="#BFS的伪代码" class="headerlink" title="BFS的伪代码"></a>BFS的伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    queue.add(v);   <span class="hljs-comment">// 初始顶点加入队列</span><br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> v = queue.poll();<br>        <span class="hljs-comment">// 将还没访问过的邻接顶点压入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                queue.add(w);<br>                visited[w] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用1：求点s到点t的任一路径"><a href="#应用1：求点s到点t的任一路径" class="headerlink" title="应用1：求点s到点t的任一路径"></a>应用1：求点s到点t的任一路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br>pre[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;<br><br>bfs(<span class="hljs-keyword">int</span> s) &#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    queue.add(v);   <span class="hljs-comment">// 初始顶点加入队列</span><br>    pre[s] = s;<br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> v = queue.poll();<br>        <span class="hljs-comment">// 将还没访问过的邻接顶点压入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                queue.add(w);<br>                visited[w] = <span class="hljs-keyword">true</span>;<br>                pre[w] = v  <span class="hljs-comment">// 记录上一个节点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用2：求无权图中点s到其他顶点的最短距离"><a href="#应用2：求无权图中点s到其他顶点的最短距离" class="headerlink" title="应用2：求无权图中点s到其他顶点的最短距离"></a>应用2：求无权图中点s到其他顶点的最短距离</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br>dist[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;<br><br>bfs(<span class="hljs-keyword">int</span> s) &#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    dist[s] = <span class="hljs-number">0</span>;<br>    queue.add(s);<br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> v = queue.poll();<br><br>        <span class="hljs-comment">// 将还没访问过的邻接顶点压入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                queue.add(w);<br>                visited[w] = <span class="hljs-keyword">true</span>;<br>                dist[w] = dist[v] + <span class="hljs-number">1</span>;    <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的深度优先搜索</title>
    <link href="/2021/04/11/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/11/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图的深度优先遍历需要维护：一个节点是否已经被访问过</p><p>时间复杂度：O(V + E)</p><p>深度优先遍历的应用：</p><ul><li>求连通分量</li><li>两个点是否可达</li><li>图中是否有环</li><li>…</li></ul></blockquote><h3 id="DFS的伪代码"><a href="#DFS的伪代码" class="headerlink" title="DFS的伪代码"></a>DFS的伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><br>visited[<span class="hljs-number">0</span> ~ V - <span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 这样的话可以遍历多个连通分量的情况</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>    <span class="hljs-keyword">if</span> (!visited[v])<br>        dfs(v);<br>&#125;<br><br>dfs(<span class="hljs-keyword">int</span> v) &#123;<br>    <span class="hljs-comment">// 将该节点加入访问节点</span><br>    list.add(v)<br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 遍历与它相邻的所有节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-comment">// 需要判断该节点是否以已经被访问过</span><br>        <span class="hljs-keyword">if</span> (!visited[w])<br>            dfs(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用1：无向图的联通分量个数"><a href="#应用1：无向图的联通分量个数" class="headerlink" title="应用1：无向图的联通分量个数"></a>应用1：无向图的联通分量个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V - <span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>    <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>        cnt++;      <span class="hljs-comment">// 每进入一次则连通分量+1</span><br>        dfs(v);<br>    &#125;<br>&#125;<br><br>dfs(<span class="hljs-keyword">int</span> v) &#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w])<br>            dfs(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用2：每个连通分量的顶点个数"><a href="#应用2：每个连通分量的顶点个数" class="headerlink" title="应用2：每个连通分量的顶点个数"></a>应用2：每个连通分量的顶点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V - <span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>; <br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>    <span class="hljs-keyword">if</span> (visited[v] == -<span class="hljs-number">1</span>) &#123;<br>        dfs(v, cnt);<br>        cnt++;      <span class="hljs-comment">// 不仅维护有几个连通分量，而且可以赋给visited[]来记录顶点属于第几个连通分量</span><br>    &#125;<br>&#125;<br><br>dfs(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> cnt) &#123;<br>    visited[v] = cnt;       <span class="hljs-comment">// visited[]记录属于哪一个连通分量</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-keyword">if</span> (visited[w] == -<span class="hljs-number">1</span>)<br>            dfs(w, cnt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用3：判断两个顶点是否属于同一个联通分量"><a href="#应用3：判断两个顶点是否属于同一个联通分量" class="headerlink" title="应用3：判断两个顶点是否属于同一个联通分量"></a>应用3：判断两个顶点是否属于同一个联通分量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在应用2的基础上，通过判断visited[]是否为同一个值即可判断</span><br><br><span class="hljs-keyword">if</span> (visited[s] == visited[p])   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 返回每个连通分量的所有情况</span><br>Map&lt;Integer, List&lt;Integer&gt;&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;<br>    <span class="hljs-keyword">int</span> t = visited[i];<br>    <span class="hljs-keyword">if</span> (!m.containsKey(t))<br>        m.put(t, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>    m.get(t).add(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用4：如何求出两个顶点之间的任意一条路径"><a href="#应用4：如何求出两个顶点之间的任意一条路径" class="headerlink" title="应用4：如何求出两个顶点之间的任意一条路径"></a>应用4：如何求出两个顶点之间的任意一条路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 记录pre信息即可</span><br><span class="hljs-keyword">int</span>[] pre;<br><span class="hljs-keyword">boolean</span>[] visited;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> parent, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    pre[v] = parent;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 提前返回</span><br>    <span class="hljs-keyword">if</span> (v == t) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adg[v]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            <span class="hljs-keyword">if</span> (dfs(w, v, t))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 倒序输出</span><br><span class="hljs-keyword">while</span> (p != s) &#123;<br>    list.add(p);<br>    p = parent[p];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用5：检测无向图中的环"><a href="#应用5：检测无向图中的环" class="headerlink" title="应用5：检测无向图中的环"></a>应用5：检测无向图中的环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 找到一个已经访问过的节点，并且该节点不是上一个节点</span><br><span class="hljs-keyword">boolean</span> visited[];<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> parent)</span> </span>&#123;<br><br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w])<br>            <span class="hljs-keyword">if</span> (dfs(w, v))  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <br>        <span class="hljs-keyword">if</span> (visited[w] &amp;&amp; parent != v)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用6：二分图检测"><a href="#应用6：二分图检测" class="headerlink" title="应用6：二分图检测"></a>应用6：二分图检测</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二分图：每一个顶点的相邻顶点与该顶点不属于同一类</span><br><br><span class="hljs-keyword">boolean</span>[] visited;<br><span class="hljs-keyword">int</span>[] colors;  <span class="hljs-comment">// -1: 未染色，0：蓝色，1：红色</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> color)</span> </span>&#123;<br>    colors[v] = color;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            <span class="hljs-keyword">if</span> (!dfs(w, <span class="hljs-number">1</span> - color))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 判断颜色是否冲突</span><br>            <span class="hljs-keyword">if</span> (colors[w] == colors[v])<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>深度优先遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的基本表示</title>
    <link href="/2021/04/11/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA/"/>
    <url>/2021/04/11/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">利用二维数组来表示两个节点的关系<br><span class="hljs-variable">arr</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-operator">:</span> 表示<span class="hljs-variable">i</span><span class="hljs-operator">--&gt;</span><span class="hljs-variable">j</span><span class="hljs-operator">,</span> 权值为<span class="hljs-number">3</span><br>适合稠密图<span class="hljs-operator">:</span> 顶点少，边很多<br><br>空间复杂度<span class="hljs-operator">:</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">V</span> <span class="hljs-operator">^</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span><br>建图：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">)</span><br>查看两个点是否相邻：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><br>求一个点的相邻节点：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">V</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 邻接矩阵的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdjMatrix</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V;  <span class="hljs-comment">// 顶点个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;  <span class="hljs-comment">// 边的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] adj;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdjMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-keyword">int</span> E)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.V = V;<br>        <span class="hljs-keyword">this</span>.E = E;<br>        adj = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V][V];<br>    &#125;<br><br>    <span class="hljs-comment">// 无向图要维护两条边，否则仅需要维护一条边</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st, <span class="hljs-keyword">int</span> ed)</span> </span>&#123;<br>        adj[st][ed] = <span class="hljs-number">1</span>;<br>        adj[ed][st] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回与顶点v的所有相邻节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getAdj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;<br>            <span class="hljs-keyword">if</span> (adj[x][i] == <span class="hljs-number">1</span>)<br>                res.add(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl">利用数组 + 链表(哈希表<span class="hljs-variable">HashSet</span>/红黑树<span class="hljs-variable">TreeSet</span>)的形式保存顶点以及它的临边关系。<br>适合稀疏图：顶点多，边很少<br><br>空间复杂度:<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">V</span> + <span class="hljs-variable">E</span>)</span><br>建图：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">E</span>)</span><br>查看两个点是否相邻：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">degree</span>(<span class="hljs-variable">V</span>))</span><br>求一个点的相邻节点：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">degree</span>(<span class="hljs-variable">V</span>))</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 邻接表表示</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdjList</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;<br>    <span class="hljs-comment">//private LinkedList&lt;Integer&gt;[] adj;</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Integer&gt;[] adj;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdjList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-keyword">int</span> E)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.V = V;<br>        <span class="hljs-keyword">this</span>.E = E;<br><br>        adj = <span class="hljs-keyword">new</span> HashSet&lt;&gt;[V];<br>    &#125;<br><br>    <span class="hljs-comment">// 无向图要维护两条边，否则仅需要维护一条边</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st, <span class="hljs-keyword">int</span> ed)</span> </span>&#123;<br>        adj[st].add(ed);<br>        adj[ed].add(st);<br>    &#125;<br><br>    <span class="hljs-comment">// 返回与顶点v的所有相邻节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HashSet&lt;Integer&gt; <span class="hljs-title">getAdj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        HashSet&lt;Integer&gt; res = adj[x];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图的存储</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0010_正则表达式匹配</title>
    <link href="/2021/04/10/%E7%AE%97%E6%B3%95/LC0010_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95/LC0010_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <span class="hljs-string">&#x27;.&#x27;</span> 和 <span class="hljs-string">&#x27;*&#x27;</span> 的正则表达式匹配。<br><br><span class="hljs-string">&#x27;.&#x27;</span> 匹配任意单个字符<br><span class="hljs-string">&#x27;*&#x27;</span> 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：s = <span class="hljs-comment">&quot;aa&quot;</span> p = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-keyword">false</span><br>解释：<span class="hljs-comment">&quot;a&quot;</span> 无法匹配 <span class="hljs-comment">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">dp[i][j]: s串的前i个字符与p串的前j个字符是否匹配<br><br>集合划分：(p[j] != <span class="hljs-string">&#x27;*&#x27;</span> || p[j] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>    (<span class="hljs-number">1</span>) 当p[j] != <span class="hljs-string">&#x27;*&#x27;</span> 的时候，需要比较 s[i] 与 p[j]. 如果s[i]能够与p[j]匹配，那么dp[i][j]根据 dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]转移过来。<br><br>    (<span class="hljs-number">2</span>) 当p[j] == <span class="hljs-string">&#x27;*&#x27;</span> 的时候，则可能匹配<span class="hljs-number">0</span>次、<span class="hljs-number">1</span>次、<span class="hljs-number">2</span>次...<br>    匹配<span class="hljs-number">0</span>次: dp[i][j] 根据 dp[i][j<span class="hljs-number">-1</span>]转移过来<br>    匹配<span class="hljs-number">1</span>次：s[i] == p[j<span class="hljs-number">-1</span>]<br>    匹配<span class="hljs-number">2</span>次：s[i] == p[j<span class="hljs-number">-1</span>] &amp;&amp; s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>]<br>    匹配<span class="hljs-number">3</span>次：s[i] == p[j<span class="hljs-number">-1</span>] &amp;&amp; s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &amp;&amp; s[i<span class="hljs-number">-2</span>] == p[j<span class="hljs-number">-1</span>]<br>    ...<br><br>    因此匹配多次的情况：<span class="hljs-number">1</span>次 || <span class="hljs-number">2</span>次 || <span class="hljs-number">3</span>次 || ...<br>    然而我们发现 dp[i<span class="hljs-number">-1</span>][j] 在匹配多次的情况时：<br>        <span class="hljs-number">1</span>次: s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>        <span class="hljs-number">2</span>次：s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] &amp;&amp; s[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-1</span>]<br>        ...<br>    <br>    因此 dp[i][j] 可以通过 dp[i<span class="hljs-number">-1</span>][j] &amp;&amp; s[i] == p[j<span class="hljs-number">-1</span>] 转移过来。<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br><br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    p = <span class="hljs-string">&quot; &quot;</span> + p;<br><br>    <span class="hljs-comment">// dp[i][j]: s前i个字符是否能够与p前j个字符相匹配 </span><br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] || dp[i][j];<br>            <br>            <span class="hljs-keyword">if</span> (p.charAt(j) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 匹配0次</span><br>                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span>)<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">2</span>] || dp[i][j];<br>                <br>                <span class="hljs-comment">// 匹配多次</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j - <span class="hljs-number">1</span>) || p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] || dp[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0004_寻找两个正序数组的中位数</title>
    <link href="/2021/04/10/%E7%AE%97%E6%B3%95/LC0004_%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95/LC0004_%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br><br>示例 1：<br><br>输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm">方法<span class="hljs-number">1</span>：O(N + M)<br>    将两个正序数组按序合并，返回对应的中位数即可<br><br>方法<span class="hljs-number">2</span>：O(log(N + M))<br>    先考虑朴素情况：每次我们取<span class="hljs-built_in">s1</span>[k/<span class="hljs-number">2</span>]和<span class="hljs-built_in">s2</span>[k/<span class="hljs-number">2</span>]的地方，如果<span class="hljs-built_in">s1</span>[k/<span class="hljs-number">2</span>] &gt; <span class="hljs-built_in">s2</span>[k/<span class="hljs-number">2</span>]，则说明第k小的数肯定不会存在于<span class="hljs-built_in">s2</span>[l, l + k/<span class="hljs-number">2</span>]中。因此可以排除掉 k / <span class="hljs-number">2</span> 个元素。<br><br>    再考虑边界情况，如果<span class="hljs-built_in">s1</span>中的个数不足 k / <span class="hljs-number">2</span> 怎么办？ <br>        那么就取最后一个位置的元素参与比较, int si = min(i + k / <span class="hljs-number">2</span>, len(<span class="hljs-built_in">s1</span>))<br>    <br>    如果<span class="hljs-built_in">s1</span>已经排除完了怎么办？i<br>        返回<span class="hljs-built_in">s2</span>[j + k - <span class="hljs-number">1</span>]的元素即可<br><br>    如果 k == <span class="hljs-number">1</span> 怎么办？<br>        返回 min(<span class="hljs-built_in">s1</span>[i], <span class="hljs-built_in">s2</span>[j])<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> total = nums1.length + nums2.length;<br><br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// find (total / 2)th number</span><br>        <span class="hljs-keyword">int</span> left = findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// find (total / 2 + 1)th number</span><br>        <span class="hljs-keyword">int</span> right = findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2.0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">1.0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums1.length - i &gt; nums2.length - j)<br>        <span class="hljs-keyword">return</span> findKth(nums2, j, nums1, i, k);<br>    <br>    <span class="hljs-keyword">if</span> (i == nums1.length)  <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br><br>    <span class="hljs-keyword">int</span> si = Math.min(i + k / <span class="hljs-number">2</span>, nums1.length);<br>    <span class="hljs-keyword">int</span> sj = j + k / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (nums1[si - <span class="hljs-number">1</span>] &gt; nums2[sj - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> findKth(nums1, si, nums2, j, k - (si - i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>递归</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中位数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie字典树</title>
    <link href="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Trie%E6%A0%91/"/>
    <url>/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素版字典树：仅维护单词结尾信息"><a href="#朴素版字典树：仅维护单词结尾信息" class="headerlink" title="朴素版字典树：仅维护单词结尾信息"></a>朴素版字典树：仅维护单词结尾信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> isWord;<br>    Node[] next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isWord)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.isWord = isWord;<br>        next = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> Node();<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加一个单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        <span class="hljs-comment">// 从根节点开始查找</span><br>        Node cur = root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <span class="hljs-comment">// 如果该字符还没出现过，则生成节点</span><br>            <span class="hljs-keyword">if</span> (cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Node();<br><br>            <span class="hljs-comment">// cur指向新节点继续向下找</span><br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>]<br>        &#125;<br><br>        <span class="hljs-comment">// 走到最后一个字符，判断是否已经出现过</span><br>        <span class="hljs-keyword">if</span> (!cur.isWord) &#123;<br>            cur.isWord = <span class="hljs-keyword">true</span>;<br>            size++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询一个单词是否存在</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <span class="hljs-keyword">if</span> (cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cur.isWord == <span class="hljs-keyword">true</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂版字典树：维护结尾信息、前缀信息"><a href="#复杂版字典树：维护结尾信息、前缀信息" class="headerlink" title="复杂版字典树：维护结尾信息、前缀信息"></a>复杂版字典树：维护结尾信息、前缀信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> isWord; <span class="hljs-comment">// 维护结尾信息</span><br>    <span class="hljs-keyword">int</span> pre;    <span class="hljs-comment">// 维护前缀信息</span><br>    <br>    Node[] next;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>        isWord = <span class="hljs-keyword">false</span>;<br>        pre = <span class="hljs-number">0</span>;<br>        next = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> Node();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 添加单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <br>            <span class="hljs-comment">// 如果该后缀不存在，则创建</span><br>            <span class="hljs-keyword">if</span> (cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Node();<br>            <br>            <span class="hljs-comment">// 以该字符为前缀的单词数量+1</span><br>            cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>].pre += <span class="hljs-number">1</span>;<br>            <br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!cur.isWord) &#123;<br>            cur.isWord = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <br>            <span class="hljs-keyword">if</span> (cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> cur.isWord;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 删除单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <br>            <span class="hljs-comment">// 以该字符为前缀的单词数量-1</span><br>            cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>].pre -= <span class="hljs-number">1</span>;<br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <br>        cur.isWord = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询前缀</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numOfPre</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> cur.pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>字典树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>股票交易问题</title>
    <link href="/2021/04/08/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/08/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="LeetCode121-买卖股票的最佳时机1"><a href="#LeetCode121-买卖股票的最佳时机1" class="headerlink" title="LeetCode121:买卖股票的最佳时机1"></a>LeetCode121:买卖股票的最佳时机1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    特点：只能买卖一次</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    贪心：寻找最大的上升区间。xMin记录曾经出现过的最小值，xMax记录最大的上升区间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> xMin = prices[<span class="hljs-number">0</span>];   <span class="hljs-comment">// 记录当前出现的最小值</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        res = Math.max(res, prices[i] - xMin);<br>        xMin = Math.min(xMin, prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode122-买卖股票的最佳时机2"><a href="#LeetCode122-买卖股票的最佳时机2" class="headerlink" title="LeetCode122:买卖股票的最佳时机2"></a>LeetCode122:买卖股票的最佳时机2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    特点：可以买卖无数次</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    贪心: 累加每一个上升区间</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-comment">// 累加每一个上升区间</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; prices.length &amp;&amp; prices[j] &gt; prices[j - <span class="hljs-number">1</span>])<br>            j++;<br>        <br>        <span class="hljs-comment">// 上升区间[i, j - 1]</span><br>        sum += prices[j - <span class="hljs-number">1</span>] - prices[i];<br>        i = j - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode123-买卖股票的最佳时机3"><a href="#LeetCode123-买卖股票的最佳时机3" class="headerlink" title="LeetCode123:买卖股票的最佳时机3"></a>LeetCode123:买卖股票的最佳时机3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    特点：只能交易2次</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用前后缀分解的思想：</span><br><span class="hljs-comment">        1、从前往后枚举，记录前面买卖一次的最大收益f[i]。 第i天手上无股票的最大收益</span><br><span class="hljs-comment">        2、从后往前枚举，记录后面买卖一次的最大收益g[i]。 第i天买入股票的最大收益</span><br><span class="hljs-comment">        3、则总的最大收益：max(f[i] + g[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <br>    <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];   <span class="hljs-comment">// 前面买卖一次的最大收益</span><br>    <span class="hljs-keyword">int</span> xMin = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        f[i] = f[i - <span class="hljs-number">1</span>];    <span class="hljs-comment">// 不卖</span><br>        f[i] = Math.max(f[i], prices[i] - xMin); <span class="hljs-comment">// 卖</span><br>        xMin = Math.min(xMin, prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];   <span class="hljs-comment">// 后面买卖一次的最大收益</span><br>    <span class="hljs-keyword">int</span> xMax = prices[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        g[i] = g[i + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 不买</span><br>        g[i] = Math.max(g[i], xMax - prices[i]);    <span class="hljs-comment">// 买</span><br>        xMax = Math.max(xMax, prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        res = Math.max(res, f[i] + g[i]);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode188-买卖股票的最佳时机4"><a href="#LeetCode188-买卖股票的最佳时机4" class="headerlink" title="LeetCode188:买卖股票的最佳时机4"></a>LeetCode188:买卖股票的最佳时机4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    特点：只能买卖K次</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    状态机模型： </span><br><span class="hljs-comment">        状态1: 手上有现金</span><br><span class="hljs-comment">        状态2：手上有股票</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    转移方式： 1 -&gt; 1  不买</span><br><span class="hljs-comment">              1 -&gt; 2  买  -price[i]</span><br><span class="hljs-comment">              2 -&gt; 2  不卖</span><br><span class="hljs-comment">              2 -&gt; 1  卖  +price[i]</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    f[i][j] : 经过了i天，交易了j次且当天不持有股票的最大收益 f[0][0] = 0</span><br><span class="hljs-comment">    g[i][j] : 经过了i天，交易了j次且当天持有股票的最大收益   g[0][0] = -INF</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    f[i][j] 对应两种转移方式： max(f[i-1][j], g[i-1][j-1] + prices[i])</span><br><span class="hljs-comment">    g[i][j] 对应两种转移方式： max(g[i-1][j], f[i-1][j-1] - prices[i])</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    由于f[i][j] 和 g[i][j] 都至于上一层有关，因此采用滚动数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意: 当 k &gt;= n / 2 天时，相当于无限次交易</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">if</span> (k &gt;= n / <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 相当于无限次交易</span><br>        <span class="hljs-keyword">return</span> maxProfit(prices);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][k + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        Arrays.fill(f[i], -<span class="hljs-number">100000000</span>);<br>        Arrays.fill(g[i], -<span class="hljs-number">100000000</span>);<br>    &#125;<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= k; j++) &#123;<br>            f[i % <span class="hljs-number">2</span>][j] = f[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j];<br>            g[i % <span class="hljs-number">2</span>][j] = Math.max(g[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j], f[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j] - prices[i-<span class="hljs-number">1</span>]);<br><br>            <span class="hljs-comment">// 只有买过才算一次交易，才能从 2 -&gt; 1</span><br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>)<br>                f[i % <span class="hljs-number">2</span>][j] = Math.max(f[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j], g[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j-<span class="hljs-number">1</span>] + prices[i-<span class="hljs-number">1</span>]);<br>            <br>            xMax = Math.max(xMax, f[i % <span class="hljs-number">2</span>][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br><span class="hljs-comment">// 股票问题2</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-comment">// 累加每一个上升区间</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; prices.length &amp;&amp; prices[j] &gt; prices[j - <span class="hljs-number">1</span>])<br>            j++;<br>        <br>        <span class="hljs-comment">// 上升区间[i, j - 1]</span><br>        sum += prices[j - <span class="hljs-number">1</span>] - prices[i];<br>        i = j - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode309-最佳买卖股票时机含冷冻期"><a href="#LeetCode309-最佳买卖股票时机含冷冻期" class="headerlink" title="LeetCode309:最佳买卖股票时机含冷冻期"></a>LeetCode309:最佳买卖股票时机含冷冻期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    不再有次数的限制。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    三个状态：</span><br><span class="hljs-comment">        状态0：冷冻期</span><br><span class="hljs-comment">        状态1：持有股票</span><br><span class="hljs-comment">        状态2：持有现金</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    状态转移： 0 -&gt; 0  不买</span><br><span class="hljs-comment">              0 -&gt; 1  买入 -price[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">              1 -&gt; 1  不卖</span><br><span class="hljs-comment">              1 -&gt; 2  卖了 +price[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">              2 -&gt; 0  触发了1-2, 自然会进入0</span><br><span class="hljs-comment">              2 -&gt; 2  不买</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    f[i][0] = max(f[i-1][0], f[i-1][2])</span><br><span class="hljs-comment">    f[i][1] = max(f[i-1][1], f[i-1][0] - prices[i])</span><br><span class="hljs-comment">    f[i][2] = max(f[i-1][2], f[i-1][1] + prices[i])</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    状态入口：f[0][0] = 0, f[0][1] = 0, 其他皆为最小值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    取三者的最大值.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br><br>    <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        Arrays.fill(f[i], -<span class="hljs-number">100000000</span>);<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>        f[i][<span class="hljs-number">1</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        f[i][<span class="hljs-number">2</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Math.max(f[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], Math.max(f[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[n-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode714-最佳买卖股票时机含手续费"><a href="#LeetCode714-最佳买卖股票时机含手续费" class="headerlink" title="LeetCode714:最佳买卖股票时机含手续费"></a>LeetCode714:最佳买卖股票时机含手续费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    状态0: 持有现金</span><br><span class="hljs-comment">    状态1：持有股票</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    0 -&gt; 0  不买</span><br><span class="hljs-comment">    0 -&gt; 1  买入 -prices[i] - fee</span><br><span class="hljs-comment">    1 -&gt; 1  不卖</span><br><span class="hljs-comment">    1 -&gt; 0  卖了</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br><br>    <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>        Arrays.fill(f[i], -<span class="hljs-number">100000000</span>);<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i - <span class="hljs-number">1</span>]);<br>        f[i][<span class="hljs-number">1</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i - <span class="hljs-number">1</span>] - fee);<br>        xMax = Math.max(xMax, f[i][<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之数据库</title>
    <link href="/2021/04/07/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/04/07/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NC0092_最长公共子序列</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/NC0092_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/NC0092_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-<span class="hljs-number">1</span>。<br><br>示例<span class="hljs-number">1</span><br>输入:<span class="hljs-string">&quot;1A2C3D4B56&quot;</span>,<span class="hljs-string">&quot;B1D23CA45B6A&quot;</span><br>返回值:<span class="hljs-string">&quot;123456&quot;</span><br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j]: s1前i个字符和s2前j个字符的公共子序列的最长值<br><br>集合划分：(包含s1[i]且包含s2[j] || 包含s1[i]不包含s2[j] || 不包含s1[i]包含s2[j] || 都不包含)<br>         (dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> || dp[i][j-<span class="hljs-number">1</span>] || dp[i-<span class="hljs-number">1</span>][j] || dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])<br>         然而实则 dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]已经出现在了 dp[i][j-<span class="hljs-number">1</span>]和dp[i-<span class="hljs-number">1</span>][j]之中。<br><br>因此如果s1[i] == s2[j]: dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>否则：max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])<br><br>如何获取具体的序列？    <br>    保存转移状态：s1[i] == s2[j]  from[i][j] = <span class="hljs-number">0</span><br>                 dp[i-<span class="hljs-number">1</span>][j] &gt;= dp[i][j-<span class="hljs-number">1</span>] : 从i-<span class="hljs-number">1</span>转移过来，from[i][j] = <span class="hljs-number">1</span><br>                 dp[i][j-<span class="hljs-number">1</span>] &gt; dp[i-<span class="hljs-number">1</span>][j] : 从j-<span class="hljs-number">1</span>转移过来，from[i][j] = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">LCS</span> <span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">int</span> N = text1.length();<br>    <span class="hljs-keyword">int</span> M = text2.length();<br><br>    text1 = <span class="hljs-string">&quot; &quot;</span> + text1;<br>    text2 = <span class="hljs-string">&quot; &quot;</span> + text2;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][M + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[][] from = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][M + <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= M; j++) &#123;<br>            <span class="hljs-keyword">if</span> (text1.charAt(i) == text2.charAt(j)) &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                from[i][j] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j] &gt;= dp[i][j-<span class="hljs-number">1</span>])<br>                    from[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    from[i][j] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dp[N][M] == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">int</span> i = N, j = M;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (text1.charAt(i) == text2.charAt(j))<br>            sb.append(text1.charAt(i));<br>        <br>        <span class="hljs-comment">// 通过转移状态来移动i或者j，从而获取到s1[i] == s2[j]的状态</span><br>        <span class="hljs-keyword">if</span> (from[i][j] == <span class="hljs-number">0</span>) &#123;<br>            i--;<br>            j--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (from[i][j] == <span class="hljs-number">1</span>)<br>            i--;<br>        <span class="hljs-keyword">else</span> <br>            j--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>牛客网</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>公共子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NC0127_最长公共子串</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/NC0127_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/NC0127_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">给定两个字符串str1和str2,输出两个字符串的最长公共子串<br>题目保证str1和str2的最长公共子串存在且唯一。<br><br>示例<span class="hljs-number">1</span><br>输入: <span class="hljs-string">&quot;1AB2345CD&quot;</span>,<span class="hljs-string">&quot;12345EF&quot;</span><br>返回值 : <span class="hljs-string">&quot;2345&quot;</span><br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">dp[i][<span class="hljs-keyword">j]: </span><span class="hljs-built_in">s1</span>以下标i结尾和<span class="hljs-built_in">s2</span>以下标<span class="hljs-keyword">j结尾的最长公共子串的最大值</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">集合划分：(s1[i] </span>== <span class="hljs-built_in">s2</span>[<span class="hljs-keyword">j] </span><span class="hljs-title">||</span> <span class="hljs-built_in">s1</span>[i]  != <span class="hljs-built_in">s2</span>[<span class="hljs-keyword">j])</span><br><span class="hljs-keyword"> </span>        (dp[i][<span class="hljs-keyword">j] </span>= dp[i<span class="hljs-number">-1</span>][<span class="hljs-keyword">j-1] </span>+ <span class="hljs-number">1</span> <span class="hljs-title">||</span> <span class="hljs-number">0</span>)<br>         当i或者<span class="hljs-keyword">j为0时，i-1和j-1会溢出，因此当 </span>i == <span class="hljs-number">0</span> <span class="hljs-title">||</span> <span class="hljs-keyword">j </span>== <span class="hljs-number">0</span> 且 <span class="hljs-built_in">s1</span>[i] == <span class="hljs-built_in">s2</span>[<span class="hljs-keyword">j], </span>dp[i][<span class="hljs-keyword">j] </span>= <span class="hljs-number">1</span><br><br>出现更大的长度时，记录下标xIndex以及最大长度，则结果为<span class="hljs-built_in">s1</span>(xIndex - xMax + <span class="hljs-number">1</span>, xIndex + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">LCS</span> <span class="hljs-params">(String str1, String str2)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">int</span> n = str1.length();<br>    <span class="hljs-keyword">int</span> m = str2.length();<br>    <br>    <span class="hljs-comment">// str1以下标i结尾的和str2以下标j结尾的公共子串的长度最大值</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>    <br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录最大值</span><br>    <span class="hljs-keyword">int</span> xIndex = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录出现最大值的下标</span><br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 如果s1[i] == s2[j]， dp[i][j] = dp[i-1][j-1] + 1</span><br>            <span class="hljs-comment">// 如果s1[i] != s2[j], dp[i][j] = 0</span><br>            <span class="hljs-keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <br>            &#125;<br>                <br>            <span class="hljs-keyword">if</span> (xMax &lt; dp[i][j]) &#123;<br>                xMax = dp[i][j];<br>                xIndex = i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (xMax == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">return</span> str1.substring(xIndex - xMax + <span class="hljs-number">1</span>, xIndex + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>牛客网</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>公共子串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的前中后序遍历</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">实现二叉树的前、中、后序的递归遍历和非递归遍历<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归实现</span><br>ArrayList&lt;Integer&gt; arr1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    arr1.add(root.val);<br>    preOrder(root.left);<br>    preOrder(root.right);<br>&#125;<br><br>ArrayList&lt;Integer&gt; arr2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    inOrder(root.left);<br>    arr2.add(root.val);<br>    inOrder(root.right);<br>&#125;<br><br>ArrayList&lt;Integer&gt; arr3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    postOrder(root.left);<br>    postOrder(root.right);<br>    arr3.add(root.val);<br>&#125;<br><br><span class="hljs-comment">// 非递归实现</span><br>ArrayList&lt;Integer&gt; arr1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span>;<br>    <br>    Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    st.push(root);<br>    <br>    TreeNode temp;<br>    <span class="hljs-keyword">while</span> (!st.isEmpty()) &#123;<br>        temp = st.pop();<br>        <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 按照相反的方向push进去</span><br>            <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-keyword">null</span>) st.push(temp.right);<br>            <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-keyword">null</span>) st.push(temp.left);<br>            st.push(temp);<br>            st.push(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果是null，则下一个是访问的节点</span><br>            arr1.add(st.pop().val);<br>        &#125;<br>    &#125;<br>&#125;<br><br>ArrayList&lt;Integer&gt; arr2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span>;<br>    <br>    Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    st.push(root);<br>    <br>    TreeNode temp;<br>    <span class="hljs-keyword">while</span> (!st.isEmpty()) &#123;<br>        temp = st.pop();<br>        <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 按照相反的方向push进去</span><br>            <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-keyword">null</span>) st.push(temp.right);<br>            st.push(temp);<br>            st.push(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-keyword">null</span>) st.push(temp.left);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果是null，则下一个是访问的节点</span><br>            arr2.add(st.pop().val);<br>        &#125;<br>    &#125;<br>&#125;<br><br>ArrayList&lt;Integer&gt; arr3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span>;<br>    <br>    Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    st.push(root);<br>    <br>    TreeNode temp;<br>    <span class="hljs-keyword">while</span> (!st.isEmpty()) &#123;<br>        temp = st.pop();<br>        <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 按照相反的方向push进去</span><br>            st.push(temp);<br>            st.push(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-keyword">null</span>) st.push(temp.right);<br>            <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-keyword">null</span>) st.push(temp.left);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果是null，则下一个是访问的节点</span><br>            arr3.add(st.pop().val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC146_LRU缓存机制</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/LC0146_%E8%AE%BE%E8%AE%A1LRU%E7%BC%93%E5%AD%98/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/LC0146_%E8%AE%BE%E8%AE%A1LRU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">LRU缓存底层使用 哈希表 + 双向链表。双向链表中存放缓存节点<span class="hljs-keyword">Node</span><span class="hljs-title">, 哈希表记录&lt;key</span>, <span class="hljs-keyword">Node</span><span class="hljs-title">&gt;之间的映射。</span><br><span class="hljs-title"></span><br><span class="hljs-title">put</span>(int key, int value)的逻辑：<br>    <span class="hljs-number">1</span>、生成新节点<span class="hljs-keyword">Node</span><span class="hljs-title">(key</span>, value)<br>    <span class="hljs-number">2</span>、放入之前先判断该key的节点是否存在，如果存在则直接访问并且将该节点放到链表头并更新哈希表key对应的<span class="hljs-keyword">Node</span><span class="hljs-title">。</span><br><span class="hljs-title">    3</span>、如果不存在，先判断缓存是否满了，如果满了则先删除链表尾节点(同时更新哈希表)，然后将新节点插入到链表头(同时更新哈希表)<br>    <span class="hljs-number">4</span>、如果没满，则直接插入到链表头并更新哈希表即可<br><br>get(int key)的逻辑：<br>    <span class="hljs-number">1</span>、直接返回哈希表key对应的节点<span class="hljs-keyword">Node</span><span class="hljs-title"></span><br><span class="hljs-title">    2</span>、将该节点从原链表删除并插入到头节点处。<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 缓存节点定义</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 哈希表 + 双向链表</span><br><span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-keyword">private</span> LinkedList&lt;Node&gt; cache = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;<br><br><span class="hljs-comment">// 放入新节点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(key, value);<br>    <br>    <span class="hljs-keyword">if</span> (m.containsKey(key)) &#123;<br>        cache.remove(m.get(key));<br>        cache.addFirst(node);<br>        m.put(key, node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 判断容量是否满了</span><br>        <span class="hljs-keyword">if</span> (cache.size() == cap) &#123;<br>            Node last = cache.removeLast();<br>            m.remove(last.key);<br>        &#125;<br>        <br>        cache.addFirst(node);<br>        m.put(key, node);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 访问key</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!m.containsKey(key))<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <br>    Node res = m.get(key);<br>    cache.remove(res);<br>    put(key, res.value);<br>    <span class="hljs-keyword">return</span> res.value;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU缓存</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态压缩DP</title>
    <link href="/2021/03/31/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    <url>/2021/03/31/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
    
    <content type="html"><![CDATA[<h3 id="题目特点"><a href="#题目特点" class="headerlink" title="题目特点"></a>题目特点</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、数据范围不会超过<span class="hljs-number">24</span><br><span class="hljs-attribute">2</span>、dp值虽然是一个整数，但是需要看成二进制，每一位的<span class="hljs-number">01</span>表示不同的状态<br></code></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 状态压缩DP中常用的位运算</span><br><br><span class="hljs-keyword">int</span> A, B;   <span class="hljs-comment">// 集合A、B</span><br><span class="hljs-keyword">long</span> C;     <span class="hljs-comment">// 集合C</span><br><br>A |= <span class="hljs-number">1</span> &gt;&gt; x;    <span class="hljs-comment">// 将x(x = 0 ~ 31)加入到集合A</span><br>A &amp;= ~(<span class="hljs-number">1</span> &gt;&gt; x); <span class="hljs-comment">// 将x(x = 0 ~ 31)从集合A删除</span><br>A ^= <span class="hljs-number">1</span> &gt;&gt; x;    <span class="hljs-comment">// 将x(x = 0 ~ 31)从集合A删除</span><br><br>x &amp; (-x);       <span class="hljs-comment">// 获取x最后一位1</span><br>A = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 清空集合A</span><br>A | B;          <span class="hljs-comment">// 取集合A和B的并集</span><br>A &amp; B;          <span class="hljs-comment">// 取集合A和B的交集</span><br><br><span class="hljs-keyword">int</span> si = <span class="hljs-number">15</span>;<br><span class="hljs-keyword">int</span> All = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>) - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 建立大小为15的全集</span><br><br>All ^ A;        <span class="hljs-comment">// 求全集中A的补集</span><br><br>(A &amp; B) == B;   <span class="hljs-comment">// 判断B是否为A的子集</span><br><br><span class="hljs-comment">// 枚举全集All的所有子集</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= ALL; i++) &#123;    &#125;<br><br><span class="hljs-comment">// 枚举集合A的所有子集</span><br><span class="hljs-keyword">int</span> subset = A;<br><span class="hljs-keyword">do</span> &#123;<br>    subset = (subset - <span class="hljs-number">1</span>) &amp; A;<br>&#125; <span class="hljs-keyword">while</span> (subset != A)<br><br><span class="hljs-comment">// 计算集合A的元素的个数</span><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A; A &gt; <span class="hljs-number">0</span>; A &gt;&gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>    cnt += i &amp; <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 预处理每个子集的元素个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; pow(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>); i++)<br>    cnt[i] = cnt[i &gt;&gt; <span class="hljs-number">1</span>] + (i &amp; <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 判断x是否为2的幂次方</span><br>x != <span class="hljs-number">0</span> &amp;&amp; x &amp; (x - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ---&gt; x &amp;&amp; !(x &amp; (x - <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h3 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">求把 N×M 的棋盘分割成若干个 1×2 的的长方形，有多少种方案。<br><br>例如当 <span class="hljs-attribute">N</span>=2，M=4 时，共有 5 种方案。当 <span class="hljs-attribute">N</span>=2，M=3 时，共有 3 种方案。<br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    n x m 的矩阵：</span><br><span class="hljs-comment">        - - - - -</span><br><span class="hljs-comment">        - - - - -</span><br><span class="hljs-comment">        - - - - -</span><br><span class="hljs-comment">        - - - - -</span><br><span class="hljs-comment">    1代表该位置放了东西，0代表该位置没放东西。</span><br><span class="hljs-comment">    由于长方形是 1 x 2 的, 横着放是： 1 1 0 0 0  竖着放是： 1 0 0 0 0</span><br><span class="hljs-comment">                                                         1 0 0 0 0</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    核心: 先放横着的，再放竖着的(竖着的只有唯一1种方案，塞进去就可以)。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    因此总方案数 = 只放横着的所有合法方案数</span><br><span class="hljs-comment">    如何判断当前方案是否合法？  所有剩余位置能否通过竖着的填充满。可以按列来看，每一列内部所有连续的1没有奇数个(所有连续空着的0是2的倍数)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 表示已经将前i-1列摆好，且从第i-1列，伸到第i列的状态是j的所有方案数。  因为横着放：放到第i-1列的可能伸到第i列。  1表示伸到了，0表示没伸到。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]肯定是由dp[i-1][k]转移过来。由于由n行，所有k有2 ^ n个可能。</span><br><span class="hljs-comment">    但是需要保证以下条件才可以转移:</span><br><span class="hljs-comment">        (1) j &amp; k == 0: 不能在同一行。上一行都伸出来了1, 那该列该位置肯定不能横着放了</span><br><span class="hljs-comment">        (2) k的二进制所有连续空着的0必须是2的倍数。这样才能插入竖着的</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    最后返回的结果是 dp[m][0]: 最后一列所有方块不能再伸出来了。</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位统计DP</title>
    <link href="/2021/03/31/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/"/>
    <url>/2021/03/31/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/</url>
    
    <content type="html"><![CDATA[<h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9 的出现次数。<br><br>例如，a=1024，b=1032，则 a 和 b 之间共有<span class="hljs-number"> 9 </span>个数如下：<br><br>1024<span class="hljs-number"> 1025 </span>1026<span class="hljs-number"> 1027 </span>1028<span class="hljs-number"> 1029 </span>1030<span class="hljs-number"> 1031 </span>1032<br><br>其中<span class="hljs-number"> 0 </span>出现<span class="hljs-number"> 10 </span>次，1 出现<span class="hljs-number"> 10 </span>次，2 出现<span class="hljs-number"> 7 </span>次，3 出现<span class="hljs-number"> 3 </span>次等等…<br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">数位DP最重要的一点：分情况讨论<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP</title>
    <link href="/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP(%E9%87%8D%E8%A6%81)/"/>
    <url>/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP(%E9%87%8D%E8%A6%81)/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li></li></ul></blockquote><h3 id="什么叫可靠传输？"><a href="#什么叫可靠传输？" class="headerlink" title="什么叫可靠传输？"></a>什么叫可靠传输？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">简单来说，一方给另外一方发送消息，只需要保证按序到达、无错误、不丢失、不重复即可认为是可靠传输。<br></code></pre></td></tr></table></figure><h3 id="如何做到可靠传输"><a href="#如何做到可靠传输" class="headerlink" title="如何做到可靠传输?"></a>如何做到可靠传输?</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">先考虑最简单的情况：<br><span class="hljs-code">    为了保证按序到达：发送方发送一个消息就等待对方发送确认信息，确认收到后才发送下一个。因此TCP提供消息确认机制ACK。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了保证无错误：提供检测错误的能力。比如TCP报文段有一个检验和机制，用来确认是否发生错误。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了保证不丢失：发生丢失则重传该消息。TCP提供超时重传机制(每发送一个分组就启动计时器)。若发送方在一个往返时延RTT没有收到确认信息则认为发生了丢失情况，因此重新发送。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了避免重复：给每个消息一个序号。TCP提供序号机制。如果发送方发送一个分组经历了很大的时延才到达接收方，可能中途已经触发了超时重传，因此会再次发送该分组，结果第一个分组已经到了，第二个相同的分组就成为了冗余分组，通过添加序号机制能够很方便的分辨冗余分组。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h3 id="停等协议效率太低，如何解决？"><a href="#停等协议效率太低，如何解决？" class="headerlink" title="停等协议效率太低，如何解决？"></a>停等协议效率太低，如何解决？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">发送方一个一个发送消息，效率太慢。因此TCP提供了滑动窗口协议，以流水线的形式将窗口内的消息一一发送出去，而不用等待第一个确认正确到达才发送第二个。<br><br>根据接收方的行为不同，提供一下两种协议：<br><br><span class="hljs-code">    回退N帧协议：接收方的接收窗口设置为1，即使发送方以流水线的形式发送多个消息，接收方也是按序接收，出现失序分组则会丢弃，同时返回最后一个正确分组的编号。当接收方收到确认消息，它会将从确认序号继续发送。其缺点是：当窗口很大的时候可能需要重传大量分组。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">    选择重传协议：接收方的接收窗口不再是1，一般设置为发送窗口大小的一半。接收方接受分组的时候，出现在接收窗口内的分组，即使没有按序到达也会先缓存起来，并返回确认信息。直到序号更小的分组到达才一起交付给上层。因此，发送方只需要重新发送未正确接收的分组即可。</span><br></code></pre></td></tr></table></figure><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">作用：抑制发送方的发送速率，避免发送速率比接收方应用程序的读取速率大，导致接收缓冲区的溢出。<br><br>接收方控制发送窗口的大小，当服务端过于繁忙时，发送窗口可能会变为0。这个时候，发送方会启动一个计时器，超时就会发送一个探测报文，如果发送窗口不为0，则发送报文，如果仍然为0，则重启计时器。<br></code></pre></td></tr></table></figure><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nix">为什么需要拥塞控制：<br>    计算机网络是一个共享的环境，在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，就会进入恶性循环。<br><br>作用：发送方维护一个拥塞窗口，它能根据网络环境动态地变换，当发生了超时重传就认为出现了拥塞，从而降低发送量，避免数据填满整个网络。<br><br><br>慢启动：当TCP建立连接后，一点点提升发送量。当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会翻倍，呈指数级增长。<br><br><br>拥塞避免：当 cwnd &gt;= ssthresh(<span class="hljs-number">65535</span>)后，它收到<span class="hljs-number">1</span>个ACK，则cwnd加<span class="hljs-number">1</span>，呈线性增长。<br><br><br>拥塞发生：当发生了重传情况，如果是超时导致的重传，则<span class="hljs-attr">ssthresh</span> = cwnd / <span class="hljs-number">2</span>, <span class="hljs-attr">cwnd</span> = <span class="hljs-number">1</span>, 然后进入慢启动。如果是快速重传，则<span class="hljs-attr">sshtresh</span> = cwnd, <span class="hljs-attr">cwnd</span> = cwnd / <span class="hljs-number">2</span>，然后进入快恢复。<br><br><br>快恢复：<br>    <span class="hljs-number">1</span>、拥塞窗口 <span class="hljs-attr">cwnd</span> = ssthresh + <span class="hljs-number">3</span><br>    <span class="hljs-number">2</span>、重传丢失的数据包<br>    <span class="hljs-number">3</span>、如果再收到重复的 ACK，那么 cwnd 增加 <span class="hljs-number">1</span><br>    <span class="hljs-number">4</span>、如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法<br></code></pre></td></tr></table></figure><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><h4 id="建立连接的过程"><a href="#建立连接的过程" class="headerlink" title="建立连接的过程"></a>建立连接的过程</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">1、客户端随机生成初始化序列号(client_isn)并填充到TCP首部的序号字段中，然后将SYN置为1。然后发送给服务端。该报文不包括应用层数据，之后客户端进入SYN-SEND状态。<br><br>2、服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn）并填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。<br><br>3、客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为<span class="hljs-number"> 1 </span>，其次「确认应答号」字段填入 server_isn +<span class="hljs-number"> 1 </span>，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。<br><br>一旦完成三次握手，双方都处于 ESTABLISHED 状态，此致连接就已建立完成，客户端和服务端就可以相互发送数据了。<br></code></pre></td></tr></table></figure><h4 id="为什么需要三次握手，而不是两次或四次"><a href="#为什么需要三次握手，而不是两次或四次" class="headerlink" title="为什么需要三次握手，而不是两次或四次?"></a>为什么需要三次握手，而不是两次或四次?</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown">一、三次握手才可以阻止历史重复连接的初始化<br><span class="hljs-code">    客户端连续发送多个SYN请求连接报文，在网络拥堵的情况下：</span><br><span class="hljs-code">        1、一个[旧的请求报文]在[新的请求报文]之前到达。</span><br><span class="hljs-code">        2、服务端返回SYN+ACK的确认报文给客户端。</span><br><span class="hljs-code">        3、客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端有足够的上下文来判断当前连接是否是历史连接，从而在第三次发送不同的报文：</span><br><span class="hljs-code">        1、如果是历史连接，则发送RST报文终止此次连接。</span><br><span class="hljs-code">        2、如果是新连接，则发送ACK报文来建立连接。</span><br><span class="hljs-code"></span><br><span class="hljs-code">二、三次握手才可以同步双方的初始序列号</span><br><span class="hljs-code">    序列号在可靠传输中非常的重要。通过序列号：</span><br><span class="hljs-code">        1、接收方能够确定冗余分组</span><br><span class="hljs-code">        2、接收方能够根据序列号按序接收</span><br><span class="hljs-code">        3、可以标识发送出去的数据包中， 哪些是已经被对方收到的</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    因此通信双方都必须确定对方可以正确接收自己的序列号。</span><br><span class="hljs-code">    而两次握手只有客户端确定自己的初始序列号被对方接收，而服务端不确定自己的初始序列号能被对方接收。</span><br><span class="hljs-code"></span><br><span class="hljs-code">三、三次握手才可以避免资源浪费</span><br><span class="hljs-code">    如果只有「两次握手」，当服务端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，从而建立多个冗余的无效链接，造成不必要的资源浪费。</span><br></code></pre></td></tr></table></figure><h4 id="初始序列号是如何生成的？"><a href="#初始序列号是如何生成的？" class="headerlink" title="初始序列号是如何生成的？"></a>初始序列号是如何生成的？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ISN</span> = M + F<br>M是一个计时器。每隔四毫米加<span class="hljs-number">1</span><br>F是一个哈希算法。根据源 <span class="hljs-built_in">IP</span>、目的 <span class="hljs-built_in">IP</span>、源端口、目的端口生成一个随机数值。<br></code></pre></td></tr></table></figure><h4 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">如果只有<span class="hljs-built_in">IP</span>层分片，那么当如果一个 <span class="hljs-built_in">IP</span> 分片丢失，整个 <span class="hljs-built_in">IP</span> 报文的所有分片都得重传。因为<span class="hljs-built_in">IP</span>层没有重传机制，最后还得传输层来进行重传。如果传输层不分片，那么需要传输整个TCP报文段。<br><br>经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。<br></code></pre></td></tr></table></figure><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><h4 id="断开连接的过程"><a href="#断开连接的过程" class="headerlink" title="断开连接的过程"></a>断开连接的过程</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、客户端发送FIN报文，请求关闭连接。客户端之后进入FIN_WAIT_<span class="hljs-number">1</span>状态。<br><span class="hljs-attribute">2</span>、服务端收到后，回复ACK应答报文。服务端之后进入CLOSE_WAIT状态。客户端收到ACK后进入FIN_WAIT_<span class="hljs-number">2</span>状态。<br><span class="hljs-attribute">3</span>、服务端处理完数据后，向客户端发送FIN报文。服务端进入LAST_ACK状态。<br><span class="hljs-attribute">4</span>、客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文。客户端之后进入 TIME_WAIT 状态（主动关闭连接的才有TIME_WAIT状态）。服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。客户端在经过 <span class="hljs-number">2</span>MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。<br></code></pre></td></tr></table></figure><h4 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">关闭连接时，客户端向服务端发送FIN报文，仅仅表示客户端不再向服务端主动发送数据，但是还可以接收数据。<br><br>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。<br><br>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。<br></code></pre></td></tr></table></figure><h4 id="为什么TIME-WAIT状态的等待时间是2MSL？"><a href="#为什么TIME-WAIT状态的等待时间是2MSL？" class="headerlink" title="为什么TIME_WAIT状态的等待时间是2MSL？"></a>为什么TIME_WAIT状态的等待时间是2MSL？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">MSL:</span> 报文最大生存时间。它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<br><br><span class="hljs-symbol">MSL</span> 与 <span class="hljs-meta">TTL</span> 的关系：TCP 报文基于是 <span class="hljs-built_in">IP</span> 协议的，而 <span class="hljs-built_in">IP</span> 头中有一个 <span class="hljs-meta">TTL</span> 字段，是 <span class="hljs-built_in">IP</span> 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 <span class="hljs-number">1</span>，当此值为 <span class="hljs-number">0</span> 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。MSL 的单位是时间，而 <span class="hljs-meta">TTL</span> 是经过路由跳数。所以 MSL 应该要大于等于 <span class="hljs-meta">TTL</span> 消耗为 <span class="hljs-number">0</span> 的时间，以确保报文已被自然消亡。<br><br><span class="hljs-number">2</span>倍的MSL：客户端发送数据给服务端，服务端需要处理之后再返回消息。一来一回就是<span class="hljs-number">2</span>倍的MSL。<br><br><span class="hljs-number">2</span>MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <span class="hljs-number">2</span>MSL 时间将重新计时。<br></code></pre></td></tr></table></figure><h4 id="为什么需要-TIME-WAIT-状态"><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态?"></a>为什么需要 TIME_WAIT 状态?</h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-number">1</span>、防止收到旧连接的数据包而产生数据错乱等严重的问题。<br>    比如：服务端在断开连接之前发送了一个报文被延迟了，这时有相同端口的 TCP 连接被复用后，被延迟的报文抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。<br>    经过 <span class="hljs-number">2</span>MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。<br><br><span class="hljs-number">2</span>、确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。<br>    假如TIME_WAIT时间过短，那么第四步挥手主动关闭方发送完ACK就会马上进入<span class="hljs-keyword">CLOSE</span>状态，但是这个ACK可能会丢失从而导致被动关闭方一直处于LAST_ACK状态。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>传输层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FTP</title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/FTP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/FTP/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>FTP是文件传输协议，使用TCP提供可靠传输，一个FTP服务器可以为多个客户进程提供服务。</li><li>FTP使用两个并行的TCP连接，一个是控制连接(21端口), 一个数据连接(20端口)。</li></ul></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 服务端监听<span class="hljs-number">21</span>号端口，等待客户端的连接<br><span class="hljs-comment">(2)</span> 客户端发起连接请求后，启动数据连接处理客户端请求，处理完毕后，数据连接关闭。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DHCP</title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>DHCP协议是：动态主机配置协议，用来动态的给加入网络的主机分配IP地址。</li><li>DHCP客户端使用UDP协议，端口号68</li><li>DHCP服务端使用TCP协议，端口号67</li></ul></blockquote><h3 id="DHCP的工作流程"><a href="#DHCP的工作流程" class="headerlink" title="DHCP的工作流程"></a>DHCP的工作流程</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-number">1</span>) 一个新加入的主机，需要向DHCP服务器申请<span class="hljs-built_in">IP</span>地址。由于刚开始它没有<span class="hljs-built_in">IP</span>地址，因此它源<span class="hljs-built_in">IP</span>地址全部设为<span class="hljs-number">0</span>，目的<span class="hljs-built_in">IP</span>地址全部设为<span class="hljs-number">1</span>. 以广播的方式发送DHCPDISCOVER报文。<br><br>(<span class="hljs-number">2</span>) 凡是收到DHCPDISCOVER报文的DHCP服务器都发出DHCP提供报文，DHCP客户端从中选择一个，并向所选择的DHCP服务器发送DHCP请求报文。<br><br>(<span class="hljs-number">3</span>) 被选择的DHCP服务器发送DHCPACK的确认报文并提供<span class="hljs-built_in">IP</span>地址给DHCP客户端使用。DHCP客户端设置使用时限。<br><br>(<span class="hljs-number">4</span>) 当使用时限过半时，DHCP客户端申请重新设置计时器。如果服务器同意则发回确认报文DHCPACK，客户端继续使用<span class="hljs-built_in">IP</span>；否则发送否认报文DHCPNACK，客户端需要重新申请<span class="hljs-built_in">IP</span>。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>DHCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS</title>
    <link href="/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/"/>
    <url>/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>DNS提供的服务：提供主机名到IP地址的解析功能。</li><li>DNS协议运行于UDP协议之上，使用53号端口。</li></ul></blockquote><h3 id="DNS工作步骤"><a href="#DNS工作步骤" class="headerlink" title="DNS工作步骤"></a>DNS工作步骤</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) 用户输入网址，浏览器首先检查是否有主机名到IP地址的映射缓存<br>(<span class="hljs-number">2</span>) 没有就检查本地host文件看是否有<br>(<span class="hljs-number">3</span>) 没有就询问本地DNS服务器<br>(<span class="hljs-number">4</span>) 本地DNS服务器没有的话，就会询问根DNS服务器<br>(<span class="hljs-number">5</span>) 根DNS服务器返回顶级域服务器地址，本地DNS服务器接着询问顶级域服务器<br>(<span class="hljs-number">6</span>) 顶级域服务器返回权威DNS服务器地址，本地DNS服务器接着询问权威DNS服务器地址。<br>(<span class="hljs-number">7</span>) 权威DNS服务器返回IP地址返回给本地DNS服务器。<br>(<span class="hljs-number">8</span>) 本地DNS服务器将结果返回给主机。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP(%E9%87%8D%E8%A6%81)/"/>
    <url>/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP(%E9%87%8D%E8%A6%81)/</url>
    
    <content type="html"><![CDATA[<h3 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h3><blockquote><ul><li>HTTP(超文本传输协议)是web应用所使用的协议</li><li>HTTP使用TCP作为它的支撑运输的协议</li><li>HTTP是无状态的协议</li></ul></blockquote><h3 id="非持续连接-vs-持续连接"><a href="#非持续连接-vs-持续连接" class="headerlink" title="非持续连接 vs 持续连接"></a>非持续连接 vs 持续连接</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">非持续连接：每一个请求/响应对都是经过单独的TCP连接。<br>持续连接：所有的请求/响应对都是经过同一个TCP连接。<br><br>比如：客户端向服务端发送一个HTTP请求，假设该请求页面包含<span class="hljs-number">1</span>个<span class="hljs-selector-tag">HTML</span>页面和<span class="hljs-number">10</span>个JPEG图片，那么采用非持续连接就需要建立<span class="hljs-number">11</span>次TCP连接，而采用持续连接仅需要一个TCP连接。<br></code></pre></td></tr></table></figure><h3 id="HTTP请求格式和响应格式"><a href="#HTTP请求格式和响应格式" class="headerlink" title="HTTP请求格式和响应格式"></a>HTTP请求格式和响应格式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">请求报文:<br><span class="hljs-code">    请求行：</span><br><span class="hljs-code">        方法 URL 版本</span><br><span class="hljs-code"></span><br><span class="hljs-code">    首部行: </span><br><span class="hljs-code">        host</span><br><span class="hljs-code">        Connection</span><br><span class="hljs-code">        ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    实体：</span><br><span class="hljs-code"></span><br><span class="hljs-code">响应报文：</span><br><span class="hljs-code">    状态行:</span><br><span class="hljs-code">        版本 状态码 短语</span><br><span class="hljs-code"></span><br><span class="hljs-code">    首部行：</span><br><span class="hljs-code">        Connection</span><br><span class="hljs-code">        Date</span><br><span class="hljs-code">        Last-Modified</span><br><span class="hljs-code">        Content-Length</span><br><span class="hljs-code">        Content-Type</span><br><span class="hljs-code">        ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    实体：</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h3 id="HTTP常见的状态码和含义"><a href="#HTTP常见的状态码和含义" class="headerlink" title="HTTP常见的状态码和含义"></a>HTTP常见的状态码和含义</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">200</span>: 成功<br><span class="hljs-number">204</span>：与<span class="hljs-number">200</span>相同，响应头没有body数据<br><span class="hljs-number">206</span>：是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。<br><br><span class="hljs-number">301</span>:表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。<br><span class="hljs-number">302</span>：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br><span class="hljs-symbol">301 </span>和 <span class="hljs-number">302</span> 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。<br><br><span class="hljs-number">400</span>:表示客户端请求的报文有错误<br><span class="hljs-number">403</span>:表示服务器禁止访问资源<br><span class="hljs-number">404</span>:资源未找到<br><br><span class="hljs-number">500</span>:与 <span class="hljs-number">400</span> 类型，是个笼统通用的错误码<br><span class="hljs-number">503</span>:表示服务器当前很忙，暂时无法响应服务器<br></code></pre></td></tr></table></figure><h3 id="Get-和-Post-的区别"><a href="#Get-和-Post-的区别" class="headerlink" title="Get 和 Post 的区别"></a>Get 和 Post 的区别</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Get:向服务器获取资源; Post向指定的URI提交数据，数据保存在<span class="hljs-selector-tag">body</span>中。<br>Get:是安全且幂等的; Post不是安全也不是幂等的。<br><br>安全性：请求方法不会「破坏」服务器上的资源。<br>幂等性: 多次执行相同的操作，结果都是「相同」的。<br></code></pre></td></tr></table></figure><h3 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">由于HTTP是无状态协议，如果想要保存用户的状态信息，则出现了Cookie机制和<span class="hljs-keyword">Session</span>机制。<br><br>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，获取状态信息。<br><br>然后Cookie需要保存的信息比较多，比如<span class="hljs-type">name</span>，<span class="hljs-keyword">value</span>，maxAge等。如果HTTP请求每次都需要携带Cookie完整信息，那么增加了客户端与服务端的数据传输量。因此就出现了<span class="hljs-keyword">Session</span>机制，同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 SessionID。<br><br><span class="hljs-keyword">Session</span>是一种服务端的机制，用户信息保存在服务器端，服务端为每一个客户创建<span class="hljs-keyword">Session</span>并利用SessionID进行关联。<br></code></pre></td></tr></table></figure><h3 id="HTTP-和-HTTPS-有哪些区别？"><a href="#HTTP-和-HTTPS-有哪些区别？" class="headerlink" title="HTTP 和 HTTPS 有哪些区别？"></a>HTTP 和 HTTPS 有哪些区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之操作系统</title>
    <link href="/2021/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="OSI七层模型？"><a href="#OSI七层模型？" class="headerlink" title="OSI七层模型？"></a>OSI七层模型？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">物理层：通过媒介传输比特,确定机械及电气范围。<span class="hljs-comment">(比特)</span><br>数据链路层：将比特组装成帧和点到点的传递。<span class="hljs-comment">(帧)</span><br>网络层：负责数据包从源到宿的传递和网际互连。<span class="hljs-comment">(包)</span><br>传输层: 提供端到端的可靠报文传递和错误恢复。<span class="hljs-comment">(段)</span><br>会话层：建立、管理和终止会话。<span class="hljs-comment">(会话协议数据单元)</span><br>表示层：对数据进行翻译、加密和压缩。<span class="hljs-comment">(表示协议数据单元)</span><br>应用层: 允许方法OSI环境的手段。<span class="hljs-comment">(应用协议数据单元)</span><br></code></pre></td></tr></table></figure><h2 id="从一个URL到获取页面的过程？"><a href="#从一个URL到获取页面的过程？" class="headerlink" title="从一个URL到获取页面的过程？"></a>从一个URL到获取页面的过程？</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(<span class="hljs-number">1</span>) 浏览器查询DNS，获取域名对应的<span class="hljs-built_in">IP</span>地址。具体过程包括: 浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的host文件、像本地DNS服务器进行查询。<br><br>(<span class="hljs-number">2</span>) 获取对应的<span class="hljs-built_in">IP</span>地址以后，向服务器请求建立连接，发起TCP三次握手。<br><br>(<span class="hljs-number">3</span>) 连接建立以后，浏览器发起HTTP请求<br><br>(<span class="hljs-number">4</span>) 浏览器收到请求以后，处理请求并返回相应的视图。<br><br>(<span class="hljs-number">5</span>) 浏览器解析并渲染视图。如果有对<span class="hljs-keyword">js</span>、css及图片等静态资源的引用，则重复HTTP请求获取相应的资源。<br><br>(<span class="hljs-number">6</span>) 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。<br></code></pre></td></tr></table></figure><h3 id="Session的实现原理-和-Cookie的实现原理？"><a href="#Session的实现原理-和-Cookie的实现原理？" class="headerlink" title="Session的实现原理 和 Cookie的实现原理？"></a>Session的实现原理 和 Cookie的实现原理？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。<br><br><span class="hljs-keyword">Session</span> 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。使用上比 Cookie 简单一些，相应的也增加了服务器的存储压力。<br><br>总体来说：Cookie 通过在客户端记录信息确定用户身份，<span class="hljs-keyword">Session</span> 通过在服务器端记录信息确定用户身份。<br></code></pre></td></tr></table></figure><h3 id="Session和Cooike的关系？禁用Cookie对Session的影响？"><a href="#Session和Cooike的关系？禁用Cookie对Session的影响？" class="headerlink" title="Session和Cooike的关系？禁用Cookie对Session的影响？"></a>Session和Cooike的关系？禁用Cookie对Session的影响？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Session</span> 的实现常常依赖于 Cookie 机制。一般默认情况下，服务器存储 <span class="hljs-keyword">session</span> 的 sessionid 是通过 cookie 存到浏览器里。如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，<span class="hljs-keyword">session</span> 失效。但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用 <span class="hljs-keyword">session</span>。<br><br><span class="hljs-number">1</span>、通过 url 重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中 携带 sessionid 参数。<br><span class="hljs-number">2</span>、服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。<br><span class="hljs-number">3</span>、通过 Http 协议其他 <span class="hljs-keyword">header</span> 字段，服务器每次返回时设置该 <span class="hljs-keyword">header</span> 字段信息，浏览器中 js 读取该 <span class="hljs-keyword">header</span> 字段，请求服务器时，js 设置携带该 <span class="hljs-keyword">header</span> 字段。<br></code></pre></td></tr></table></figure><h3 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">forward 是服务器请求资源，服务器直接访问目标地址的 <span class="hljs-built_in">URL</span>, 把那个 <span class="hljs-built_in">URL</span> 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址.<br><br>redirect 是服务端根据逻辑，发送一个状态码 , 告诉浏览器重新去请求那个地址。所以地址栏显示的是新的<span class="hljs-built_in">URL</span>.<br></code></pre></td></tr></table></figure><h3 id="内网和外网的区别？ABC三类地址的划分？"><a href="#内网和外网的区别？ABC三类地址的划分？" class="headerlink" title="内网和外网的区别？ABC三类地址的划分？"></a>内网和外网的区别？ABC三类地址的划分？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">外网 <span class="hljs-built_in">IP</span> 是全世界唯一的 <span class="hljs-built_in">IP</span> 地址，仅分配给一个网络设备。公网 <span class="hljs-built_in">IP</span> 地址全世界仅分配给一个网络设备。<br><br>内网 <span class="hljs-built_in">IP</span> 局域网，网线都是连接在同一个 交换机上面的，也就是说它们的 <span class="hljs-built_in">IP</span> 地址是由交换机或者路由器进行分配的。内网用户的电脑都是经过交换机和路由器之后才能连到 外网。Internet 上的用户也无法直接访问到内网用户。不同内网的内网地址可以相同。<br><br><span class="hljs-built_in">IP</span>地址 = 网络地址 + 主机地址。<br>A类网络：以<span class="hljs-number">0</span>开头前<span class="hljs-number">8</span>位。<span class="hljs-number">0</span> ~ <span class="hljs-number">127</span><br>B类地址：以<span class="hljs-number">10</span>开头前<span class="hljs-number">16</span>位。<span class="hljs-number">128</span> ~ <span class="hljs-number">191</span><br>C类地址：以<span class="hljs-number">110</span>开头前<span class="hljs-number">24</span>位。<span class="hljs-number">192</span> ~ <span class="hljs-number">223</span><br></code></pre></td></tr></table></figure><h3 id="网关和子网掩码的关系？"><a href="#网关和子网掩码的关系？" class="headerlink" title="网关和子网掩码的关系？"></a>网关和子网掩码的关系？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">子网掩码：用来判断任意两台计算机的 <span class="hljs-built_in">ip</span> 地址是否属于同一子网络的根据。<br><br>网关实质上是一个在不同子段网路中传输数据的设备。<br><br>子网掩码相同，不需要网关即可通讯，子网掩码不同，需要网关才能通讯。<br></code></pre></td></tr></table></figure><h3 id="MAC地址和IP地址的关系？"><a href="#MAC地址和IP地址的关系？" class="headerlink" title="MAC地址和IP地址的关系？"></a>MAC地址和IP地址的关系？</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">MAC</span> 地址是硬件地址，定位全球唯一主机机器，在网络底层的物理传输过程中，是通 过物理地址来识别主机的，它一定是全球唯一的，对应数据链路层。<br><br>IP 地址是网络拓扑地址，定位全球唯一网络结构中的主机。对应网路层。<br></code></pre></td></tr></table></figure><h3 id="什么是DNS服务器？"><a href="#什么是DNS服务器？" class="headerlink" title="什么是DNS服务器？"></a>什么是DNS服务器？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DNS</span> 是指：域名服务器 (Domain Name Server)。在 Internet 上域名与 <span class="hljs-built_in">IP</span> 地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识 <span class="hljs-built_in">IP</span> 地址，它们之间的转 换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 就是进行域名解析的服务器 。一个<span class="hljs-built_in">ip</span>是可以供多个域名解析的,但是域名解析到的一个地址是一对一的。底层使用UDP协议。<br></code></pre></td></tr></table></figure><h3 id="IP如何映射到MAC地址？"><a href="#IP如何映射到MAC地址？" class="headerlink" title="IP如何映射到MAC地址？"></a>IP如何映射到MAC地址？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用ARP协议, 位于网络层。<br><br>工作原理:<br>    (<span class="hljs-number">1</span>) 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 <span class="hljs-built_in">IP</span> 地址和 MAC 地址之间的对应关系。当源主机要发送数据时，首先检查 ARP 列表中是否有对应 <span class="hljs-built_in">IP</span> 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 ARP 数据包。<br><br>    (<span class="hljs-number">2</span>) 当本网络的所有主机收到该 ARP 数据包时，首先检查数据包中的 <span class="hljs-built_in">IP</span> 地址是否是自己 的 <span class="hljs-built_in">IP</span> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <span class="hljs-built_in">IP</span> 和 MAC 地址写入到 ARP 列表中, 然后将自己的MAC地址回复给源主机。<br><br>    (<span class="hljs-number">3</span>) 如果目标 <span class="hljs-built_in">IP</span> 与自己不在同一个网段，这种情况需要将包发给默认网关，所以主要获取网关的 MAC 地址。<br></code></pre></td></tr></table></figure><h3 id="TCP是如何保证可靠传输的？"><a href="#TCP是如何保证可靠传输的？" class="headerlink" title="TCP是如何保证可靠传输的？"></a>TCP是如何保证可靠传输的？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">保证可靠传输最主要的是：<br>    <span class="hljs-comment">(1)</span> 拥塞控制<br>    <span class="hljs-comment">(2)</span> 流量控制<br>    <span class="hljs-comment">(3)</span> ARQ协议<br>    <br>    除此之外还有：超时传送、丢弃重复、校验和、分割合适数据包。<br></code></pre></td></tr></table></figure><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h3 id="TCP-和-UDP-的区别？"><a href="#TCP-和-UDP-的区别？" class="headerlink" title="TCP 和 UDP 的区别？"></a>TCP 和 UDP 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">TCP：面向连接、面向字节流、一对一； UDP：无连接、面向报文、一对一、一对多、 多对多。 <br><br>TCP 的优点：可靠，稳定. 缺点：慢，效率低，占用系统资源高，易被攻击 <br><br>UDP 的优点：快，UDP 是一个无状态的传输协议 缺点： 不可靠，不稳定<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数DP</title>
    <link href="/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%A1%E6%95%B0DP/"/>
    <url>/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%A1%E6%95%B0DP/</url>
    
    <content type="html"><![CDATA[<h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">一个正整数 <span class="hljs-built_in">n</span> 可以表示成若干个正整数之和，形如：<span class="hljs-built_in">n</span>=<span class="hljs-symbol">n1</span>+<span class="hljs-symbol">n2</span>+…+nk，其中 <span class="hljs-symbol">n1</span>≥<span class="hljs-symbol">n2</span>≥…≥nk,k≥<span class="hljs-number">1</span>。<br><br>我们将这样的一种表示称为正整数 <span class="hljs-built_in">n</span> 的一种划分。<br><br>现在给定一个正整数 <span class="hljs-built_in">n</span>，请你求出 <span class="hljs-built_in">n</span> 共有多少种不同的划分方法。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC312_戳气球</title>
    <link href="/2021/03/22/%E7%AE%97%E6%B3%95/LC0312_%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <url>/2021/03/22/%E7%AE%97%E6%B3%95/LC0312_%E6%88%B3%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs inform7">有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。<br><br>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums<span class="hljs-comment">[i - 1]</span> * nums<span class="hljs-comment">[i]</span> * nums<span class="hljs-comment">[i + 1]</span> 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。<br><br>求所能获得硬币的最大数量。<br><br> <br>示例 1：<br>输入：nums = <span class="hljs-comment">[3,1,5,8]</span><br>输出：167<br>解释：<br>    nums = <span class="hljs-comment">[3,1,5,8]</span> --&gt; <span class="hljs-comment">[3,5,8]</span> --&gt; <span class="hljs-comment">[3,8]</span> --&gt; <span class="hljs-comment">[8]</span> --&gt; <span class="hljs-comment">[]</span><br>    coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167<br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[1,5]</span><br>输出：10<br></code></pre></td></tr></table></figure><h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 打完所有[i+1, j-1]的气球所能获得的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以最后一个气球作为分界点</span><br><span class="hljs-comment">             (第i+1个 | 第i+2个 | 第k个 | ... | 第j-1个)</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    则dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 辅助数组。首尾添加1</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];<br>    temp[<span class="hljs-number">0</span>] = temp[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        temp[i+<span class="hljs-number">1</span>] = nums[i];<br>    <br>    <span class="hljs-comment">// 枚举长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">3</span>; len &lt;= n + <span class="hljs-number">2</span>; len++) &#123;<br>        <span class="hljs-comment">// 枚举左边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;= n + <span class="hljs-number">2</span> - len; l++) &#123;<br>            <span class="hljs-comment">// 确定右边界</span><br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 枚举切割点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l + <span class="hljs-number">1</span>; k &lt; r; k++)<br>                dp[l][r] = Math.max(dp[l][r], dp[l][k] + dp[k][r] + temp[l] * temp[k] * temp[r]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">设有 <span class="hljs-built_in">N</span> 堆石子排成一排，现在要将这 <span class="hljs-built_in">N</span> 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和,找出一种合理的方法，使总的代价最小，输出最小代价。<br></code></pre></td></tr></table></figure><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 所有将第i堆到第j堆合并为一个的方案中的代价的最小值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以最后一次的分界线来分类。</span><br><span class="hljs-comment">             (第i堆和[i+1, j]合并 | [i, i + 1]与[i + 2, j]合并 | ... | [i, j - 1] 和第j堆合并)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j] = dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1];</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] pre;<br><span class="hljs-keyword">int</span>[][] dp;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 处理前缀和</span><br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] + nums[i];<br>    <br>    dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br><br>    helper(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 合并区间[l, r]的最小代价</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (dp[l][r] != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> dp[l][r];<br>    <br>    <span class="hljs-comment">// 枚举每个分界线</span><br>    <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt; r; k++) &#123;<br>        res = Math.min(res, helper(nums, l, k) + helper(nums, k + <span class="hljs-number">1</span>, r) + pre[r] - pre[l - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[l][r] = res;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性DP</title>
    <link href="/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。<br><br>        7<br>     <span class="hljs-number"> 3 </span>  8<br>   <span class="hljs-number"> 8 </span> <span class="hljs-number"> 1 </span>  0<br> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 7 </span> <span class="hljs-number"> 4 </span>  4<br>4  <span class="hljs-number"> 5 </span> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 6 </span>  5<br></code></pre></td></tr></table></figure><h4 id="方法1：自顶向下"><a href="#方法1：自顶向下" class="headerlink" title="方法1：自顶向下"></a>方法1：自顶向下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    7</span><br><span class="hljs-comment">    3 8</span><br><span class="hljs-comment">    8 1 0</span><br><span class="hljs-comment">    2 7 4 4</span><br><span class="hljs-comment">    4 5 2 6 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 所有从(0, 0)走到(i, j)的路径的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从上面来 | 从左上方来)</span><br><span class="hljs-comment">             max(dp[i-1][j] | dp[i-1][j-1]) + matrix[i][j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++) <br>            dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= col; k++)<br>        xMax = Math.max(dp[row][k], xMax);<br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br><span class="hljs-comment">// 优化：跟01背包相似，都与第i-1层的第j个和第j-1个有关</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[col + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j-<span class="hljs-number">1</span>]) + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= col; k++)<br>        xMax = Math.max(dp[k], xMax);<br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2：自底向上"><a href="#方法2：自底向上" class="headerlink" title="方法2：自底向上"></a>方法2：自底向上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    7</span><br><span class="hljs-comment">    3 8</span><br><span class="hljs-comment">    8 1 0</span><br><span class="hljs-comment">    2 7 4 4</span><br><span class="hljs-comment">    4 5 2 6 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 所有从最底部走到(i, j)的路径的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从下面来 | 从右下方来)</span><br><span class="hljs-comment">             max(dp[i+1][j] | dp[i+1][j+1]) + matrix[i][j]</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个长度为 <span class="hljs-built_in">N</span> 的数列，求数值严格单调递增的子序列的长度最长是多少。<br><br>子序列：不要求连续<br></code></pre></td></tr></table></figure><h4 id="方法1：朴素版"><a href="#方法1：朴素版" class="headerlink" title="方法1：朴素版"></a>方法1：朴素版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i]：以下标i结尾的最长上升子序列的长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(比nums[0]大 | 比nums[1]大 | ... | 比nums[i-1]大)</span><br><span class="hljs-comment">            max(dp[0] | dp[1] | ... | dp[n - 1]) + 1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        xMax = Math.max(dp[i], xMax);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="方法2：二分法优化"><a href="#方法2：二分法优化" class="headerlink" title="方法2：二分法优化"></a>方法2：二分法优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于二分法的优化。</span><br><span class="hljs-comment">    g[i]: 最大长度为i的递增子序列中序列的最小值</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    那么在遍历nums[i]的过程中，只需要在g[]中寻找 &lt; nums[i] 的右边界r，那么 dp[i] = r + 1; g[r + 1] = nums[i]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    g[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <br>        <span class="hljs-comment">// 在g[]中寻找 &lt; nums[i] 的右边界</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g[mid] &lt; nums[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前最大长度</span><br>        len = Math.max(len, r + <span class="hljs-number">1</span>);<br>        g[r + <span class="hljs-number">1</span>] = nums[i];<br>        dp[i] = r + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="延申：打印字典序最小的最长上升子序列"><a href="#延申：打印字典序最小的最长上升子序列" class="headerlink" title="延申：打印字典序最小的最长上升子序列"></a>延申：打印字典序最小的最长上升子序列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 假如说我们已经拿到了dp[] 和 xMax</span><br><br>    <span class="hljs-comment">// 如果出现dp[i] = 3, dp[i + 1] = 3, 那么显然nums[i+1] &lt; nums[i]。因此后者才是字典序最小的。</span><br><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[xMax];<br>    <span class="hljs-keyword">int</span> k = xMax - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = xMax; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// dp[i] == j, 则添加进res中</span><br>        <span class="hljs-keyword">if</span> (dp[i] == j) &#123;<br>            res[k--] = nums[i];<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个长度分别为 N 和 M 的字符串 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，求既是 <span class="hljs-selector-tag">A</span> 的子序列又是 <span class="hljs-selector-tag">B</span> 的子序列的字符串长度最长是多少。<br></code></pre></td></tr></table></figure><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 所有 即出现在第一个序列的前i个字符中，且出现在第二个序列的前j个字符中 的子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以 a[i] 和 b[j] 是否包含在子序列中为划分依据</span><br><span class="hljs-comment">         max (包含a[i] | 包含b[j] | 都包含 | 都不包含)</span><br><span class="hljs-comment">         max (dp[i][j-1] | dp[i-1][j] | dp[i-1][j-1] + 1 | dp[i-1][j-1])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>    <span class="hljs-comment">// 子序列没有连续的要求</span><br>    <span class="hljs-comment">// dp[i][j]: 字符串1的前i个字符和字符串2前j个字符的最长公共子序列的长度</span><br><br>    <span class="hljs-keyword">int</span> n = text1.length();<br>    <span class="hljs-keyword">int</span> m = text2.length();<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 包含s1[i]或者s2[j]</span><br>            dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>]);<br><br>            <span class="hljs-comment">// 如果s1[i] == s2[j], 则包含s1[i]和s2[j]</span><br>            <span class="hljs-keyword">if</span> (text1.charAt(i) == text2.charAt(j))<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>], dp[i][j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个字符串 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，现在要将 <span class="hljs-selector-tag">A</span> 经过若干操作变为 <span class="hljs-selector-tag">B</span>，可进行的操作有：<br>    删除–将字符串 <span class="hljs-selector-tag">A</span> 中的某个字符删除。<br>    插入–在字符串 <span class="hljs-selector-tag">A</span> 的某个位置插入某个字符。<br>    替换–将字符串 <span class="hljs-selector-tag">A</span> 中的某个字符替换为另一个字符。<br>现在请你求出，将 <span class="hljs-selector-tag">A</span> 变为 <span class="hljs-selector-tag">B</span> 至少需要进行多少次操作。<br></code></pre></td></tr></table></figure><h4 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = word1.length();<br>    <span class="hljs-keyword">int</span> n = word2.length();<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 需要增dp[i][j+1]、删dp[i+1][j]、改dp[i][j]的情况</span><br>            dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(dp[i][j+<span class="hljs-number">1</span>], Math.min(dp[i][j], dp[i+<span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">// 相等则啥也不用改</span><br>            <span class="hljs-keyword">if</span> (word1.charAt(i) == word2.charAt(j))<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>], dp[i][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2021/03/20/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/20/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    01背包模型：</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品只能选择一次。</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">        (选第i物品[前提是能装得下] | 不选第i个物品)</span><br><span class="hljs-comment">        (dp[i - 1][j - v[i]] + w[i] | dp[i - 1][j])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版本</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag01</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-comment">// 不选择第i个物品</span><br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br><br>            <span class="hljs-comment">// 选取第i个物品</span><br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) <br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    优化版</span><br><span class="hljs-comment">    dp[i]这一层仅使用到了dp[i-1]这一层，因此可以优化为一维。</span><br><span class="hljs-comment">    由于第i层的是通过第i-1层的第j位和第j-v[i]位来更新，因此优化成1维的时候，必须保证j-v[i]还没有被覆盖。因此需要从大到小进行更新。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag01</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;= v[i]; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    完全背包模型:</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品可以选取无数次。</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">            (不选第i个物品 | 选1个 | 选2个 | ... | 选k个)</span><br><span class="hljs-comment">            (dp[i-1][j] | dp[i-1][j - v[i]] + w[i] | dp[i-1][j - 2 * v[i]] + 2 * w[i] | ... | dp[i-1][j - k * v[i]] + k * w[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k++)<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化1：</span><br><span class="hljs-comment">    dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2v] + 2w + .... + dp[i-1][j-kv] + kw)</span><br><span class="hljs-comment">    dp[i][j-v] = max(          dp[i-1][j-v], dp[i-1][j-2v] + w, ... + dp[i-1][j-kv] + (k-1)w)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    因此dp[i][j] = max(dp[i-1][j], dp[i][j-v] + w) </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i+<span class="hljs-number">1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化2：</span><br><span class="hljs-comment">        dp[i][j]需要第i-1层的第j个和第i层的第j-v[i]个有关。因此可以优化成一维。</span><br><span class="hljs-comment">        需要保证j从小到大更新。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag03</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v[i]; j &lt;= V; j++) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    多重背包模型：</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品最多包含s个。</span><br><span class="hljs-comment">        s[i]: 第i个物品的个数</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">            (不选第i个物品 | 选1个 | 选2个 | ... | 选s个)</span><br><span class="hljs-comment">            (dp[i-1][j] | dp[i-1][j - v[i]] + w[i] | dp[i-1][j - 2 * v[i]] + 2 * w[i] | ... | dp[i-1][j - s * v[i]] + s * w[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] s, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">// 优化版：二进制优化, 将s[i]分解成1、2、4、8..., 然后转换成01背包问题</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (k &lt;= s) &#123;<br>    v[cnt] = a * k;<br>    w[cnt] = b * k;<br>    s -= k;<br>    k *= <span class="hljs-number">2</span>;<br>    cnt++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>    v[cnt] = a * s;<br>    w[cnt] = b * s;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合背包"><a href="#组合背包" class="headerlink" title="组合背包"></a>组合背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    组合背包模型：</span><br><span class="hljs-comment">        有N组物品和一个容量为V的背包，每个组只能选择一个。</span><br><span class="hljs-comment">        v[i][k]: 第i组的第k个物品的体积</span><br><span class="hljs-comment">        w[i][k]: 第i组的第k个物品的价值</span><br><span class="hljs-comment">        s[i]: 第i组一共有多少个物品</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(不从第i组选择 | 从第i组选第1个物品 | ... | 从第i组选第k个物品)</span><br><span class="hljs-comment">             (dp[i-1][j] | dp[i-1][j - v[i-1][1]] + w[i-1][1] | ... | dp[i-1][j - v[i-1][k]] + w[i-1][k])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag04</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] v, <span class="hljs-keyword">int</span>[][] w, <span class="hljs-keyword">int</span>[] s, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-comment">// 不选择</span><br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k++) &#123;<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - v[i][k] + w[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化：第i层的第j个只与第i-1层的第j个和第i-1层的第j-v[i][k]有关，因此优化方案与01背包一样</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i][k])<br>                dp[j] = Math.max(dp[j], dp[j - v[i][k] + w[i][k]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之Java基础</title>
    <link href="/2021/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BJava%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BJava%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="StringBuilder-和-StringBuffer-的异同点"><a href="#StringBuilder-和-StringBuffer-的异同点" class="headerlink" title="StringBuilder 和 StringBuffer 的异同点"></a>StringBuilder 和 StringBuffer 的异同点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">相同点：底层都是<span class="hljs-keyword">char</span>数组<br>不同点：前者是线程不安全的，后者是线程安全的(通过Synchronized修饰)<br></code></pre></td></tr></table></figure><h3 id="Java数组对象的内存分配"><a href="#Java数组对象的内存分配" class="headerlink" title="Java数组对象的内存分配"></a>Java数组对象的内存分配</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">基础类型的数组，分配在栈内存中，是连续分配的。<br><br>对象数组，对象引用连续分配在栈内存中。实际对象分配在堆内存，不是连续分配的<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="创建对象的方式有哪些？"><a href="#创建对象的方式有哪些？" class="headerlink" title="创建对象的方式有哪些？"></a>创建对象的方式有哪些？</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) new<br>(<span class="hljs-number">2</span>) clone()<br>(<span class="hljs-number">3</span>) 反射<br>(<span class="hljs-number">4</span>) 序列化<br></code></pre></td></tr></table></figure><h3 id="深拷贝-和-浅拷贝"><a href="#深拷贝-和-浅拷贝" class="headerlink" title="深拷贝 和 浅拷贝"></a>深拷贝 和 浅拷贝</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">浅拷贝：在堆内存中，将该对象复制了一份，也就是说产生了一个新的对象。<br><span class="hljs-code">       新对象的属性如果是基本类型，拷贝的就是基本类型的值；</span><br><span class="hljs-code">       如果属性是引用类型，拷贝的就是内存地址。</span><br><span class="hljs-code"></span><br><span class="hljs-code">深拷贝：在堆内存中，将该对象复制了一份，也就是说产生了一个新的对象。</span><br><span class="hljs-code">       在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</span><br></code></pre></td></tr></table></figure><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">== 用来比较栈中的值是否相等。对于基础类型直接比较值，对于引用类型比较地址值。</span><br><br>equals 用来比较堆中对象的内容是否相等。<br><br>Object类中的equals()用的是 ==, 因此如果不重写equals()的话，相当于使用 ==。<br></code></pre></td></tr></table></figure><h3 id="自动拆箱和自动装箱"><a href="#自动拆箱和自动装箱" class="headerlink" title="自动拆箱和自动装箱"></a>自动拆箱和自动装箱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">拆箱和装箱是指：基础类型和它们对应的包装类之间的转换。拆箱是把包装类型变成基本类型；装箱是把基本类型变成包装类型。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    <url>/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 堆是一个完全二叉树</span><br><span class="hljs-comment">// 核心操作：down(int x) 和 up(int x)</span><br><span class="hljs-comment">// 如果是从下标0开始，则父亲下标为(x - 1) / 2; 如果是从下标1开始，则父亲下标为 x / 2;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(size);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            data.add(arr[i]);<br>        <br>        <span class="hljs-comment">// 从最后一个叶子节点的父节点开始进行down, 即可O(N)实现堆化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            down(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 上浮操作 : 用于添加元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 当不是根节点时，不断与其父节点进行比较。</span><br>        <span class="hljs-comment">// 如果比根节点更小，则进行交换。继续上浮</span><br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; data.get(index) &lt; data.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &#123;<br>            Collections.swap(data, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始t为当前节点，代表值最小的位置</span><br>        <span class="hljs-keyword">int</span> t = index;<br>        <span class="hljs-comment">// 如果左孩子存在，当前最小节点则与左孩子进行比较。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span> &lt; data.size() &amp;&amp; data.get(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>) &lt; data.get(t))<br>            t = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 如果右孩子存在，当前最小节点则与左孩子进行比较。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span> &lt; data.size() &amp;&amp; data.get(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>) &lt; data.get(t))<br>            t = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 如果当前节点不是最小节点，则进行交换。继续下沉。</span><br>        <span class="hljs-keyword">if</span> (t != index) &#123;<br>            Collections.swap(data, t, index);<br>            down(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-comment">// 末尾添加新元素，然后不断上浮</span><br>        data.add(v);<br>        up(data.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 提取堆顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = data.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 末尾元素与堆顶元素交换，然后不断下沉</span><br>        Collections.swap(data, <span class="hljs-number">0</span>, data.size() - <span class="hljs-number">1</span>);<br>        data.remove(data.size() - <span class="hljs-number">1</span>);<br>        down(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集[Acwing]</title>
    <link href="/2021/03/18/Acwing/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/03/18/Acwing/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Acwing837-连通块中点的数量"><a href="#Acwing837-连通块中点的数量" class="headerlink" title="Acwing837_连通块中点的数量"></a>Acwing837_连通块中点的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 合并两个集合：必须先累加size再合并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            size[find(b)] += size[find(a)];<br>            p[find(a)] = find(b);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回x所在连通块的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size[find(x)];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing240-食物链"><a href="#Acwing240-食物链" class="headerlink" title="Acwing240_食物链"></a>Acwing240_食物链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要额外维护当前节点到根节点的距离</span><br><span class="hljs-comment">// 到根节点距离为0 : 与根节点同类</span><br><span class="hljs-comment">// 到根节点距离为1 : 能够吃根节点</span><br><span class="hljs-comment">// 到根节点距离为2 : 能够被根节点吃</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩过程中维护到根节点的距离</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                root</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">              /   d[p[x]]</span><br><span class="hljs-comment">            p[x]</span><br><span class="hljs-comment">            /</span><br><span class="hljs-comment">           /  d[x]</span><br><span class="hljs-comment">          x</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x]) &#123;<br>            <span class="hljs-keyword">int</span> u = find(p[x]); <span class="hljs-comment">// 寻找它当前根节点的父节点</span><br>            <span class="hljs-comment">// 它到新父节点的距离 = 它原来父节点的距离 + 它原来父节点到新父节点的距离</span><br>            d[x] = (d[x] + d[p[x]]) % M;    <br>            p[x] = u;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 与 b 是否同类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br><br>        <span class="hljs-comment">// 如果a和b已经同属于一个集合了，则判断到根节点的距离是否相等</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == d[b] % M;<br>        <br>        <span class="hljs-comment">// 否则，需要将两者放入同一个集合，并更新d[pa]到pb的距离</span><br>        <span class="hljs-comment">// 由于 a 和 b 同类， 所以 (d[a] + d[pa]) % M == d[b] % M</span><br>        <span class="hljs-comment">// 因此 d[pa] = (d[b] - d[a] + M) % M  --- 加M是以防d[a] - d[b] &lt; 0</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 是否能吃 b</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br>        <br>        <span class="hljs-comment">// 如果已经是同类，则a能吃b的前提是 a到根节点的距离 - 1 == b到根节点的距离</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == (d[b] + <span class="hljs-number">1</span>) % M;<br>        <br>        <span class="hljs-comment">// 否则加入同一集合，并维护a吃b的关系</span><br>        <span class="hljs-comment">// (d[a] + d[pa]) % M == (d[b] + 1) % M;</span><br>        <span class="hljs-comment">// d[pa] = (d[b] + 1 - d[a] + M) % M;</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] + <span class="hljs-number">1</span> - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-comment">// 维护并查集的个数</span><br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            p[i] = i;<br>        <br>        <span class="hljs-keyword">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            p[find(a)] = find(b);<br>            size--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            <span class="hljs-comment">// 必须数量相加再合并</span><br>            size[find(b)] += size[find(a)];<br>            p[find(a)] = find(b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护到祖宗节点的并查集"><a href="#维护到祖宗节点的并查集" class="headerlink" title="维护到祖宗节点的并查集"></a>维护到祖宗节点的并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩过程中维护到根节点的距离</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                root</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">              /   d[p[x]]</span><br><span class="hljs-comment">            p[x]</span><br><span class="hljs-comment">            /</span><br><span class="hljs-comment">           /  d[x]</span><br><span class="hljs-comment">          x</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x]) &#123;<br>            <span class="hljs-keyword">int</span> u = find(p[x]); <span class="hljs-comment">// 寻找它当前根节点的父节点</span><br>            <span class="hljs-comment">// 它到新父节点的距离 = 它原来父节点的距离 + 它原来父节点到新父节点的距离</span><br>            d[x] = (d[x] + d[p[x]]) % M;    <br>            p[x] = u;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 与 b 是否同类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br><br>        <span class="hljs-comment">// 如果a和b已经同属于一个集合了，则判断到根节点的距离是否相等</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == d[b] % M;<br>        <br>        <span class="hljs-comment">// 否则，需要将两者放入同一个集合，并更新d[pa]到pb的距离</span><br>        <span class="hljs-comment">// 由于 a 和 b 同类， 所以 (d[a] + d[pa]) % M == d[b] % M</span><br>        <span class="hljs-comment">// 因此 d[pa] = (d[b] - d[a] + M) % M  --- 加M是以防d[a] - d[b] &lt; 0</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 是否能吃 b</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br>        <br>        <span class="hljs-comment">// 如果已经是同类，则a能吃b的前提是 a到根节点的距离 - 1 == b到根节点的距离</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == (d[b] + <span class="hljs-number">1</span>) % M;<br>        <br>        <span class="hljs-comment">// 否则加入同一集合，并维护a吃b的关系</span><br>        <span class="hljs-comment">// (d[a] + d[pa]) % M == (d[b] + 1) % M;</span><br>        <span class="hljs-comment">// d[pa] = (d[b] + 1 - d[a] + M) % M;</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] + <span class="hljs-number">1</span> - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之操作系统</title>
    <link href="/2021/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span>、进程是资源分配的最小单位；线程是任务执行<span class="hljs-comment">(资源调度)</span>的最小单位。<br><br><span class="hljs-number">2</span>、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵；多个线程共享进程的地址空间和数据，因此线程的维护和切换代价比进程要低很多。<br><br><span class="hljs-number">3</span>、进程之间的需要以IPC的方式进行通信；线程由于共享进程的全局变量和静态变量，因此通信更为方便。<br></code></pre></td></tr></table></figure><h3 id="进程调度算法有哪些？"><a href="#进程调度算法有哪些？" class="headerlink" title="进程调度算法有哪些？"></a>进程调度算法有哪些？</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) 先来先服务<br>(<span class="hljs-number">2</span>) 时间片轮转<br>(<span class="hljs-number">3</span>) 短作业优先<br>(<span class="hljs-number">4</span>) 优先级调度<br>(<span class="hljs-number">5</span>) 多级反馈队列 <span class="hljs-selector-attr">[详细了解]</span><br></code></pre></td></tr></table></figure><h3 id="5种IO模型"><a href="#5种IO模型" class="headerlink" title="5种IO模型"></a>5种IO模型</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gcode">同步 <span class="hljs-attr">vs 异步</span><br><span class="hljs-attr">阻塞 vs 非阻塞</span><br><span class="hljs-attr"></span><br><span class="hljs-attr">(1</span>) 阻塞式IO<br>    <br><span class="hljs-comment">(2)</span> 非阻塞式IO<br>    <br><span class="hljs-comment">(3)</span> 多路复用IO<br><br><span class="hljs-comment">(4)</span> 信号驱动IO<br><br><span class="hljs-comment">(5)</span> 异步IO<br></code></pre></td></tr></table></figure><h3 id="进程的通信方式有哪些？线程呢？"><a href="#进程的通信方式有哪些？线程呢？" class="headerlink" title="进程的通信方式有哪些？线程呢？"></a>进程的通信方式有哪些？线程呢？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode">进程间的通信方式：<br>    <span class="hljs-comment">(1)</span> 匿名管道：<br>    <span class="hljs-comment">(2)</span> 管道<span class="hljs-comment">(有名管道)</span><br>    <span class="hljs-comment">(3)</span> 消息队列<br>    <span class="hljs-comment">(4)</span> 信号量<br>    <span class="hljs-comment">(5)</span> 共享内存<br>    <span class="hljs-comment">(6)</span> 套接字<br><br>线程间的通信方式：<br>    <span class="hljs-comment">(1)</span> 互斥量: 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。<br>    <span class="hljs-comment">(2)</span> 信号量<br></code></pre></td></tr></table></figure><h3 id="什么是僵尸进程-什么是孤儿进程-有什么危害"><a href="#什么是僵尸进程-什么是孤儿进程-有什么危害" class="headerlink" title="什么是僵尸进程? 什么是孤儿进程? 有什么危害?"></a>什么是僵尸进程? 什么是孤儿进程? 有什么危害?</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">僵尸进程：<br>    一个进程fork了子进程，如果子进程退出，但是它的父进程没有调用wait/waitpid获取子进程的状态信息，那么子进程的进程描述符等一系列信息还会保存在系统中。这样的进程我们称为僵尸进程。<br><br>    危害：僵尸进程是一个早已死亡的进程，但是在进程表中仍占用了一个位置，而进程表的容量是有限的，如果僵尸进程过多的话可能导致系统无法产生新的进程，导致系统瘫痪。<br><br>处理僵尸进程：<br>    (<span class="hljs-number">1</span>) 修改父进程。子进程死亡后会发送SIGCHLD信号给父进程，父进程收到此信号后调用wait/waitpid进行处理。<br>    (<span class="hljs-number">2</span>) 杀死父进程。杀死父进程后，僵尸进程会进化为孤儿进程，继而由<span class="hljs-number">1</span>号进程<span class="hljs-keyword">init</span>接管，<span class="hljs-keyword">init</span>进程会负责处理孤儿进程。<br><br>孤儿进程：<br>    父进程运行结束，但子进程还在运行 (未运行结束) 的子进程就称为孤儿进程。 <br>    <br>    孤儿进程最终会被 <span class="hljs-keyword">init</span> 进程 (进程号为 <span class="hljs-number">1</span>) 所收养，因此 <span class="hljs-keyword">init</span> 进程此时变成孤儿进程 的父进程，并由 <span class="hljs-keyword">init</span> 进程对它们完成状态收集工作。<br></code></pre></td></tr></table></figure><h3 id="CPU上下文切换有几种？系统中断进行了几次上下文切换？"><a href="#CPU上下文切换有几种？系统中断进行了几次上下文切换？" class="headerlink" title="CPU上下文切换有几种？系统中断进行了几次上下文切换？"></a>CPU上下文切换有几种？系统中断进行了几次上下文切换？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">上下文切换是一种将<span class="hljs-meta">CPU</span>资源从一个进程分配给另外一个进程的机制。操作系统需要先保存当前进程的状态(内存空间的指针，指令执行的位置等)，然后才能加载另外一个进程的状态并执行。<br><br><span class="hljs-meta">CPU</span>的上下文切换分为三种：进程上下文切换、线程上下文切换、中断上下文切换。<br><br>(<span class="hljs-number">1</span>) 系统调用过程中也会发生 <span class="hljs-meta">CPU</span> 上下文切换。<span class="hljs-meta">CPU</span> 寄存器会先保存用户态的状态，然后加载内核态相关内容。系统调用结束之后，<span class="hljs-meta">CPU</span> 寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次 <span class="hljs-meta">CPU</span> 上下文切换。<br><br>(<span class="hljs-number">2</span>) 进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调 用的上下文则不会，因为其未发生进程的变化。<br><br>(<span class="hljs-number">3</span>) 内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。 线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。而线程自己的 私有数据，如栈和寄存器等，上下文切换时需要保存。<br></code></pre></td></tr></table></figure><h3 id="虚拟内存的实现方式有哪些？分别有什么缺陷？"><a href="#虚拟内存的实现方式有哪些？分别有什么缺陷？" class="headerlink" title="虚拟内存的实现方式有哪些？分别有什么缺陷？"></a>虚拟内存的实现方式有哪些？分别有什么缺陷？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 请求分页存储管理。将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如 <span class="hljs-number">4</span>KB、<span class="hljs-number">8</span>KB 或 <span class="hljs-number">16</span>KB 等，并以页面作为内存空间的最小分配单位，一个程序的一个页面 可以存放在任意一个物理页面里。页是信息的物理单位。<br><br><span class="hljs-comment">(2)</span> 请求分段存储管理。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组 相对完整的逻辑信息。段是信息的逻辑单位。<br><br>分页存储的缺点：产生内部碎片 <br>分段存储的缺点：产生外部碎片 <br><br><span class="hljs-comment">(3)</span> 采用段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组 合起来使用。这样做的目的就是想同时获得分段和分页的好处，但又避免了单独分段或单独分页的缺陷<br></code></pre></td></tr></table></figure><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h3 id="什么是中断？产生中断的方式有哪些？"><a href="#什么是中断？产生中断的方式有哪些？" class="headerlink" title="什么是中断？产生中断的方式有哪些？"></a>什么是中断？产生中断的方式有哪些？</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对 程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。<br><br>(<span class="hljs-number">1</span>) 由计算机硬件异常或故障引起的中断，称为内部异常中断<span class="hljs-comment">;</span><br>(<span class="hljs-number">2</span>) 由程序中执行了引起中断的指令而造成的中断，称为软中断（系统调用相关的中断)<span class="hljs-comment">;</span><br>(<span class="hljs-number">3</span>) 由外部设备请求引起的中断，称为外部中断<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="什么会导致用户态陷入内核态？"><a href="#什么会导致用户态陷入内核态？" class="headerlink" title="什么会导致用户态陷入内核态？"></a>什么会导致用户态陷入内核态？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 系统调用：操作系统提供的函数就被称为系统调用（system <span class="hljs-keyword">call</span>）。程序的执行一般是在用户态下 执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、 读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是 系统调用。<br><br><span class="hljs-comment">(2)</span> 异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时 会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如 缺页异常。<br><br><span class="hljs-comment">(3)</span> 外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号， 这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程 序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序 中执行后续操作等。<br></code></pre></td></tr></table></figure><h3 id="陷阱与中断的区别？"><a href="#陷阱与中断的区别？" class="headerlink" title="陷阱与中断的区别？"></a>陷阱与中断的区别？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 陷阱指令可以使执行流程从用户态陷入内核并把控制权转移给操作系统，使得用户程序 可以调用内核函数和使用硬件从而获得操作系统所提供的服务，比如用视频软件放一个 电影，视频软件就发出陷阱使用显示器和声卡从而访问硬件。<br><br><span class="hljs-comment">(2)</span> 中断是由外部事件导致并且它发生的时间是不可预测的，这一点和陷阱不同。外部事件 主要是指时钟中断，硬件中断等。CPU 决定切换到另一个进程运行，就会产生一个时 钟中断，切换到下一个进程运行。<br></code></pre></td></tr></table></figure><h3 id="同步与互斥的关系？"><a href="#同步与互斥的关系？" class="headerlink" title="同步与互斥的关系？"></a>同步与互斥的关系？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法 限制访问者对资源的访问顺序，即访问是无序的。 <br><br><span class="hljs-comment">(2)</span> 同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。<br><br>实现同步和互斥的方式<br>    <span class="hljs-comment">(1)</span> 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>    <span class="hljs-comment">(2)</span> 互斥量：为协调共同对一个共享资源的单独访问而设计的。 <br>    <span class="hljs-comment">(3)</span> 信号量：为控制一个具有有限数量用户资源而设计。 <br>    <span class="hljs-comment">(4)</span> 事 件：用来通知线程有一些事件已发生，从而启动后继任务的开始。<br></code></pre></td></tr></table></figure><h3 id="死锁产生的条件？"><a href="#死锁产生的条件？" class="headerlink" title="死锁产生的条件？"></a>死锁产生的条件？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">互斥条件 <span class="hljs-comment">(Mutual exclusion)</span>：资源不能被共享，只能由一个进程使用。<br>请求与保持条件 <span class="hljs-comment">(Hold and wait)</span>：已经得到资源的进程可以再次申请新的资源。<br>非抢占条件 <span class="hljs-comment">(No pre-emption)</span>：已经分配的资源不能从相应的进程中被强制地剥夺。<br>循环等待条件 <span class="hljs-comment">(Circular wait)</span>：系统中若干进程组成环路，该环路中每个进程都在等待 相邻进程正占用的资源。<br></code></pre></td></tr></table></figure><h3 id="IO多路复用的select、poll和epoll的区别"><a href="#IO多路复用的select、poll和epoll的区别" class="headerlink" title="IO多路复用的select、poll和epoll的区别"></a>IO多路复用的select、poll和epoll的区别</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">(<span class="hljs-number">1</span>) <span class="hljs-keyword">select</span> 函数监视文件描述符，调用后 <span class="hljs-keyword">select</span> 函数会阻塞，直到有描述符就绪，或者超时，函数返回，当 <span class="hljs-keyword">select</span> 函数返回后，就可以遍历描述符，找到就绪的描述符。<span class="hljs-keyword">select</span> 的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制 <br><br>(<span class="hljs-number">2</span>) poll 没有最大限制（但是数量过大后性能也是会下降）。和 <span class="hljs-keyword">select</span> 函数一样，poll 返回后， 需要轮询来获取就绪的描述符。<br><br>(<span class="hljs-number">3</span>) epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下多路复用 IO 接口 <span class="hljs-keyword">select</span>/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的 情况下的系统 CPU 利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听 的描述符集，只要遍历那些被内核 IO 事件异步唤醒而加入 Ready 队列的描述符集合 就行了。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算器问题</title>
    <link href="/2021/03/11/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/11/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="利用双栈解决所有计算器问题"><a href="#利用双栈解决所有计算器问题" class="headerlink" title="利用双栈解决所有计算器问题"></a>利用双栈解决所有计算器问题</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">利用数字栈nums和字符栈ops解决计算器问题：<br><br>遍历字符串：<br>    若是空格，跳过。<br>    若是&#x27;(&#x27;，压入ops中，等待与之匹配的&#x27;)&#x27;。<br>    若是&#x27;)&#x27;, 取ops和nums进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums。<br>    若是操作符，若ops栈顶的操作符优先级大于该操作符，则先计算栈顶的操作。直到遇到左括号或者没有操作符。否则压入ops中。<br>    若是数字，则一直累计直到遇到非数字，将数字压入nums中。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 建立字符串优先级</span><br>        m.put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);<br>        m.put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);<br>        m.put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 去掉所有空格</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 将所有&quot;(-&quot; 改为 &quot;(0-&quot;</span><br>        s = s.replaceAll(<span class="hljs-string">&quot;\\(-&quot;</span>, <span class="hljs-string">&quot;(0-&quot;</span>);<br><br>        Stack&lt;Character&gt; ops = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        Stack&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.push(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                ops.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 一直计算直到遇到左括号为止</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-keyword">char</span> op = ops.peek();<br>                    <span class="hljs-keyword">if</span> (op != <span class="hljs-string">&#x27;(&#x27;</span>)<br>                        cal(ops, nums);<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        ops.pop();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">int</span> j = i;<br>                    <span class="hljs-keyword">while</span> (j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(j) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                        sum = sum * <span class="hljs-number">10</span> + (s.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                        j++;<br>                    &#125;<br>                    nums.push(sum);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 碰到新操作符</span><br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">char</span> prev = ops.peek();<br>                        <span class="hljs-comment">// 如果之前的运算优先级更大，则先计算</span><br>                        <span class="hljs-keyword">if</span> (m.get(prev) &gt;= m.get(c))<br>                            cal(ops, nums);<br>                        <span class="hljs-keyword">else</span> <br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    ops.push(c);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的计算完</span><br>        <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>)<br>            cal(ops, nums);<br><br>        <span class="hljs-keyword">return</span> nums.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(Stack&lt;Character&gt; ops, Stack&lt;Integer&gt; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> a = nums.pop();<br>        <span class="hljs-keyword">int</span> b = nums.pop();<br>        <span class="hljs-keyword">char</span> op = ops.pop();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) ans = b + a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) ans = b - a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) ans = b * a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>) ans = b / a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) ans = (<span class="hljs-keyword">int</span>)Math.pow(b, a);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;%&#x27;</span>) ans = b % a;<br>        nums.push(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>计算器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC300_最长上升子序列</title>
    <link href="/2021/03/06/%E7%AE%97%E6%B3%95/LC0300_%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/03/06/%E7%AE%97%E6%B3%95/LC0300_%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    算法思想：</span><br><span class="hljs-comment">        dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment">        从[0, i - 1]从查找，如果遇到 nums[j] &lt; nums[i], 则 dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N ^ 2)</span><br><span class="hljs-comment">    空间复杂度: O(N) </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 记录最长递增子序列</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 初始化为1</span><br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从[0, n - 1]寻找比 nums[i] 小的数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        xMax = Math.max(xMax, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于二分法的优化。</span><br><span class="hljs-comment">    g[i]: 最大长度为i的递增子序列中序列的最小值</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    那么在遍历nums[i]的过程中，只需要在g[]中寻找 &lt; nums[i] 的右边界r，那么 dp[i] = r + 1; g[r + 1] = nums[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    例如：g[3] = 4; // 1 2 4</span><br><span class="hljs-comment">          g[4] = 6; // 1 2 4 6</span><br><span class="hljs-comment">          nums[i] = 5, 则g[4] = 5; // 1 2 4 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    g[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g[mid] &lt; nums[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前最大长度</span><br>        len = Math.max(len, r + <span class="hljs-number">1</span>);<br>        g[r + <span class="hljs-number">1</span>] = nums[i];<br>        dp[i] = r + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何获取最小字典序"><a href="#如何获取最小字典序" class="headerlink" title="如何获取最小字典序"></a>如何获取最小字典序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    此时dp[i]记录了以i结尾的最长上升子序列的长度；</span><br><span class="hljs-comment">    如果整个序列递增，那么显然dp[i]中的值从小到大依次递增。</span><br><span class="hljs-comment">    如果dp[i]中出现了相等的值，比如：</span><br><span class="hljs-comment">    1 2 5 3;    dp[2] = 3, dp[3] = 3;   显然后者的字典序更小</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[xMax];<br><span class="hljs-keyword">int</span> k = xMax - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = xMax; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// dp[i] == j, 则添加进res中</span><br>    <span class="hljs-keyword">if</span> (dp[i] == j) &#123;<br>        res[k--] = nums[i];<br>        j--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表</title>
    <link href="/2021/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/"/>
    <url>/2021/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="跳表简介"><a href="#跳表简介" class="headerlink" title="跳表简介"></a>跳表简介</h2><blockquote><ul><li>在有序链表的基础上添加跳跃功能减少不必要的搜索。</li><li>搜索、删除、添加的时间复杂度为 O(N * logN)。</li><li>跳表按层构造，高层相当于底层的’快速通道’</li></ul></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 定义链表节点Node</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>        K key;<br>        V value;<br>        Node&lt;K, V&gt;[] nexts; <span class="hljs-comment">// 存放后继节点数组</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> Node&lt;K, V&gt; first;   <span class="hljs-comment">// 首部虚拟节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-comment">// 跳表元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEVEL = <span class="hljs-number">32</span>;    <span class="hljs-comment">// 跳表最大层数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> level = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 记录有效层数</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkipList</span><span class="hljs-params">()</span> </span>&#123;<br>        first = <span class="hljs-keyword">new</span> Node&lt;&gt;();<br>        first.nexts = <span class="hljs-keyword">new</span> Node[MAX_LEVEL];<br>    &#125;<br><br>    <span class="hljs-comment">// 生成随机层数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (Math.random() &lt; <span class="hljs-number">0.25</span> &amp;&amp; level &lt; MAX_LEVEL)<br>            level++;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索get-K-key-设计"><a href="#搜索get-K-key-设计" class="headerlink" title="搜索get(K key)设计"></a>搜索get(K key)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、从首节点开始，一直找到第一个 &gt;= key 的下一个节点</span><br><span class="hljs-comment">    2、如果相等，则直接返回；否则从下一层继续寻找</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;<br><br>    Node&lt;K, V&gt; node = first;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-comment">// 若当前节点的key == key, 则找到了直接返回</span><br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> node.nexts[i].value;<br>        <br>        <span class="hljs-comment">// 没找到则从node.nexts[i-1]开始搜索</span><br>    &#125; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加put-K-key-V-value-设计"><a href="#添加put-K-key-V-value-设计" class="headerlink" title="添加put(K key, V value)设计"></a>添加put(K key, V value)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>  <br>    Node&lt;K, V&gt; node = first;  <br>    Node&lt;K, V&gt;[] prevs = <span class="hljs-keyword">new</span> Node[level];         <span class="hljs-comment">// 存放每次发生跳层的节点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-comment">// 若node.nexts[i].key == key, 则覆盖value</span><br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>) &#123;<br>            node.nexts[i].value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 记录发生跳转的节点</span><br>        prevs[i] = node;    <br>    &#125; <br><br>    <span class="hljs-comment">// 不存在改key, 则此时node是前驱节点, i == -1</span><br>    Node&lt;K, V&gt; newNode = <span class="hljs-keyword">new</span> Node(key, value);<br>    <span class="hljs-keyword">int</span> rdLevel = randomLevel();<br>    newNode.nexts = <span class="hljs-keyword">new</span> Node&lt;&gt;[rdLevel];<br><br>    <span class="hljs-comment">// 调整层数为[0, level - 1]的后继指向</span><br>    <span class="hljs-comment">// 如果rdLevel &gt; level, 则调整头节点next</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rdLevel; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; level) &#123;<br>            newNode.nexts[i] = prevs[i].nexts[i];<br>            prevs[i].nexts[i] = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            first.nexts[i] = newNode;<br>        &#125;<br>    &#125;<br><br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除remove-K-key-设计"><a href="#删除remove-K-key-设计" class="headerlink" title="删除remove(K key)设计"></a>删除remove(K key)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;<br>    Node&lt;K, V&gt; node = first;  <br>    Node&lt;K, V&gt;[] prevs = <span class="hljs-keyword">new</span> Node[level];         <span class="hljs-comment">// 存放每次发生跳层的节点</span><br>    <span class="hljs-keyword">boolean</span> exist = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>)<br>            exist = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 找到key则进入下一层并记录所有发生跳转的节点</span><br>        prevs[i] = node;    <br>    &#125; <br><br>    <span class="hljs-comment">// 如果没找到则返回null</span><br>    <span class="hljs-keyword">if</span> (!exist) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 调整所有前驱的后继</span><br>    Node&lt;K, V&gt; removeNode = node.nexts[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; removeNode.nexts.length; i++) &#123;<br>        prevs[i].nexts[i] = removeNode.nexts[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 更新跳表的层数, 从头节点出发寻找next[i]不为空的层数</span><br>    <span class="hljs-keyword">int</span> newLevel = level;<br>    <span class="hljs-keyword">while</span> (newLevel &gt; <span class="hljs-number">0</span> &amp;&amp; first.nexts[newLevel] == <span class="hljs-keyword">null</span>)<br>        newLevel--;<br>    <br>    level = newLevel;<br><br>    size--;<br>    <span class="hljs-keyword">return</span> removeNode.value;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>跳表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2021/03/05/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2021/03/05/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>前缀和与差分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="Acwing791-高精度加法"><a href="#Acwing791-高精度加法" class="headerlink" title="Acwing791_高精度加法"></a>Acwing791_高精度加法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-comment">// 将两个大数字符串翻转</span><br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录进位情况</span><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length() || i &lt; b.length(); i++) &#123;<br>        <span class="hljs-comment">// 按位累加</span><br>        <span class="hljs-keyword">if</span> (i &lt; a.length()) t += a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; b.length()) t += b.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        sb.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-number">0</span>) sb.append(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing792-高精度减法"><a href="#Acwing792-高精度减法" class="headerlink" title="Acwing792_高精度减法"></a>Acwing792_高精度减法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sub</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-comment">// 默认 a &gt; b</span><br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录借位情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        t -= a[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; b.length()) <br>            t -= b[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <span class="hljs-comment">// 此时t若小于0则发生借位, t若大于0则没发生借位</span><br>        <span class="hljs-comment">// (t + 10) % 10, 可以保证无论是否发生借位都可以是正数</span><br>        sb.append((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);   <span class="hljs-comment">// 核心步骤</span><br>        t = t &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = sb.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index--;<br>    <br>    sb.delete(index + <span class="hljs-number">1</span>, sb.length());<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing793-高精度乘法"><a href="#Acwing793-高精度乘法" class="headerlink" title="Acwing793_高精度乘法"></a>Acwing793_高精度乘法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    情况1：大数 x 个位数</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    t += A[i] * b;  t /= 10;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br><br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        t += (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * b;<br><br>        res.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果此时 t == 87, 需要先添加7, 再添加8</span><br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-number">0</span>) &#123;<br>        sb.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 12345 x 0, 会存在前导0</span><br>    <span class="hljs-keyword">int</span> index = sb.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index--;<br>    <br>    sb = sb.delete(index + <span class="hljs-number">1</span>, sb.length());<br>    <br>    <span class="hljs-keyword">return</span> res.reverse().toString();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    情况2: 大数 x 大数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    c[i+j] += a[i] * b[j];</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul2</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length() + b.length()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.length(); j++) &#123;<br>            c[i][j] += (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (b.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理数组c的进位</span><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.length; i++) &#123;<br>        c[i] = (c[i] + t) % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = c.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; c[index] == <span class="hljs-number">0</span>)<br>        index--;<br>    <br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &gt;= <span class="hljs-number">0</span>; i--)<br>        sb.append(c[i]);<br><br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing794-高精度除法"><a href="#Acwing794-高精度除法" class="headerlink" title="Acwing794_高精度除法"></a>Acwing794_高精度除法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    高精度 / 低精度</span><br><span class="hljs-comment">    核心思想： r = r * 10 + A[i];  r / 10;  r %= b;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 保存余数</span><br><span class="hljs-keyword">int</span>[] res; <span class="hljs-comment">// 保存商</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">div</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        r = r * <span class="hljs-number">10</span> + (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        sb.append(r / b);<br>        r %= b;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除商的前导0</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; sb.length() - <span class="hljs-number">1</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index++;<br><br>    <span class="hljs-comment">// [index, sb.length() - 1]</span><br>    res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sb.length() - index];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; sb.length(); i++)<br>        res[k++] = sb.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    高精度 / 高精度</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>高精度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="二分法思想"><a href="#二分法思想" class="headerlink" title="二分法思想"></a>二分法思想</h2><blockquote><p>二分法常用于有序状态的数组中，通过中点值与条件的比较一下筛选掉一半的处理规模，从而使时间复杂度从O(N)降到O(logN)</p></blockquote><blockquote><ul><li>整数二分</li><li>小数二分</li></ul></blockquote><h3 id="Acwing789-数的范围"><a href="#Acwing789-数的范围" class="headerlink" title="Acwing789_数的范围"></a>Acwing789_数的范围</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    元素k的起始位置和终止位置，没找到则返回[-1, -1]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1、寻找 &gt;= k 的左边界l和 &lt;= k 的右边界r</span><br><span class="hljs-comment">    2、如果边界处的值不等于k, 则说明k不存在</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] num_score(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <br>    <span class="hljs-comment">// 寻找 &gt;= k 的左边界</span><br>    <span class="hljs-keyword">int</span> l1 = <span class="hljs-number">0</span>, r1 = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l1 &lt; r1) &#123;<br>        <span class="hljs-keyword">int</span> mid1 = (l1 + r1) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 如果中点处的值 &gt;= k, 则缩小右边界的范围，因为[mid1, r1]肯定都 &gt;= k</span><br>        <span class="hljs-keyword">if</span> (nums[mid1] &gt;= k)<br>            r1 = mid1;<br>        <span class="hljs-comment">// 否则说明[l1, mid1]都 &lt; k, 那么 &gt;= k的左边界只可能在[mid1 + 1, r1]之间</span><br>        <span class="hljs-keyword">else</span><br>            l1 = mid1 + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果边界处的值不等于k则说明元素不存在</span><br>    <span class="hljs-keyword">if</span> (nums[l1] != k)  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-comment">// 寻找 &lt;= k 的右边界</span><br>    <span class="hljs-keyword">int</span> l2 = <span class="hljs-number">0</span>, r2 = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l2 &lt; r2) &#123;<br>        <span class="hljs-comment">// 如果是使得l = mid, 则应该 + 1</span><br>        <span class="hljs-keyword">int</span> mid2 = (l2 + r2 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 如果中点处的值 &lt;= k, 则缩小右边界的范围，因为[l2, mid2]肯定都 &lt;= k</span><br>        <span class="hljs-keyword">if</span> (nums[mid2] &lt;= k)<br>            l2 = mid1;<br>        <span class="hljs-comment">// 否则说明[mid2, r2]都 &gt; k, 那么 &gt;= k的左边界只可能在[l2, mid2 - 1]之间</span><br>        <span class="hljs-keyword">else</span><br>            l2 = mid2 - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l1, l2&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing790-数的三次方根"><a href="#Acwing790-数的三次方根" class="headerlink" title="Acwing790_数的三次方根"></a>Acwing790_数的三次方根</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    计算数的三次方根</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">three_sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> l = -<span class="hljs-number">100</span>, r = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 通过精度来控制循环, 一半比要求的精度低两个数量级</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1e-8</span>) &#123;<br>        <span class="hljs-keyword">double</span> mid = (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">double</span> t = mid * mid * mid;<br>        <span class="hljs-keyword">if</span> (t &lt; target)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <br>    System.out.printf(<span class="hljs-string">&quot;%.6f&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>二分法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="归并排序的思想"><a href="#归并排序的思想" class="headerlink" title="归并排序的思想"></a>归并排序的思想</h2><blockquote><p>归并排序是基于 <strong>分治</strong> 和 <strong>递归</strong> 的思想。</p><ul><li>选取数组中间点为分割点</li><li>递归排序左子数组和右子数组</li><li>归并两个有序的子数组</li></ul></blockquote><h3 id="Acwing787-归并排序模板"><a href="#Acwing787-归并排序模板" class="headerlink" title="Acwing787_归并排序模板"></a>Acwing787_归并排序模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：子数组无元素或只剩一个元素</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 选取中间点作为分割点</span><br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 递归排序左右数组</span><br>    merge_sort(nums, l, mid);<br>    merge_sort(nums, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">// 归并两个有序数组</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j])<br>            temp[k++] = nums[i++];<br>        <span class="hljs-keyword">else</span><br>            temp[k++] = nums[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)    temp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)   temp[k++] = nums[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        nums[i] = temp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing788-逆序对的数量"><a href="#Acwing788-逆序对的数量" class="headerlink" title="Acwing788_逆序对的数量"></a>Acwing788_逆序对的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用归并排序的思想，在归并两个有序数组的时候对逆序对进行累加</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N * logN)</span><br><span class="hljs-comment">    空间复杂度：O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 返回数组区间[l, r]的逆序对数量</span><br><span class="hljs-comment">// 那么总的逆序对为 左边的逆序对 + 右边的逆序对 + 左右数组形成的逆序对</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">mergeSort_findReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：数组无元素或只有一个元素无法形成逆序对，返回0</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 累加左数组的逆序对和右数组的逆序对</span><br>    <span class="hljs-keyword">long</span> res = mergeSort_findReverse(nums, l, mid) + mergeSort_findReverse(nums, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">// 两个有序数组归并的过程中继续累加逆序对</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>            temp[k++] = nums[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// i &lt; j 但是 nums[i] &gt; nums[j], 则[i, mid]均大于nums[j]</span><br>            temp[k++] = nums[j++];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)    temp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)   temp[k++] = nums[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        nums[i] = temp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="快排的思想"><a href="#快排的思想" class="headerlink" title="快排的思想"></a>快排的思想</h2><blockquote><p>快速排序是基于 <strong>分治</strong> 和 <strong>递归</strong> 的思想。</p><ul><li>选取分界点x。</li><li>双指针处理，使得 &lt;= x 的都在左边， &gt;= x 的都在右边。</li><li>递归排序左右子数组, 递归出口为子数组无元素或只有一个元素。</li></ul></blockquote><h3 id="Acwing785-快排模板"><a href="#Acwing785-快排模板" class="headerlink" title="Acwing785_快排模板"></a>Acwing785_快排模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    时间复杂度: O(N ^ logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：子数组无元素或只剩一个元素</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 1、选取数组中存在的值作为分界值</span><br>    <span class="hljs-keyword">int</span> x = nums[l + (r - l) / <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 2、保证 &lt;= x 的都在左边， &gt;= x 的都在右边</span><br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br><br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> t = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3、递归处理左右子数组</span><br>    quick_sort(nums, l, j);<br>    quick_sort(nums, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing786-寻找第k小的数"><a href="#Acwing786-寻找第k小的数" class="headerlink" title="Acwing786_寻找第k小的数"></a>Acwing786_寻找第k小的数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于快排的思想将小的数放在数组右边，大的数放在数组左边</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    当右子数组长度 len &gt;= k时，说明第k大的数是右数组的第k大的数</span><br><span class="hljs-comment">    当右子数组长度 len &lt; k时, 说明第k大的数是左数组的第(k - len)大的数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    递归的向相应的子数组中寻找，直到数组中只剩下一个元素则为目标值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 当只剩下一个数的时候，说明找到了第K小的数</span><br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> arr[l];<br>    <br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> target = arr[(l + r) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (arr[i] &lt; target);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (arr[j] &gt; target);<br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> len = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (len &gt;= k)<br>        <span class="hljs-keyword">return</span> findKth(arr, l, j, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findKth(arr, j + <span class="hljs-number">1</span>, r, k - len);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
