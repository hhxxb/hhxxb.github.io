<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC0044_通配符匹配</title>
    <link href="/2021/03/23/%E7%AE%97%E6%B3%95/LC0044_%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
    <url>/2021/03/23/%E7%AE%97%E6%B3%95/LC0044_%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">给定一个字符串 <span class="hljs-comment">(s)</span> 和一个字符模式 <span class="hljs-comment">(p)</span> ，实现一个支持 <span class="hljs-string">&#x27;?&#x27;</span> 和 <span class="hljs-string">&#x27;*&#x27;</span> 的通配符匹配。<br><br><span class="hljs-string">&#x27;?&#x27;</span> 可以匹配任何单个字符。<br><span class="hljs-string">&#x27;*&#x27;</span> 可以匹配任意字符串（包括空字符串）。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">与<span class="hljs-symbol">LC0010_</span>正则表达式类似。<br>不同的是：<br>    (<span class="hljs-number">1</span>) <span class="hljs-string">&#x27;.&#x27;</span> 相当于 <span class="hljs-string">&#x27;?&#x27;</span><br>    (<span class="hljs-number">2</span>) 由于<span class="hljs-string">&#x27;*&#x27;</span>可以相当于任意字符，因此匹配<span class="hljs-number">0</span>次时不需要 j &gt;= <span class="hljs-number">2</span>; 匹配多次时不需要 s[i] == p[j<span class="hljs-number">-1</span>]<br><br>    匹配<span class="hljs-number">0</span>次：dp[i][j<span class="hljs-number">-1</span>]<br>    匹配<span class="hljs-number">1</span>次：dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>    匹配<span class="hljs-number">2</span>次：dp[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-2</span>]<br><br>    dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] || ... || <br>    dp[i<span class="hljs-number">-1</span>][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-1</span>] || ... ||<br><br>    因此 dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-1</span>][j]<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br><br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    p = <span class="hljs-string">&quot; &quot;</span> + p;<br><br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-comment">// 不为&#x27;*&#x27;</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="hljs-string">&#x27;?&#x27;</span>))<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] || dp[i][j];<br>            <br>            <span class="hljs-comment">// 为&#x27;*&#x27;</span><br>            <span class="hljs-keyword">if</span> (p.charAt(j) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 匹配0次</span><br>                dp[i][j] = dp[i][j-<span class="hljs-number">1</span>] || dp[i][j];<br><br>                <span class="hljs-comment">// 匹配多次</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] || dp[i][j];<br>            &#125;<br>        &#125;    <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>线性DP</tag>
      
      <tag>通配符匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0010_正则表达式</title>
    <link href="/2021/03/23/%E7%AE%97%E6%B3%95/LC0010_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/03/23/%E7%AE%97%E6%B3%95/LC0010_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <span class="hljs-string">&#x27;.&#x27;</span> 和 <span class="hljs-string">&#x27;*&#x27;</span> 的正则表达式匹配。<br><br><span class="hljs-string">&#x27;.&#x27;</span> 匹配任意单个字符<br><span class="hljs-string">&#x27;*&#x27;</span> 匹配零个或多个前面的那一个元素<br><br>示例 <span class="hljs-number">1</span>：<br>输入：s = <span class="hljs-comment">&quot;aa&quot;</span> p = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-keyword">false</span><br>解释：<span class="hljs-comment">&quot;a&quot;</span> 无法匹配 <span class="hljs-comment">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">dp[i][j] : s串前i个字符是否能够和p串前j个字符匹配<br><br>集合划分：以p[j]是否为<span class="hljs-string">&#x27;*&#x27;</span>进行划分<br>         如果不是<span class="hljs-string">&#x27;*&#x27;</span>, 则只有当s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &amp;&amp; dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] == true. 才能够匹配。<br>         <br>         如果是<span class="hljs-string">&#x27;*&#x27;</span>, 则可能匹配<span class="hljs-number">0</span>次, <span class="hljs-number">1</span>次.... n次。<br>         dp[i][j] = dp[i][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>] &amp;&amp; s[i] || dp[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-2</span>] &amp;&amp; s[i] &amp;&amp; s[i<span class="hljs-number">-1</span>] || ...<br>         <br>        于此同时我们可以发现 dp[i<span class="hljs-number">-1</span>][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-2</span>] &amp; s[i<span class="hljs-number">-1</span>] || ...<br><br>        因此 dp[i][j] = dp[i][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-1</span>][j] &amp; s[i]<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br><br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    p = <span class="hljs-string">&quot; &quot;</span> + p;<br><br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] || dp[i][j];<br>            <br>            <span class="hljs-keyword">if</span> (p.charAt(j) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 匹配0次: j &gt;= 2</span><br>                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span>) <br>                    dp[i][j] = dp[i][j-<span class="hljs-number">2</span>] || dp[i][j];<br><br>                <span class="hljs-comment">// 匹配多次: s[i] == p[j - 1]</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j - <span class="hljs-number">1</span>) || p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] || dp[i][j];<br>            &#125;<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>正则表达式</tag>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之操作系统</title>
    <link href="/2021/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="OSI七层模型？"><a href="#OSI七层模型？" class="headerlink" title="OSI七层模型？"></a>OSI七层模型？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">物理层：通过媒介传输比特,确定机械及电气范围。<span class="hljs-comment">(比特)</span><br>数据链路层：将比特组装成帧和点到点的传递。<span class="hljs-comment">(帧)</span><br>网络层：负责数据包从源到宿的传递和网际互连。<span class="hljs-comment">(包)</span><br>传输层: 提供端到端的可靠报文传递和错误恢复。<span class="hljs-comment">(段)</span><br>会话层：建立、管理和终止会话。<span class="hljs-comment">(会话协议数据单元)</span><br>表示层：对数据进行翻译、加密和压缩。<span class="hljs-comment">(表示协议数据单元)</span><br>应用层: 允许方法OSI环境的手段。<span class="hljs-comment">(应用协议数据单元)</span><br></code></pre></td></tr></table></figure><h2 id="从一个URL到获取页面的过程？"><a href="#从一个URL到获取页面的过程？" class="headerlink" title="从一个URL到获取页面的过程？"></a>从一个URL到获取页面的过程？</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(<span class="hljs-number">1</span>) 浏览器查询DNS，获取域名对应的<span class="hljs-built_in">IP</span>地址。具体过程包括: 浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的host文件、像本地DNS服务器进行查询。<br><br>(<span class="hljs-number">2</span>) 获取对应的<span class="hljs-built_in">IP</span>地址以后，向服务器请求建立连接，发起TCP三次握手。<br><br>(<span class="hljs-number">3</span>) 连接建立以后，浏览器发起HTTP请求<br><br>(<span class="hljs-number">4</span>) 浏览器收到请求以后，处理请求并返回相应的视图。<br><br>(<span class="hljs-number">5</span>) 浏览器解析并渲染视图。如果有对<span class="hljs-keyword">js</span>、css及图片等静态资源的引用，则重复HTTP请求获取相应的资源。<br><br>(<span class="hljs-number">6</span>) 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。<br></code></pre></td></tr></table></figure><h3 id="Session的实现原理-和-Cookie的实现原理？"><a href="#Session的实现原理-和-Cookie的实现原理？" class="headerlink" title="Session的实现原理 和 Cookie的实现原理？"></a>Session的实现原理 和 Cookie的实现原理？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。<br><br><span class="hljs-keyword">Session</span> 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。使用上比 Cookie 简单一些，相应的也增加了服务器的存储压力。<br><br>总体来说：Cookie 通过在客户端记录信息确定用户身份，<span class="hljs-keyword">Session</span> 通过在服务器端记录信息确定用户身份。<br></code></pre></td></tr></table></figure><h3 id="Session和Cooike的关系？禁用Cookie对Session的影响？"><a href="#Session和Cooike的关系？禁用Cookie对Session的影响？" class="headerlink" title="Session和Cooike的关系？禁用Cookie对Session的影响？"></a>Session和Cooike的关系？禁用Cookie对Session的影响？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Session</span> 的实现常常依赖于 Cookie 机制。一般默认情况下，服务器存储 <span class="hljs-keyword">session</span> 的 sessionid 是通过 cookie 存到浏览器里。如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，<span class="hljs-keyword">session</span> 失效。但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用 <span class="hljs-keyword">session</span>。<br><br><span class="hljs-number">1</span>、通过 url 重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中 携带 sessionid 参数。<br><span class="hljs-number">2</span>、服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。<br><span class="hljs-number">3</span>、通过 Http 协议其他 <span class="hljs-keyword">header</span> 字段，服务器每次返回时设置该 <span class="hljs-keyword">header</span> 字段信息，浏览器中 js 读取该 <span class="hljs-keyword">header</span> 字段，请求服务器时，js 设置携带该 <span class="hljs-keyword">header</span> 字段。<br></code></pre></td></tr></table></figure><h3 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">forward 是服务器请求资源，服务器直接访问目标地址的 <span class="hljs-built_in">URL</span>, 把那个 <span class="hljs-built_in">URL</span> 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址.<br><br>redirect 是服务端根据逻辑，发送一个状态码 , 告诉浏览器重新去请求那个地址。所以地址栏显示的是新的<span class="hljs-built_in">URL</span>.<br></code></pre></td></tr></table></figure><h3 id="内网和外网的区别？ABC三类地址的划分？"><a href="#内网和外网的区别？ABC三类地址的划分？" class="headerlink" title="内网和外网的区别？ABC三类地址的划分？"></a>内网和外网的区别？ABC三类地址的划分？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">外网 <span class="hljs-built_in">IP</span> 是全世界唯一的 <span class="hljs-built_in">IP</span> 地址，仅分配给一个网络设备。公网 <span class="hljs-built_in">IP</span> 地址全世界仅分配给一个网络设备。<br><br>内网 <span class="hljs-built_in">IP</span> 局域网，网线都是连接在同一个 交换机上面的，也就是说它们的 <span class="hljs-built_in">IP</span> 地址是由交换机或者路由器进行分配的。内网用户的电脑都是经过交换机和路由器之后才能连到 外网。Internet 上的用户也无法直接访问到内网用户。不同内网的内网地址可以相同。<br><br><span class="hljs-built_in">IP</span>地址 = 网络地址 + 主机地址。<br>A类网络：以<span class="hljs-number">0</span>开头前<span class="hljs-number">8</span>位。<span class="hljs-number">0</span> ~ <span class="hljs-number">127</span><br>B类地址：以<span class="hljs-number">10</span>开头前<span class="hljs-number">16</span>位。<span class="hljs-number">128</span> ~ <span class="hljs-number">191</span><br>C类地址：以<span class="hljs-number">110</span>开头前<span class="hljs-number">24</span>位。<span class="hljs-number">192</span> ~ <span class="hljs-number">223</span><br></code></pre></td></tr></table></figure><h3 id="网关和子网掩码的关系？"><a href="#网关和子网掩码的关系？" class="headerlink" title="网关和子网掩码的关系？"></a>网关和子网掩码的关系？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">子网掩码：用来判断任意两台计算机的 <span class="hljs-built_in">ip</span> 地址是否属于同一子网络的根据。<br><br>网关实质上是一个在不同子段网路中传输数据的设备。<br><br>子网掩码相同，不需要网关即可通讯，子网掩码不同，需要网关才能通讯。<br></code></pre></td></tr></table></figure><h3 id="MAC地址和IP地址的关系？"><a href="#MAC地址和IP地址的关系？" class="headerlink" title="MAC地址和IP地址的关系？"></a>MAC地址和IP地址的关系？</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">MAC</span> 地址是硬件地址，定位全球唯一主机机器，在网络底层的物理传输过程中，是通 过物理地址来识别主机的，它一定是全球唯一的，对应数据链路层。<br><br>IP 地址是网络拓扑地址，定位全球唯一网络结构中的主机。对应网路层。<br></code></pre></td></tr></table></figure><h3 id="什么是DNS服务器？"><a href="#什么是DNS服务器？" class="headerlink" title="什么是DNS服务器？"></a>什么是DNS服务器？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DNS</span> 是指：域名服务器 (Domain Name Server)。在 Internet 上域名与 <span class="hljs-built_in">IP</span> 地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识 <span class="hljs-built_in">IP</span> 地址，它们之间的转 换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 就是进行域名解析的服务器 。一个<span class="hljs-built_in">ip</span>是可以供多个域名解析的,但是域名解析到的一个地址是一对一的。底层使用UDP协议。<br></code></pre></td></tr></table></figure><h3 id="IP如何映射到MAC地址？"><a href="#IP如何映射到MAC地址？" class="headerlink" title="IP如何映射到MAC地址？"></a>IP如何映射到MAC地址？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用ARP协议, 位于网络层。<br><br>工作原理:<br>    (<span class="hljs-number">1</span>) 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 <span class="hljs-built_in">IP</span> 地址和 MAC 地址之间的对应关系。当源主机要发送数据时，首先检查 ARP 列表中是否有对应 <span class="hljs-built_in">IP</span> 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 ARP 数据包。<br><br>    (<span class="hljs-number">2</span>) 当本网络的所有主机收到该 ARP 数据包时，首先检查数据包中的 <span class="hljs-built_in">IP</span> 地址是否是自己 的 <span class="hljs-built_in">IP</span> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <span class="hljs-built_in">IP</span> 和 MAC 地址写入到 ARP 列表中, 然后将自己的MAC地址回复给源主机。<br><br>    (<span class="hljs-number">3</span>) 如果目标 <span class="hljs-built_in">IP</span> 与自己不在同一个网段，这种情况需要将包发给默认网关，所以主要获取网关的 MAC 地址。<br></code></pre></td></tr></table></figure><h3 id="TCP是如何保证可靠传输的？"><a href="#TCP是如何保证可靠传输的？" class="headerlink" title="TCP是如何保证可靠传输的？"></a>TCP是如何保证可靠传输的？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">保证可靠传输最主要的是：<br>    <span class="hljs-comment">(1)</span> 拥塞控制<br>    <span class="hljs-comment">(2)</span> 流量控制<br>    <span class="hljs-comment">(3)</span> ARQ协议<br>    <br>    除此之外还有：超时传送、丢弃重复、校验和、分割合适数据包。<br></code></pre></td></tr></table></figure><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h3 id="TCP-和-UDP-的区别？"><a href="#TCP-和-UDP-的区别？" class="headerlink" title="TCP 和 UDP 的区别？"></a>TCP 和 UDP 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">TCP：面向连接、面向字节流、一对一； UDP：无连接、面向报文、一对一、一对多、 多对多。 <br><br>TCP 的优点：可靠，稳定. 缺点：慢，效率低，占用系统资源高，易被攻击 <br><br>UDP 的优点：快，UDP 是一个无状态的传输协议 缺点： 不可靠，不稳定<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数DP</title>
    <link href="/2021/03/22/Acwing/%E8%AE%A1%E6%95%B0DP/"/>
    <url>/2021/03/22/Acwing/%E8%AE%A1%E6%95%B0DP/</url>
    
    <content type="html"><![CDATA[<h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">一个正整数 <span class="hljs-built_in">n</span> 可以表示成若干个正整数之和，形如：<span class="hljs-built_in">n</span>=<span class="hljs-symbol">n1</span>+<span class="hljs-symbol">n2</span>+…+nk，其中 <span class="hljs-symbol">n1</span>≥<span class="hljs-symbol">n2</span>≥…≥nk,k≥<span class="hljs-number">1</span>。<br><br>我们将这样的一种表示称为正整数 <span class="hljs-built_in">n</span> 的一种划分。<br><br>现在给定一个正整数 <span class="hljs-built_in">n</span>，请你求出 <span class="hljs-built_in">n</span> 共有多少种不同的划分方法。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC312_戳气球</title>
    <link href="/2021/03/22/%E7%AE%97%E6%B3%95/LC0312_%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <url>/2021/03/22/%E7%AE%97%E6%B3%95/LC0312_%E6%88%B3%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs inform7">有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。<br><br>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums<span class="hljs-comment">[i - 1]</span> * nums<span class="hljs-comment">[i]</span> * nums<span class="hljs-comment">[i + 1]</span> 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。<br><br>求所能获得硬币的最大数量。<br><br> <br>示例 1：<br>输入：nums = <span class="hljs-comment">[3,1,5,8]</span><br>输出：167<br>解释：<br>    nums = <span class="hljs-comment">[3,1,5,8]</span> --&gt; <span class="hljs-comment">[3,5,8]</span> --&gt; <span class="hljs-comment">[3,8]</span> --&gt; <span class="hljs-comment">[8]</span> --&gt; <span class="hljs-comment">[]</span><br>    coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167<br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[1,5]</span><br>输出：10<br></code></pre></td></tr></table></figure><h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 打完所有[i+1, j-1]的气球所能获得的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以最后一个气球作为分界点</span><br><span class="hljs-comment">             (第i+1个 | 第i+2个 | 第k个 | ... | 第j-1个)</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    则dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 辅助数组。首尾添加1</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];<br>    temp[<span class="hljs-number">0</span>] = temp[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        temp[i+<span class="hljs-number">1</span>] = nums[i];<br>    <br>    <span class="hljs-comment">// 枚举长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">3</span>; len &lt;= n + <span class="hljs-number">2</span>; len++) &#123;<br>        <span class="hljs-comment">// 枚举左边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;= n + <span class="hljs-number">2</span> - len; l++) &#123;<br>            <span class="hljs-comment">// 确定右边界</span><br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 枚举切割点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l + <span class="hljs-number">1</span>; k &lt; r; k++)<br>                dp[l][r] = Math.max(dp[l][r], dp[l][k] + dp[k][r] + temp[l] * temp[k] * temp[r]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>戳气球</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/2021/03/22/Acwing/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2021/03/22/Acwing/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">设有 <span class="hljs-built_in">N</span> 堆石子排成一排，现在要将这 <span class="hljs-built_in">N</span> 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和,找出一种合理的方法，使总的代价最小，输出最小代价。<br></code></pre></td></tr></table></figure><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 所有将第i堆到第j堆合并为一个的方案中的代价的最小值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以最后一次的分界线来分类。</span><br><span class="hljs-comment">             (第i堆和[i+1, j]合并 | [i, i + 1]与[i + 2, j]合并 | ... | [i, j - 1] 和第j堆合并)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j] = dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1];</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] pre;<br><span class="hljs-keyword">int</span>[][] dp;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 处理前缀和</span><br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] + nums[i];<br>    <br>    dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br><br>    helper(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 合并区间[l, r]的最小代价</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (dp[l][r] != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> dp[l][r];<br>    <br>    <span class="hljs-comment">// 枚举每个分界线</span><br>    <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt; r; k++) &#123;<br>        res = Math.min(res, helper(nums, l, k) + helper(nums, k + <span class="hljs-number">1</span>, r) + pre[r] - pre[l - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[l][r] = res;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性DP</title>
    <link href="/2021/03/22/Acwing/%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2021/03/22/Acwing/%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。<br><br>        7<br>     <span class="hljs-number"> 3 </span>  8<br>   <span class="hljs-number"> 8 </span> <span class="hljs-number"> 1 </span>  0<br> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 7 </span> <span class="hljs-number"> 4 </span>  4<br>4  <span class="hljs-number"> 5 </span> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 6 </span>  5<br></code></pre></td></tr></table></figure><h4 id="方法1：自顶向下"><a href="#方法1：自顶向下" class="headerlink" title="方法1：自顶向下"></a>方法1：自顶向下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    7</span><br><span class="hljs-comment">    3 8</span><br><span class="hljs-comment">    8 1 0</span><br><span class="hljs-comment">    2 7 4 4</span><br><span class="hljs-comment">    4 5 2 6 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 所有从(0, 0)走到(i, j)的路径的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从上面来 | 从左上方来)</span><br><span class="hljs-comment">             max(dp[i-1][j] | dp[i-1][j-1]) + matrix[i][j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++) <br>            dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= col; k++)<br>        xMax = Math.max(dp[row][k], xMax);<br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br><span class="hljs-comment">// 优化：跟01背包相似，都与第i-1层的第j个和第j-1个有关</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[col + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j-<span class="hljs-number">1</span>]) + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= col; k++)<br>        xMax = Math.max(dp[k], xMax);<br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2：自底向上"><a href="#方法2：自底向上" class="headerlink" title="方法2：自底向上"></a>方法2：自底向上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    7</span><br><span class="hljs-comment">    3 8</span><br><span class="hljs-comment">    8 1 0</span><br><span class="hljs-comment">    2 7 4 4</span><br><span class="hljs-comment">    4 5 2 6 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 所有从最底部走到(i, j)的路径的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从下面来 | 从右下方来)</span><br><span class="hljs-comment">             max(dp[i+1][j] | dp[i+1][j+1]) + matrix[i][j]</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个长度为 <span class="hljs-built_in">N</span> 的数列，求数值严格单调递增的子序列的长度最长是多少。<br><br>子序列：不要求连续<br></code></pre></td></tr></table></figure><h4 id="方法1：朴素版"><a href="#方法1：朴素版" class="headerlink" title="方法1：朴素版"></a>方法1：朴素版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i]：以下标i结尾的最长上升子序列的长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(比nums[0]大 | 比nums[1]大 | ... | 比nums[i-1]大)</span><br><span class="hljs-comment">            max(dp[0] | dp[1] | ... | dp[n - 1]) + 1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        xMax = Math.max(dp[i], xMax);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="方法2：二分法优化"><a href="#方法2：二分法优化" class="headerlink" title="方法2：二分法优化"></a>方法2：二分法优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于二分法的优化。</span><br><span class="hljs-comment">    g[i]: 最大长度为i的递增子序列中序列的最小值</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    那么在遍历nums[i]的过程中，只需要在g[]中寻找 &lt; nums[i] 的右边界r，那么 dp[i] = r + 1; g[r + 1] = nums[i]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    g[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <br>        <span class="hljs-comment">// 在g[]中寻找 &lt; nums[i] 的右边界</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g[mid] &lt; nums[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前最大长度</span><br>        len = Math.max(len, r + <span class="hljs-number">1</span>);<br>        g[r + <span class="hljs-number">1</span>] = nums[i];<br>        dp[i] = r + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="延申：打印字典序最小的最长上升子序列"><a href="#延申：打印字典序最小的最长上升子序列" class="headerlink" title="延申：打印字典序最小的最长上升子序列"></a>延申：打印字典序最小的最长上升子序列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 假如说我们已经拿到了dp[] 和 xMax</span><br><br>    <span class="hljs-comment">// 如果出现dp[i] = 3, dp[i + 1] = 3, 那么显然nums[i+1] &lt; nums[i]。因此后者才是字典序最小的。</span><br><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[xMax];<br>    <span class="hljs-keyword">int</span> k = xMax - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = xMax; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// dp[i] == j, 则添加进res中</span><br>        <span class="hljs-keyword">if</span> (dp[i] == j) &#123;<br>            res[k--] = nums[i];<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个长度分别为 N 和 M 的字符串 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，求既是 <span class="hljs-selector-tag">A</span> 的子序列又是 <span class="hljs-selector-tag">B</span> 的子序列的字符串长度最长是多少。<br></code></pre></td></tr></table></figure><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 所有 即出现在第一个序列的前i个字符中，且出现在第二个序列的前j个字符中 的子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以 a[i] 和 b[j] 是否包含在子序列中为划分依据</span><br><span class="hljs-comment">         max (包含a[i] | 包含b[j] | 都包含 | 都不包含)</span><br><span class="hljs-comment">         max (dp[i][j-1] | dp[i-1][j] | dp[i-1][j-1] + 1 | dp[i-1][j-1])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>    <span class="hljs-comment">// 子序列没有连续的要求</span><br>    <span class="hljs-comment">// dp[i][j]: 字符串1的前i个字符和字符串2前j个字符的最长公共子序列的长度</span><br><br>    <span class="hljs-keyword">int</span> n = text1.length();<br>    <span class="hljs-keyword">int</span> m = text2.length();<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 包含s1[i]或者s2[j]</span><br>            dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>]);<br><br>            <span class="hljs-comment">// 如果s1[i] == s2[j], 则包含s1[i]和s2[j]</span><br>            <span class="hljs-keyword">if</span> (text1.charAt(i) == text2.charAt(j))<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>], dp[i][j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个字符串 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，现在要将 <span class="hljs-selector-tag">A</span> 经过若干操作变为 <span class="hljs-selector-tag">B</span>，可进行的操作有：<br>    删除–将字符串 <span class="hljs-selector-tag">A</span> 中的某个字符删除。<br>    插入–在字符串 <span class="hljs-selector-tag">A</span> 的某个位置插入某个字符。<br>    替换–将字符串 <span class="hljs-selector-tag">A</span> 中的某个字符替换为另一个字符。<br>现在请你求出，将 <span class="hljs-selector-tag">A</span> 变为 <span class="hljs-selector-tag">B</span> 至少需要进行多少次操作。<br></code></pre></td></tr></table></figure><h4 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = word1.length();<br>    <span class="hljs-keyword">int</span> n = word2.length();<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 需要增dp[i][j+1]、删dp[i+1][j]、改dp[i][j]的情况</span><br>            dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(dp[i][j+<span class="hljs-number">1</span>], Math.min(dp[i][j], dp[i+<span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">// 相等则啥也不用改</span><br>            <span class="hljs-keyword">if</span> (word1.charAt(i) == word2.charAt(j))<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>], dp[i][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2021/03/20/Acwing/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/20/Acwing/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    01背包模型：</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品只能选择一次。</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">        (选第i物品[前提是能装得下] | 不选第i个物品)</span><br><span class="hljs-comment">        (dp[i - 1][j - v[i]] + w[i] | dp[i - 1][j])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版本</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag01</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-comment">// 不选择第i个物品</span><br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br><br>            <span class="hljs-comment">// 选取第i个物品</span><br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) <br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    优化版</span><br><span class="hljs-comment">    dp[i]这一层仅使用到了dp[i-1]这一层，因此可以优化为一维。</span><br><span class="hljs-comment">    由于第i层的是通过第i-1层的第j位和第j-v[i]位来更新，因此优化成1维的时候，必须保证j-v[i]还没有被覆盖。因此需要从大到小进行更新。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag01</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;= v[i]; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    完全背包模型:</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品可以选取无数次。</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">            (不选第i个物品 | 选1个 | 选2个 | ... | 选k个)</span><br><span class="hljs-comment">            (dp[i-1][j] | dp[i-1][j - v[i]] + w[i] | dp[i-1][j - 2 * v[i]] + 2 * w[i] | ... | dp[i-1][j - k * v[i]] + k * w[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k++)<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化1：</span><br><span class="hljs-comment">    dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2v] + 2w + .... + dp[i-1][j-kv] + kw)</span><br><span class="hljs-comment">    dp[i][j-v] = max(          dp[i-1][j-v], dp[i-1][j-2v] + w, ... + dp[i-1][j-kv] + (k-1)w)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    因此dp[i][j] = max(dp[i-1][j], dp[i][j-v] + w) </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i+<span class="hljs-number">1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化2：</span><br><span class="hljs-comment">        dp[i][j]需要第i-1层的第j个和第i层的第j-v[i]个有关。因此可以优化成一维。</span><br><span class="hljs-comment">        需要保证j从小到大更新。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag03</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v[i]; j &lt;= V; j++) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    多重背包模型：</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品最多包含s个。</span><br><span class="hljs-comment">        s[i]: 第i个物品的个数</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">            (不选第i个物品 | 选1个 | 选2个 | ... | 选s个)</span><br><span class="hljs-comment">            (dp[i-1][j] | dp[i-1][j - v[i]] + w[i] | dp[i-1][j - 2 * v[i]] + 2 * w[i] | ... | dp[i-1][j - s * v[i]] + s * w[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] s, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">// 优化版：二进制优化, 将s[i]分解成1、2、4、8..., 然后转换成01背包问题</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (k &lt;= s) &#123;<br>    v[cnt] = a * k;<br>    w[cnt] = b * k;<br>    s -= k;<br>    k *= <span class="hljs-number">2</span>;<br>    cnt++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>    v[cnt] = a * s;<br>    w[cnt] = b * s;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合背包"><a href="#组合背包" class="headerlink" title="组合背包"></a>组合背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    组合背包模型：</span><br><span class="hljs-comment">        有N组物品和一个容量为V的背包，每个组只能选择一个。</span><br><span class="hljs-comment">        v[i][k]: 第i组的第k个物品的体积</span><br><span class="hljs-comment">        w[i][k]: 第i组的第k个物品的价值</span><br><span class="hljs-comment">        s[i]: 第i组一共有多少个物品</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(不从第i组选择 | 从第i组选第1个物品 | ... | 从第i组选第k个物品)</span><br><span class="hljs-comment">             (dp[i-1][j] | dp[i-1][j - v[i-1][1]] + w[i-1][1] | ... | dp[i-1][j - v[i-1][k]] + w[i-1][k])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag04</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] v, <span class="hljs-keyword">int</span>[][] w, <span class="hljs-keyword">int</span>[] s, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-comment">// 不选择</span><br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k++) &#123;<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - v[i][k] + w[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化：第i层的第j个只与第i-1层的第j个和第i-1层的第j-v[i][k]有关，因此优化方案与01背包一样</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i][k])<br>                dp[j] = Math.max(dp[j], dp[j - v[i][k] + w[i][k]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之Java基础</title>
    <link href="/2021/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BJava%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BJava%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="StringBuilder-和-StringBuffer-的异同点"><a href="#StringBuilder-和-StringBuffer-的异同点" class="headerlink" title="StringBuilder 和 StringBuffer 的异同点"></a>StringBuilder 和 StringBuffer 的异同点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">相同点：底层都是<span class="hljs-keyword">char</span>数组<br>不同点：前者是线程不安全的，后者是线程安全的(通过Synchronized修饰)<br></code></pre></td></tr></table></figure><h3 id="Java数组对象的内存分配"><a href="#Java数组对象的内存分配" class="headerlink" title="Java数组对象的内存分配"></a>Java数组对象的内存分配</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">基础类型的数组，分配在栈内存中，是连续分配的。<br><br>对象数组，对象引用连续分配在栈内存中。实际对象分配在堆内存，不是连续分配的<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="创建对象的方式有哪些？"><a href="#创建对象的方式有哪些？" class="headerlink" title="创建对象的方式有哪些？"></a>创建对象的方式有哪些？</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) new<br>(<span class="hljs-number">2</span>) clone()<br>(<span class="hljs-number">3</span>) 反射<br>(<span class="hljs-number">4</span>) 序列化<br></code></pre></td></tr></table></figure><h3 id="深拷贝-和-浅拷贝"><a href="#深拷贝-和-浅拷贝" class="headerlink" title="深拷贝 和 浅拷贝"></a>深拷贝 和 浅拷贝</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">浅拷贝：在堆内存中，将该对象复制了一份，也就是说产生了一个新的对象。<br><span class="hljs-code">       新对象的属性如果是基本类型，拷贝的就是基本类型的值；</span><br><span class="hljs-code">       如果属性是引用类型，拷贝的就是内存地址。</span><br><span class="hljs-code"></span><br><span class="hljs-code">深拷贝：在堆内存中，将该对象复制了一份，也就是说产生了一个新的对象。</span><br><span class="hljs-code">       在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</span><br></code></pre></td></tr></table></figure><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">== 用来比较栈中的值是否相等。对于基础类型直接比较值，对于引用类型比较地址值。</span><br><br>equals 用来比较堆中对象的内容是否相等。<br><br>Object类中的equals()用的是 ==, 因此如果不重写equals()的话，相当于使用 ==。<br></code></pre></td></tr></table></figure><h3 id="自动拆箱和自动装箱"><a href="#自动拆箱和自动装箱" class="headerlink" title="自动拆箱和自动装箱"></a>自动拆箱和自动装箱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">拆箱和装箱是指：基础类型和它们对应的包装类之间的转换。拆箱是把包装类型变成基本类型；装箱是把基本类型变成包装类型。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    <url>/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 堆是一个完全二叉树</span><br><span class="hljs-comment">// 核心操作：down(int x) 和 up(int x)</span><br><span class="hljs-comment">// 如果是从下标0开始，则父亲下标为(x - 1) / 2; 如果是从下标1开始，则父亲下标为 x / 2;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(size);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            data.add(arr[i]);<br>        <br>        <span class="hljs-comment">// 从最后一个叶子节点的父节点开始进行down, 即可O(N)实现堆化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            down(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 上浮操作 : 用于添加元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 当不是根节点时，不断与其父节点进行比较。</span><br>        <span class="hljs-comment">// 如果比根节点更小，则进行交换。继续上浮</span><br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; data.get(index) &lt; data.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &#123;<br>            Collections.swap(data, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始t为当前节点，代表值最小的位置</span><br>        <span class="hljs-keyword">int</span> t = index;<br>        <span class="hljs-comment">// 如果左孩子存在，当前最小节点则与左孩子进行比较。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span> &lt; data.size() &amp;&amp; data.get(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>) &lt; data.get(t))<br>            t = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 如果右孩子存在，当前最小节点则与左孩子进行比较。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span> &lt; data.size() &amp;&amp; data.get(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>) &lt; data.get(t))<br>            t = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 如果当前节点不是最小节点，则进行交换。继续下沉。</span><br>        <span class="hljs-keyword">if</span> (t != index) &#123;<br>            Collections.swap(data, t, index);<br>            down(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-comment">// 末尾添加新元素，然后不断上浮</span><br>        data.add(v);<br>        up(data.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 提取堆顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = data.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 末尾元素与堆顶元素交换，然后不断下沉</span><br>        Collections.swap(data, <span class="hljs-number">0</span>, data.size() - <span class="hljs-number">1</span>);<br>        data.remove(data.size() - <span class="hljs-number">1</span>);<br>        down(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集[Acwing]</title>
    <link href="/2021/03/18/Acwing/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/03/18/Acwing/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Acwing837-连通块中点的数量"><a href="#Acwing837-连通块中点的数量" class="headerlink" title="Acwing837_连通块中点的数量"></a>Acwing837_连通块中点的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 合并两个集合：必须先累加size再合并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            size[find(b)] += size[find(a)];<br>            p[find(a)] = find(b);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回x所在连通块的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size[find(x)];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing240-食物链"><a href="#Acwing240-食物链" class="headerlink" title="Acwing240_食物链"></a>Acwing240_食物链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要额外维护当前节点到根节点的距离</span><br><span class="hljs-comment">// 到根节点距离为0 : 与根节点同类</span><br><span class="hljs-comment">// 到根节点距离为1 : 能够吃根节点</span><br><span class="hljs-comment">// 到根节点距离为2 : 能够被根节点吃</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩过程中维护到根节点的距离</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                root</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">              /   d[p[x]]</span><br><span class="hljs-comment">            p[x]</span><br><span class="hljs-comment">            /</span><br><span class="hljs-comment">           /  d[x]</span><br><span class="hljs-comment">          x</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x]) &#123;<br>            <span class="hljs-keyword">int</span> u = find(p[x]); <span class="hljs-comment">// 寻找它当前根节点的父节点</span><br>            <span class="hljs-comment">// 它到新父节点的距离 = 它原来父节点的距离 + 它原来父节点到新父节点的距离</span><br>            d[x] = (d[x] + d[p[x]]) % M;    <br>            p[x] = u;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 与 b 是否同类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br><br>        <span class="hljs-comment">// 如果a和b已经同属于一个集合了，则判断到根节点的距离是否相等</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == d[b] % M;<br>        <br>        <span class="hljs-comment">// 否则，需要将两者放入同一个集合，并更新d[pa]到pb的距离</span><br>        <span class="hljs-comment">// 由于 a 和 b 同类， 所以 (d[a] + d[pa]) % M == d[b] % M</span><br>        <span class="hljs-comment">// 因此 d[pa] = (d[b] - d[a] + M) % M  --- 加M是以防d[a] - d[b] &lt; 0</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 是否能吃 b</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br>        <br>        <span class="hljs-comment">// 如果已经是同类，则a能吃b的前提是 a到根节点的距离 - 1 == b到根节点的距离</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == (d[b] + <span class="hljs-number">1</span>) % M;<br>        <br>        <span class="hljs-comment">// 否则加入同一集合，并维护a吃b的关系</span><br>        <span class="hljs-comment">// (d[a] + d[pa]) % M == (d[b] + 1) % M;</span><br>        <span class="hljs-comment">// d[pa] = (d[b] + 1 - d[a] + M) % M;</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] + <span class="hljs-number">1</span> - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-comment">// 维护并查集的个数</span><br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            p[i] = i;<br>        <br>        <span class="hljs-keyword">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            p[find(a)] = find(b);<br>            size--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            <span class="hljs-comment">// 必须数量相加再合并</span><br>            size[find(b)] += size[find(a)];<br>            p[find(a)] = find(b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护到祖宗节点的并查集"><a href="#维护到祖宗节点的并查集" class="headerlink" title="维护到祖宗节点的并查集"></a>维护到祖宗节点的并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩过程中维护到根节点的距离</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                root</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">              /   d[p[x]]</span><br><span class="hljs-comment">            p[x]</span><br><span class="hljs-comment">            /</span><br><span class="hljs-comment">           /  d[x]</span><br><span class="hljs-comment">          x</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x]) &#123;<br>            <span class="hljs-keyword">int</span> u = find(p[x]); <span class="hljs-comment">// 寻找它当前根节点的父节点</span><br>            <span class="hljs-comment">// 它到新父节点的距离 = 它原来父节点的距离 + 它原来父节点到新父节点的距离</span><br>            d[x] = (d[x] + d[p[x]]) % M;    <br>            p[x] = u;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 与 b 是否同类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br><br>        <span class="hljs-comment">// 如果a和b已经同属于一个集合了，则判断到根节点的距离是否相等</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == d[b] % M;<br>        <br>        <span class="hljs-comment">// 否则，需要将两者放入同一个集合，并更新d[pa]到pb的距离</span><br>        <span class="hljs-comment">// 由于 a 和 b 同类， 所以 (d[a] + d[pa]) % M == d[b] % M</span><br>        <span class="hljs-comment">// 因此 d[pa] = (d[b] - d[a] + M) % M  --- 加M是以防d[a] - d[b] &lt; 0</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 是否能吃 b</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br>        <br>        <span class="hljs-comment">// 如果已经是同类，则a能吃b的前提是 a到根节点的距离 - 1 == b到根节点的距离</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == (d[b] + <span class="hljs-number">1</span>) % M;<br>        <br>        <span class="hljs-comment">// 否则加入同一集合，并维护a吃b的关系</span><br>        <span class="hljs-comment">// (d[a] + d[pa]) % M == (d[b] + 1) % M;</span><br>        <span class="hljs-comment">// d[pa] = (d[b] + 1 - d[a] + M) % M;</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] + <span class="hljs-number">1</span> - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之操作系统</title>
    <link href="/2021/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span>、进程是资源分配的最小单位；线程是任务执行<span class="hljs-comment">(资源调度)</span>的最小单位。<br><br><span class="hljs-number">2</span>、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵；多个线程共享进程的地址空间和数据，因此线程的维护和切换代价比进程要低很多。<br><br><span class="hljs-number">3</span>、进程之间的需要以IPC的方式进行通信；线程由于共享进程的全局变量和静态变量，因此通信更为方便。<br></code></pre></td></tr></table></figure><h3 id="进程调度算法有哪些？"><a href="#进程调度算法有哪些？" class="headerlink" title="进程调度算法有哪些？"></a>进程调度算法有哪些？</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) 先来先服务<br>(<span class="hljs-number">2</span>) 时间片轮转<br>(<span class="hljs-number">3</span>) 短作业优先<br>(<span class="hljs-number">4</span>) 优先级调度<br>(<span class="hljs-number">5</span>) 多级反馈队列 <span class="hljs-selector-attr">[详细了解]</span><br></code></pre></td></tr></table></figure><h3 id="5种IO模型"><a href="#5种IO模型" class="headerlink" title="5种IO模型"></a>5种IO模型</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gcode">同步 <span class="hljs-attr">vs 异步</span><br><span class="hljs-attr">阻塞 vs 非阻塞</span><br><span class="hljs-attr"></span><br><span class="hljs-attr">(1</span>) 阻塞式IO<br>    <br><span class="hljs-comment">(2)</span> 非阻塞式IO<br>    <br><span class="hljs-comment">(3)</span> 多路复用IO<br><br><span class="hljs-comment">(4)</span> 信号驱动IO<br><br><span class="hljs-comment">(5)</span> 异步IO<br></code></pre></td></tr></table></figure><h3 id="进程的通信方式有哪些？线程呢？"><a href="#进程的通信方式有哪些？线程呢？" class="headerlink" title="进程的通信方式有哪些？线程呢？"></a>进程的通信方式有哪些？线程呢？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode">进程间的通信方式：<br>    <span class="hljs-comment">(1)</span> 匿名管道：<br>    <span class="hljs-comment">(2)</span> 管道<span class="hljs-comment">(有名管道)</span><br>    <span class="hljs-comment">(3)</span> 消息队列<br>    <span class="hljs-comment">(4)</span> 信号量<br>    <span class="hljs-comment">(5)</span> 共享内存<br>    <span class="hljs-comment">(7)</span> 套接字<br><br>线程间的通信方式：<br>    <span class="hljs-comment">(1)</span> 互斥量: 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。<br>    <span class="hljs-comment">(2)</span> 信号量<br></code></pre></td></tr></table></figure><h3 id="什么是僵尸进程-什么是孤儿进程-有什么危害"><a href="#什么是僵尸进程-什么是孤儿进程-有什么危害" class="headerlink" title="什么是僵尸进程? 什么是孤儿进程? 有什么危害?"></a>什么是僵尸进程? 什么是孤儿进程? 有什么危害?</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">僵尸进程：<br>    一个进程fork了子进程，如果子进程退出，但是它的父进程没有调用wait/waitpid获取子进程的状态信息，那么子进程的进程描述符等一系列信息还会保存在系统中。这样的进程我们称为僵尸进程。<br><br>    危害：僵尸进程是一个早已死亡的进程，但是在进程表中仍占用了一个位置，而进程表的容量是有限的，如果僵尸进程过多的话可能导致系统无法产生新的进程，导致系统瘫痪。<br><br>处理僵尸进程：<br>    (<span class="hljs-number">1</span>) 修改父进程。子进程死亡后会发送SIGCHLD信号给父进程，父进程收到此信号后调用wait/waitpid进行处理。<br>    (<span class="hljs-number">2</span>) 杀死父进程。杀死父进程后，僵尸进程会进化为孤儿进程，继而由<span class="hljs-number">1</span>号进程<span class="hljs-keyword">init</span>接管，<span class="hljs-keyword">init</span>进程会负责处理孤儿进程。<br><br>孤儿进程：<br>    父进程运行结束，但子进程还在运行 (未运行结束) 的子进程就称为孤儿进程。 <br>    <br>    孤儿进程最终会被 <span class="hljs-keyword">init</span> 进程 (进程号为 <span class="hljs-number">1</span>) 所收养，因此 <span class="hljs-keyword">init</span> 进程此时变成孤儿进程 的父进程，并由 <span class="hljs-keyword">init</span> 进程对它们完成状态收集工作。<br></code></pre></td></tr></table></figure><h3 id="CPU上下文切换有几种？系统中断进行了几次上下文切换？"><a href="#CPU上下文切换有几种？系统中断进行了几次上下文切换？" class="headerlink" title="CPU上下文切换有几种？系统中断进行了几次上下文切换？"></a>CPU上下文切换有几种？系统中断进行了几次上下文切换？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">上下文切换是一种将<span class="hljs-meta">CPU</span>资源从一个进程分配给另外一个进程的机制。操作系统需要先保存当前进程的状态(内存空间的指针，指令执行的位置等)，然后才能加载另外一个进程的状态并执行。<br><br><span class="hljs-meta">CPU</span>的上下文切换分为三种：进程上下文切换、线程上下文切换、中断上下文切换。<br><br>(<span class="hljs-number">1</span>) 系统调用过程中也会发生 <span class="hljs-meta">CPU</span> 上下文切换。<span class="hljs-meta">CPU</span> 寄存器会先保存用户态的状态，然后加载内核态相关内容。系统调用结束之后，<span class="hljs-meta">CPU</span> 寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次 <span class="hljs-meta">CPU</span> 上下文切换。<br><br>(<span class="hljs-number">2</span>) 进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调 用的上下文则不会，因为其未发生进程的变化。<br><br>(<span class="hljs-number">3</span>) 内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。 线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。而线程自己的 私有数据，如栈和寄存器等，上下文切换时需要保存。<br></code></pre></td></tr></table></figure><h3 id="虚拟内存的实现方式有哪些？分别有什么缺陷？"><a href="#虚拟内存的实现方式有哪些？分别有什么缺陷？" class="headerlink" title="虚拟内存的实现方式有哪些？分别有什么缺陷？"></a>虚拟内存的实现方式有哪些？分别有什么缺陷？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 请求分页存储管理。将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如 <span class="hljs-number">4</span>KB、<span class="hljs-number">8</span>KB 或 <span class="hljs-number">16</span>KB 等，并以页面作为内存空间的最小分配单位，一个程序的一个页面 可以存放在任意一个物理页面里。页是信息的物理单位。<br><br><span class="hljs-comment">(2)</span> 请求分段存储管理。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组 相对完整的逻辑信息。段是信息的逻辑单位。<br><br>分页存储的缺点：产生内部碎片 <br>分段存储的缺点：产生外部碎片 <br><br><span class="hljs-comment">(3)</span> 采用段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组 合起来使用。这样做的目的就是想同时获得分段和分页的好处，但又避免了单独分段或单独分页的缺陷<br></code></pre></td></tr></table></figure><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h3 id="什么是中断？产生中断的方式有哪些？"><a href="#什么是中断？产生中断的方式有哪些？" class="headerlink" title="什么是中断？产生中断的方式有哪些？"></a>什么是中断？产生中断的方式有哪些？</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对 程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。<br><br>(<span class="hljs-number">1</span>) 由计算机硬件异常或故障引起的中断，称为内部异常中断<span class="hljs-comment">;</span><br>(<span class="hljs-number">2</span>) 由程序中执行了引起中断的指令而造成的中断，称为软中断（系统调用相关的中断)<span class="hljs-comment">;</span><br>(<span class="hljs-number">3</span>) 由外部设备请求引起的中断，称为外部中断<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="什么会导致用户态陷入内核态？"><a href="#什么会导致用户态陷入内核态？" class="headerlink" title="什么会导致用户态陷入内核态？"></a>什么会导致用户态陷入内核态？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 系统调用：操作系统提供的函数就被称为系统调用（system <span class="hljs-keyword">call</span>）。程序的执行一般是在用户态下 执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、 读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是 系统调用。<br><br><span class="hljs-comment">(2)</span> 异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时 会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如 缺页异常。<br><br><span class="hljs-comment">(3)</span> 外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号， 这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程 序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序 中执行后续操作等。<br></code></pre></td></tr></table></figure><h3 id="陷阱与中断的区别？"><a href="#陷阱与中断的区别？" class="headerlink" title="陷阱与中断的区别？"></a>陷阱与中断的区别？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 陷阱指令可以使执行流程从用户态陷入内核并把控制权转移给操作系统，使得用户程序 可以调用内核函数和使用硬件从而获得操作系统所提供的服务，比如用视频软件放一个 电影，视频软件就发出陷阱使用显示器和声卡从而访问硬件。<br><br><span class="hljs-comment">(2)</span> 中断是由外部事件导致并且它发生的时间是不可预测的，这一点和陷阱不同。外部事件 主要是指时钟中断，硬件中断等。CPU 决定切换到另一个进程运行，就会产生一个时 钟中断，切换到下一个进程运行。<br></code></pre></td></tr></table></figure><h3 id="同步与互斥的关系？"><a href="#同步与互斥的关系？" class="headerlink" title="同步与互斥的关系？"></a>同步与互斥的关系？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法 限制访问者对资源的访问顺序，即访问是无序的。 <br><br><span class="hljs-comment">(2)</span> 同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。<br><br>实现同步和互斥的方式<br>    <span class="hljs-comment">(1)</span> 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>    <span class="hljs-comment">(2)</span> 互斥量：为协调共同对一个共享资源的单独访问而设计的。 <br>    <span class="hljs-comment">(3)</span> 信号量：为控制一个具有有限数量用户资源而设计。 <br>    <span class="hljs-comment">(4)</span> 事 件：用来通知线程有一些事件已发生，从而启动后继任务的开始。<br></code></pre></td></tr></table></figure><h3 id="死锁产生的条件？"><a href="#死锁产生的条件？" class="headerlink" title="死锁产生的条件？"></a>死锁产生的条件？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">互斥条件 <span class="hljs-comment">(Mutual exclusion)</span>：资源不能被共享，只能由一个进程使用。<br>请求与保持条件 <span class="hljs-comment">(Hold and wait)</span>：已经得到资源的进程可以再次申请新的资源。<br>非抢占条件 <span class="hljs-comment">(No pre-emption)</span>：已经分配的资源不能从相应的进程中被强制地剥夺。<br>循环等待条件 <span class="hljs-comment">(Circular wait)</span>：系统中若干进程组成环路，该环路中每个进程都在等待 相邻进程正占用的资源。<br></code></pre></td></tr></table></figure><h3 id="IO多路复用的select、poll和epoll的区别"><a href="#IO多路复用的select、poll和epoll的区别" class="headerlink" title="IO多路复用的select、poll和epoll的区别"></a>IO多路复用的select、poll和epoll的区别</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">(<span class="hljs-number">1</span>) <span class="hljs-keyword">select</span> 函数监视文件描述符，调用后 <span class="hljs-keyword">select</span> 函数会阻塞，直到有描述符就绪，或者超时，函数返回，当 <span class="hljs-keyword">select</span> 函数返回后，就可以遍历描述符，找到就绪的描述符。<span class="hljs-keyword">select</span> 的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制 <br><br>(<span class="hljs-number">2</span>) poll 没有最大限制（但是数量过大后性能也是会下降）。和 <span class="hljs-keyword">select</span> 函数一样，poll 返回后， 需要轮询来获取就绪的描述符。<br><br>(<span class="hljs-number">3</span>) epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下多路复用 IO 接口 <span class="hljs-keyword">select</span>/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的 情况下的系统 CPU 利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听 的描述符集，只要遍历那些被内核 IO 事件异步唤醒而加入 Ready 队列的描述符集合 就行了。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算器问题</title>
    <link href="/2021/03/11/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/11/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="利用双栈解决所有计算器问题"><a href="#利用双栈解决所有计算器问题" class="headerlink" title="利用双栈解决所有计算器问题"></a>利用双栈解决所有计算器问题</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">利用数字栈nums和字符栈ops解决计算器问题：<br><br>遍历字符串：<br>    若是空格，跳过。<br>    若是&#x27;(&#x27;，压入ops中，等待与之匹配的&#x27;)&#x27;。<br>    若是&#x27;)&#x27;, 取ops和nums进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums。<br>    若是操作符，若ops栈顶的操作符优先级大于该操作符，则先计算栈顶的操作。直到遇到左括号或者没有操作符。否则压入ops中。<br>    若是数字，则一直累计直到遇到非数字，将数字压入nums中。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 建立字符串优先级</span><br>        m.put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);<br>        m.put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);<br>        m.put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 去掉所有空格</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 将所有&quot;(-&quot; 改为 &quot;(0-&quot;</span><br>        s = s.replaceAll(<span class="hljs-string">&quot;\\(-&quot;</span>, <span class="hljs-string">&quot;(0-&quot;</span>);<br><br>        Stack&lt;Character&gt; ops = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        Stack&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.push(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                ops.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 一直计算直到遇到左括号为止</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-keyword">char</span> op = ops.peek();<br>                    <span class="hljs-keyword">if</span> (op != <span class="hljs-string">&#x27;(&#x27;</span>)<br>                        cal(ops, nums);<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        ops.pop();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">int</span> j = i;<br>                    <span class="hljs-keyword">while</span> (j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(j) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                        sum = sum * <span class="hljs-number">10</span> + (s.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                        j++;<br>                    &#125;<br>                    nums.push(sum);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 碰到新操作符</span><br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">char</span> prev = ops.peek();<br>                        <span class="hljs-comment">// 如果之前的运算优先级更大，则先计算</span><br>                        <span class="hljs-keyword">if</span> (m.get(prev) &gt;= m.get(c))<br>                            cal(ops, nums);<br>                        <span class="hljs-keyword">else</span> <br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    ops.push(c);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的计算完</span><br>        <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>)<br>            cal(ops, nums);<br><br>        <span class="hljs-keyword">return</span> nums.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(Stack&lt;Character&gt; ops, Stack&lt;Integer&gt; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> a = nums.pop();<br>        <span class="hljs-keyword">int</span> b = nums.pop();<br>        <span class="hljs-keyword">char</span> op = ops.pop();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) ans = b + a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) ans = b - a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) ans = b * a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>) ans = b / a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) ans = (<span class="hljs-keyword">int</span>)Math.pow(b, a);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;%&#x27;</span>) ans = b % a;<br>        nums.push(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>计算器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC300_最长上升子序列</title>
    <link href="/2021/03/06/%E7%AE%97%E6%B3%95/LC0300_%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/03/06/%E7%AE%97%E6%B3%95/LC0300_%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    算法思想：</span><br><span class="hljs-comment">        dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment">        从[0, i - 1]从查找，如果遇到 nums[j] &lt; nums[i], 则 dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N ^ 2)</span><br><span class="hljs-comment">    空间复杂度: O(N) </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 记录最长递增子序列</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 初始化为1</span><br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从[0, n - 1]寻找比 nums[i] 小的数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        xMax = Math.max(xMax, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于二分法的优化。</span><br><span class="hljs-comment">    g[i]: 最大长度为i的递增子序列中序列的最小值</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    那么在遍历nums[i]的过程中，只需要在g[]中寻找 &lt; nums[i] 的右边界r，那么 dp[i] = r + 1; g[r + 1] = nums[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    例如：g[3] = 4; // 1 2 4</span><br><span class="hljs-comment">          g[4] = 6; // 1 2 4 6</span><br><span class="hljs-comment">          nums[i] = 5, 则g[4] = 5; // 1 2 4 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    g[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g[mid] &lt; nums[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前最大长度</span><br>        len = Math.max(len, r + <span class="hljs-number">1</span>);<br>        g[r + <span class="hljs-number">1</span>] = nums[i];<br>        dp[i] = r + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何获取最小字典序"><a href="#如何获取最小字典序" class="headerlink" title="如何获取最小字典序"></a>如何获取最小字典序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    此时dp[i]记录了以i结尾的最长上升子序列的长度；</span><br><span class="hljs-comment">    如果整个序列递增，那么显然dp[i]中的值从小到大依次递增。</span><br><span class="hljs-comment">    如果dp[i]中出现了相等的值，比如：</span><br><span class="hljs-comment">    1 2 5 3;    dp[2] = 3, dp[3] = 3;   显然后者的字典序更小</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[xMax];<br><span class="hljs-keyword">int</span> k = xMax - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = xMax; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// dp[i] == j, 则添加进res中</span><br>    <span class="hljs-keyword">if</span> (dp[i] == j) &#123;<br>        res[k--] = nums[i];<br>        j--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>线性DP</tag>
      
      <tag>最长上升子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据类型</title>
    <link href="/2021/03/06/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/03/06/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="redisObject类型"><a href="#redisObject类型" class="headerlink" title="redisObject类型"></a>redisObject类型</h3><blockquote><p>Redis是基于内存的K-V存储系统，其中 key 类型一般为字符串，而 value 类型则为 redis 对象(string, list, set…)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>数据类型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表</title>
    <link href="/2021/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/"/>
    <url>/2021/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="跳表简介"><a href="#跳表简介" class="headerlink" title="跳表简介"></a>跳表简介</h2><blockquote><ul><li>在有序链表的基础上添加跳跃功能减少不必要的搜索。</li><li>搜索、删除、添加的时间复杂度为 O(N * logN)。</li><li>跳表按层构造，高层相当于底层的’快速通道’</li></ul></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 定义链表节点Node</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>        K key;<br>        V value;<br>        Node&lt;K, V&gt;[] nexts; <span class="hljs-comment">// 存放后继节点数组</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> Node&lt;K, V&gt; first;   <span class="hljs-comment">// 首部虚拟节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-comment">// 跳表元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEVEL = <span class="hljs-number">32</span>;    <span class="hljs-comment">// 跳表最大层数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> level = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 记录有效层数</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkipList</span><span class="hljs-params">()</span> </span>&#123;<br>        first = <span class="hljs-keyword">new</span> Node&lt;&gt;();<br>        first.nexts = <span class="hljs-keyword">new</span> Node[MAX_LEVEL];<br>    &#125;<br><br>    <span class="hljs-comment">// 生成随机层数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (Math.random() &lt; <span class="hljs-number">0.25</span> &amp;&amp; level &lt; MAX_LEVEL)<br>            level++;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索get-K-key-设计"><a href="#搜索get-K-key-设计" class="headerlink" title="搜索get(K key)设计"></a>搜索get(K key)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、从首节点开始，一直找到第一个 &gt;= key 的下一个节点</span><br><span class="hljs-comment">    2、如果相等，则直接返回；否则从下一层继续寻找</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;<br><br>    Node&lt;K, V&gt; node = first;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-comment">// 若当前节点的key == key, 则找到了直接返回</span><br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> node.nexts[i].value;<br>        <br>        <span class="hljs-comment">// 没找到则从node.nexts[i-1]开始搜索</span><br>    &#125; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加put-K-key-V-value-设计"><a href="#添加put-K-key-V-value-设计" class="headerlink" title="添加put(K key, V value)设计"></a>添加put(K key, V value)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>  <br>    Node&lt;K, V&gt; node = first;  <br>    Node&lt;K, V&gt;[] prevs = <span class="hljs-keyword">new</span> Node[level];         <span class="hljs-comment">// 存放每次发生跳层的节点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-comment">// 若node.nexts[i].key == key, 则覆盖value</span><br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>) &#123;<br>            node.nexts[i].value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 记录发生跳转的节点</span><br>        prevs[i] = node;    <br>    &#125; <br><br>    <span class="hljs-comment">// 不存在改key, 则此时node是前驱节点, i == -1</span><br>    Node&lt;K, V&gt; newNode = <span class="hljs-keyword">new</span> Node(key, value);<br>    <span class="hljs-keyword">int</span> rdLevel = randomLevel();<br>    newNode.nexts = <span class="hljs-keyword">new</span> Node&lt;&gt;[rdLevel];<br><br>    <span class="hljs-comment">// 调整层数为[0, level - 1]的后继指向</span><br>    <span class="hljs-comment">// 如果rdLevel &gt; level, 则调整头节点next</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rdLevel; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; level) &#123;<br>            newNode.nexts[i] = prevs[i].nexts[i];<br>            prevs[i].nexts[i] = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            first.nexts[i] = newNode;<br>        &#125;<br>    &#125;<br><br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除remove-K-key-设计"><a href="#删除remove-K-key-设计" class="headerlink" title="删除remove(K key)设计"></a>删除remove(K key)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;<br>    Node&lt;K, V&gt; node = first;  <br>    Node&lt;K, V&gt;[] prevs = <span class="hljs-keyword">new</span> Node[level];         <span class="hljs-comment">// 存放每次发生跳层的节点</span><br>    <span class="hljs-keyword">boolean</span> exist = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>)<br>            exist = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 找到key则进入下一层并记录所有发生跳转的节点</span><br>        prevs[i] = node;    <br>    &#125; <br><br>    <span class="hljs-comment">// 如果没找到则返回null</span><br>    <span class="hljs-keyword">if</span> (!exist) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 调整所有前驱的后继</span><br>    Node&lt;K, V&gt; removeNode = node.nexts[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; removeNode.nexts.length; i++) &#123;<br>        prevs[i].nexts[i] = removeNode.nexts[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 更新跳表的层数, 从头节点出发寻找next[i]不为空的层数</span><br>    <span class="hljs-keyword">int</span> newLevel = level;<br>    <span class="hljs-keyword">while</span> (newLevel &gt; <span class="hljs-number">0</span> &amp;&amp; first.nexts[newLevel] == <span class="hljs-keyword">null</span>)<br>        newLevel--;<br>    <br>    level = newLevel;<br><br>    size--;<br>    <span class="hljs-keyword">return</span> removeNode.value;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>跳表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2021/03/05/Acwing/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2021/03/05/Acwing/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>前缀和与差分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2021/03/04/Acwing/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2021/03/04/Acwing/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="Acwing791-高精度加法"><a href="#Acwing791-高精度加法" class="headerlink" title="Acwing791_高精度加法"></a>Acwing791_高精度加法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-comment">// 将两个大数字符串翻转</span><br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录进位情况</span><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length() || i &lt; b.length(); i++) &#123;<br>        <span class="hljs-comment">// 按位累加</span><br>        <span class="hljs-keyword">if</span> (i &lt; a.length()) t += a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; b.length()) t += b.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        sb.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-number">0</span>) sb.append(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing792-高精度减法"><a href="#Acwing792-高精度减法" class="headerlink" title="Acwing792_高精度减法"></a>Acwing792_高精度减法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sub</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-comment">// 默认 a &gt; b</span><br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录借位情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        t -= a[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; b.length()) <br>            t -= b[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <span class="hljs-comment">// 此时t若小于0则发生借位, t若大于0则没发生借位</span><br>        <span class="hljs-comment">// (t + 10) % 10, 可以保证无论是否发生借位都可以是正数</span><br>        sb.append((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);   <span class="hljs-comment">// 核心步骤</span><br>        t = t &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = sb.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index--;<br>    <br>    sb.delete(index + <span class="hljs-number">1</span>, sb.length());<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing793-高精度乘法"><a href="#Acwing793-高精度乘法" class="headerlink" title="Acwing793_高精度乘法"></a>Acwing793_高精度乘法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    情况1：大数 x 个位数</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    t += A[i] * b;  t /= 10;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br><br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        t += (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * b;<br><br>        res.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果此时 t == 87, 需要先添加7, 再添加8</span><br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-number">0</span>) &#123;<br>        sb.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 12345 x 0, 会存在前导0</span><br>    <span class="hljs-keyword">int</span> index = sb.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index--;<br>    <br>    sb = sb.delete(index + <span class="hljs-number">1</span>, sb.length());<br>    <br>    <span class="hljs-keyword">return</span> res.reverse().toString();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    情况2: 大数 x 大数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    c[i+j] += a[i] * b[j];</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul2</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length() + b.length()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.length(); j++) &#123;<br>            c[i][j] += (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (b.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理数组c的进位</span><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.length; i++) &#123;<br>        c[i] = (c[i] + t) % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = c.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; c[index] == <span class="hljs-number">0</span>)<br>        index--;<br>    <br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &gt;= <span class="hljs-number">0</span>; i--)<br>        sb.append(c[i]);<br><br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing794-高精度除法"><a href="#Acwing794-高精度除法" class="headerlink" title="Acwing794_高精度除法"></a>Acwing794_高精度除法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    高精度 / 低精度</span><br><span class="hljs-comment">    核心思想： r = r * 10 + A[i];  r / 10;  r %= b;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 保存余数</span><br><span class="hljs-keyword">int</span>[] res; <span class="hljs-comment">// 保存商</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">div</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        r = r * <span class="hljs-number">10</span> + (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        sb.append(r / b);<br>        r %= b;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除商的前导0</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; sb.length() - <span class="hljs-number">1</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index++;<br><br>    <span class="hljs-comment">// [index, sb.length() - 1]</span><br>    res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sb.length() - index];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; sb.length(); i++)<br>        res[k++] = sb.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    高精度 / 高精度</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>高精度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2021/03/04/Acwing/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2021/03/04/Acwing/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="二分法思想"><a href="#二分法思想" class="headerlink" title="二分法思想"></a>二分法思想</h2><blockquote><p>二分法常用于有序状态的数组中，通过中点值与条件的比较一下筛选掉一半的处理规模，从而使时间复杂度从O(N)降到O(logN)</p></blockquote><blockquote><ul><li>整数二分</li><li>小数二分</li></ul></blockquote><h3 id="Acwing789-数的范围"><a href="#Acwing789-数的范围" class="headerlink" title="Acwing789_数的范围"></a>Acwing789_数的范围</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    元素k的起始位置和终止位置，没找到则返回[-1, -1]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1、寻找 &gt;= k 的左边界l和 &lt;= k 的右边界r</span><br><span class="hljs-comment">    2、如果边界处的值不等于k, 则说明k不存在</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] num_score(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <br>    <span class="hljs-comment">// 寻找 &gt;= k 的左边界</span><br>    <span class="hljs-keyword">int</span> l1 = <span class="hljs-number">0</span>, r1 = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l1 &lt; r1) &#123;<br>        <span class="hljs-keyword">int</span> mid1 = (l1 + r1) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 如果中点处的值 &gt;= k, 则缩小右边界的范围，因为[mid1, r1]肯定都 &gt;= k</span><br>        <span class="hljs-keyword">if</span> (nums[mid1] &gt;= k)<br>            r1 = mid1;<br>        <span class="hljs-comment">// 否则说明[l1, mid1]都 &lt; k, 那么 &gt;= k的左边界只可能在[mid1 + 1, r1]之间</span><br>        <span class="hljs-keyword">else</span><br>            l1 = mid1 + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果边界处的值不等于k则说明元素不存在</span><br>    <span class="hljs-keyword">if</span> (nums[l1] != k)  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-comment">// 寻找 &lt;= k 的右边界</span><br>    <span class="hljs-keyword">int</span> l2 = <span class="hljs-number">0</span>, r2 = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l2 &lt; r2) &#123;<br>        <span class="hljs-comment">// 如果是使得l = mid, 则应该 + 1</span><br>        <span class="hljs-keyword">int</span> mid2 = (l2 + r2 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 如果中点处的值 &lt;= k, 则缩小右边界的范围，因为[l2, mid2]肯定都 &lt;= k</span><br>        <span class="hljs-keyword">if</span> (nums[mid2] &lt;= k)<br>            l2 = mid1;<br>        <span class="hljs-comment">// 否则说明[mid2, r2]都 &gt; k, 那么 &gt;= k的左边界只可能在[l2, mid2 - 1]之间</span><br>        <span class="hljs-keyword">else</span><br>            l2 = mid2 - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l1, l2&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing790-数的三次方根"><a href="#Acwing790-数的三次方根" class="headerlink" title="Acwing790_数的三次方根"></a>Acwing790_数的三次方根</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    计算数的三次方根</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">three_sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> l = -<span class="hljs-number">100</span>, r = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 通过精度来控制循环, 一半比要求的精度低两个数量级</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1e-8</span>) &#123;<br>        <span class="hljs-keyword">double</span> mid = (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">double</span> t = mid * mid * mid;<br>        <span class="hljs-keyword">if</span> (t &lt; target)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <br>    System.out.printf(<span class="hljs-string">&quot;%.6f&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>二分法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/03/04/Acwing/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/04/Acwing/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="归并排序的思想"><a href="#归并排序的思想" class="headerlink" title="归并排序的思想"></a>归并排序的思想</h2><blockquote><p>归并排序是基于 <strong>分治</strong> 和 <strong>递归</strong> 的思想。</p><ul><li>选取数组中间点为分割点</li><li>递归排序左子数组和右子数组</li><li>归并两个有序的子数组</li></ul></blockquote><h3 id="Acwing787-归并排序模板"><a href="#Acwing787-归并排序模板" class="headerlink" title="Acwing787_归并排序模板"></a>Acwing787_归并排序模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：子数组无元素或只剩一个元素</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 选取中间点作为分割点</span><br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 递归排序左右数组</span><br>    merge_sort(nums, l, mid);<br>    merge_sort(nums, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">// 归并两个有序数组</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j])<br>            temp[k++] = nums[i++];<br>        <span class="hljs-keyword">else</span><br>            temp[k++] = nums[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)    temp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)   temp[k++] = nums[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        nums[i] = temp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing788-逆序对的数量"><a href="#Acwing788-逆序对的数量" class="headerlink" title="Acwing788_逆序对的数量"></a>Acwing788_逆序对的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用归并排序的思想，在归并两个有序数组的时候对逆序对进行累加</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N * logN)</span><br><span class="hljs-comment">    空间复杂度：O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 返回数组区间[l, r]的逆序对数量</span><br><span class="hljs-comment">// 那么总的逆序对为 左边的逆序对 + 右边的逆序对 + 左右数组形成的逆序对</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">mergeSort_findReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：数组无元素或只有一个元素无法形成逆序对，返回0</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 累加左数组的逆序对和右数组的逆序对</span><br>    <span class="hljs-keyword">long</span> res = mergeSort_findReverse(nums, l, mid) + mergeSort_findReverse(nums, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">// 两个有序数组归并的过程中继续累加逆序对</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>            temp[k++] = nums[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// i &lt; j 但是 nums[i] &gt; nums[j], 则[i, mid]均大于nums[j]</span><br>            temp[k++] = nums[j++];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)    temp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)   temp[k++] = nums[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        nums[i] = temp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/03/04/Acwing/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/04/Acwing/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="快排的思想"><a href="#快排的思想" class="headerlink" title="快排的思想"></a>快排的思想</h2><blockquote><p>快速排序是基于 <strong>分治</strong> 和 <strong>递归</strong> 的思想。</p><ul><li>选取分界点x。</li><li>双指针处理，使得 &lt;= x 的都在左边， &gt;= x 的都在右边。</li><li>递归排序左右子数组, 递归出口为子数组无元素或只有一个元素。</li></ul></blockquote><h3 id="Acwing785-快排模板"><a href="#Acwing785-快排模板" class="headerlink" title="Acwing785_快排模板"></a>Acwing785_快排模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    时间复杂度: O(N ^ logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：子数组无元素或只剩一个元素</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 1、选取数组中存在的值作为分界值</span><br>    <span class="hljs-keyword">int</span> x = nums[l + (r - l) / <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 2、保证 &lt;= x 的都在左边， &gt;= x 的都在右边</span><br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br><br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> t = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3、递归处理左右子数组</span><br>    quick_sort(nums, l, j);<br>    quick_sort(nums, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing786-寻找第k小的数"><a href="#Acwing786-寻找第k小的数" class="headerlink" title="Acwing786_寻找第k小的数"></a>Acwing786_寻找第k小的数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于快排的思想将小的数放在数组右边，大的数放在数组左边</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    当右子数组长度 len &gt;= k时，说明第k大的数是右数组的第k大的数</span><br><span class="hljs-comment">    当右子数组长度 len &lt; k时, 说明第k大的数是左数组的第(k - len)大的数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    递归的向相应的子数组中寻找，直到数组中只剩下一个元素则为目标值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 当只剩下一个数的时候，说明找到了第K小的数</span><br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> arr[l];<br>    <br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> target = arr[(l + r) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (arr[i] &lt; target);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (arr[j] &gt; target);<br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> len = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (len &gt;= k)<br>        <span class="hljs-keyword">return</span> findKth(arr, l, j, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findKth(arr, j + <span class="hljs-number">1</span>, r, k - len);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
