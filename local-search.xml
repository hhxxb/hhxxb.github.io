<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP</title>
    <link href="/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP(%E9%87%8D%E8%A6%81)/"/>
    <url>/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP(%E9%87%8D%E8%A6%81)/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>传输层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FTP</title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/FTP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/FTP/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>FTP是文件传输协议，使用TCP提供可靠传输，一个FTP服务器可以为多个客户进程提供服务。</li><li>FTP使用两个并行的TCP连接，一个是控制连接(21端口), 一个数据连接(20端口)。</li></ul></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 服务端监听<span class="hljs-number">21</span>号端口，等待客户端的连接<br><span class="hljs-comment">(2)</span> 客户端发起连接请求后，启动数据连接处理客户端请求，处理完毕后，数据连接关闭。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DHCP</title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>DHCP协议是：动态主机配置协议，用来动态的给加入网络的主机分配IP地址。</li><li>DHCP客户端使用UDP协议，端口号68</li><li>DHCP服务端使用TCP协议，端口号67</li></ul></blockquote><h3 id="DHCP的工作流程"><a href="#DHCP的工作流程" class="headerlink" title="DHCP的工作流程"></a>DHCP的工作流程</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-number">1</span>) 一个新加入的主机，需要向DHCP服务器申请<span class="hljs-built_in">IP</span>地址。由于刚开始它没有<span class="hljs-built_in">IP</span>地址，因此它源<span class="hljs-built_in">IP</span>地址全部设为<span class="hljs-number">0</span>，目的<span class="hljs-built_in">IP</span>地址全部设为<span class="hljs-number">1</span>. 以广播的方式发送DHCPDISCOVER报文。<br><br>(<span class="hljs-number">2</span>) 凡是收到DHCPDISCOVER报文的DHCP服务器都发出DHCP提供报文，DHCP客户端从中选择一个，并向所选择的DHCP服务器发送DHCP请求报文。<br><br>(<span class="hljs-number">3</span>) 被选择的DHCP服务器发送DHCPACK的确认报文并提供<span class="hljs-built_in">IP</span>地址给DHCP客户端使用。DHCP客户端设置使用时限。<br><br>(<span class="hljs-number">4</span>) 当使用时限过半时，DHCP客户端申请重新设置计时器。如果服务器同意则发回确认报文DHCPACK，客户端继续使用<span class="hljs-built_in">IP</span>；否则发送否认报文DHCPNACK，客户端需要重新申请<span class="hljs-built_in">IP</span>。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>DHCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0064_最小路径和</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0061-0080/LC0064_%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0061-0080/LC0064_%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个包含非负整数的 m x <span class="hljs-built_in">n</span> 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br><br>说明：每次只能向下或者向右移动一步。<br></code></pre></td></tr></table></figure><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 从(0, 0)走到(i, j)的最小路径和</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    集合划分：(从上方而来 | 从右方而来)</span><br><span class="hljs-comment">         min (dp[i-1][j], dp[i-1][j]) + grid[i][j]</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    初始化: 第一行和第一列进行单独累加处理</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid == <span class="hljs-keyword">null</span> || grid.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> row = grid.length;<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row][col];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; col; j++)<br>        dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>            dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[row-<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0063_不同路径ii</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0061-0080/LC0063_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84ii/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0061-0080/LC0063_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84ii/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“<span class="hljs-literal">Start</span>” ）。<br><br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br><br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br></code></pre></td></tr></table></figure><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 从(0, 0)走到(i, j)的不同路径数</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    集合划分：(dp[i][j] != 1 | dp[i][j] == 1)</span><br><span class="hljs-comment">         sum (dp[i-1][j], dp[i-1][j] | 0)</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    障碍处：dp[i][j] = 0;   否则可以从上方或者右方而来。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    初始化：对第一行和第一列进行初始化，如果没遇到障碍则为，遇到了后面都为0</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = obstacleGrid.length;<br>    <span class="hljs-keyword">int</span> col = obstacleGrid[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row][col];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// break掉是因为后面走不了，直接为0</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// break掉是因为后面走不了，直接为0</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>                dp[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[row-<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0062_不同路径</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0061-0080/LC0062_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0061-0080/LC0062_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “<span class="hljs-literal">Start</span>” ）。<br><br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br><br>问总共有多少条不同的路径？<br></code></pre></td></tr></table></figure><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 从(0, 0)走到(i, j)的不同路径数</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    集合划分：(从上方而来 | 从右方而来)</span><br><span class="hljs-comment">         sum (dp[i-1][j] | dp[i-1][j])</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    初始化: 第一行和第一列都只有1种方案。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 处于边缘地带只有一条路可走</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 从上或左而来</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0061_旋转链表</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0061-0080/LC0061_%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0061-0080/LC0061_%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br><br>示例 <span class="hljs-number">1</span>:<br><br>输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL, k = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;NULL<br></code></pre></td></tr></table></figure><h4 id="方法1：成环再断链"><a href="#方法1：成环再断链" class="headerlink" title="方法1：成环再断链"></a>方法1：成环再断链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    遍历链表成环，并统计链表长度。</span><br><span class="hljs-comment">    向前走 n - k - 1步, 然后断链，后一个节点就是新的开头。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || k == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> head;<br><br>    <span class="hljs-comment">// 成环并统计长度</span><br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>;<br>    ListNode curNode = head;<br>    <span class="hljs-keyword">while</span> (curNode.next != <span class="hljs-keyword">null</span>) &#123;<br>        n++;<br>        curNode = curNode.next;<br>    &#125;<br><br>    curNode.next = head;<br><br>    <span class="hljs-comment">// 向前走 n - k - 1步</span><br>    k = k % n;<br>    k = n - k - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        head = head.next;<br>    <br>    ListNode res = head.next;<br>    head.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0060_排列序列</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0060_%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0060_%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">给出集合 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,...,<span class="hljs-built_in">n</span>]，其所有元素共有 <span class="hljs-built_in">n</span>! 种排列。<br><br>按大小顺序列出所有排列情况，并一一标记，当 <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span> 时, 所有排列如下：<br><br><span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-string">&quot;132&quot;</span><br><span class="hljs-string">&quot;213&quot;</span><br><span class="hljs-string">&quot;231&quot;</span><br><span class="hljs-string">&quot;312&quot;</span><br><span class="hljs-string">&quot;321&quot;</span><br>给定 <span class="hljs-built_in">n</span> 和 k，返回第 k 个排列。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;213&quot;</span><br></code></pre></td></tr></table></figure><h4 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    这一题最大的难点在于：利用深度对应分支的个数与k的关系来提前剪枝</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    若 当前层的所有分支的个数： fac[n - depth - 1]</span><br><span class="hljs-comment">    如果 k &gt; fac[n - depth - 1], 则该分支个数不足，提前剪枝，并且 k -= fac[n - depth - 1]; continue;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] fac;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 预处理阶乘值</span><br>    fac = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    fac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        fac[i] = fac[i - <span class="hljs-number">1</span>] * i;<br>    <br>    <span class="hljs-keyword">int</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    dfs(n, k, <span class="hljs-number">0</span>, used, sb);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> depth, <span class="hljs-keyword">int</span>[] used, StringBuilder sb)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (depth == n)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <br>        <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 计算改层的方案数</span><br>        <span class="hljs-keyword">int</span> cnt = fac[n - depth - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (k &gt; cnt) &#123;<br>            k -= cnt;<br>            <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 这个continue很关键，比如以1开头的不够，那么剪掉它的所有方案数，看以2开头的是否满足</span><br>        &#125;<br><br>        used[i] = <span class="hljs-number">1</span>;<br>        sb.append(i);<br><br>        dfs(n, k, depth + <span class="hljs-number">1</span>, used, sb);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0059_螺旋矩阵ii</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0059_%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0059_%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</url>
    
    <content type="html"><![CDATA[<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>        <span class="hljs-comment">// 向右走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) &#123;<br>            matrix[top][i] = cnt++;<br>        &#125;<br>        top++;<br><br>        <span class="hljs-comment">// 向下走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &lt;= bottom; i++) &#123;<br>            matrix[i][right] = cnt++;<br>        &#125;<br>        right--;<br><br>        <span class="hljs-comment">// 向左走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = right; i &gt;= left &amp;&amp; top &lt;= bottom; i--) &#123;<br>            matrix[bottom][i] = cnt++;<br>        &#125;<br>        bottom--;<br>        <br>        <span class="hljs-comment">// 向上走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = bottom; i &gt;= top &amp;&amp; left &lt;= right; i--) &#123;<br>            matrix[i][left] = cnt++;<br>        &#125;<br>        left++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> matrix;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0058_最后一个单词的长度</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0058_%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0058_%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 寻找第一个不是空格的位置</span><br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)<br>        i--;<br>    <br>    <span class="hljs-comment">// 全是空格</span><br>    <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 寻找遇到的第一个空格</span><br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != <span class="hljs-string">&#x27; &#x27;</span>)<br>        j--;<br>    <br>    <span class="hljs-comment">// [j + 1, i]</span><br>    <span class="hljs-keyword">return</span> i - j;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0056_合并区间</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0057_%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0057_%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">给你一个 无重叠的 ，按照区间起始端点排序的区间列表。<br><br>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：intervals = <span class="hljs-string">[[1,3],[6,9]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-string">[[1,5],[6,9]]</span><br></code></pre></td></tr></table></figure><h4 id="方法1：贪心"><a href="#方法1：贪心" class="headerlink" title="方法1：贪心"></a>方法1：贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    left记录插入区间的开头</span><br><span class="hljs-comment">    right记录插入区间的结尾</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    当前区间与插入区间的关系有三种：</span><br><span class="hljs-comment">        1、在插入区间的左边 且 无交集。 加入当前区间</span><br><span class="hljs-comment">        2、在插入区间的右边 且 无交集。 加入插入区间(如果还没加入过的话), 加入当前区间</span><br><span class="hljs-comment">        3、产生交集。 更新left 和 right</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    最后如果还没插入新区间，则插入new int[]&#123;left, right&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] insert(<span class="hljs-keyword">int</span>[][] intervals, <span class="hljs-keyword">int</span>[] newInterval) &#123;<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> left = newInterval[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> right = newInterval[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">boolean</span> used = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intervals) &#123;<br>        <span class="hljs-comment">// 如果当前区间在插入区间左侧 且 无交集</span><br>        <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">1</span>] &lt; left)<br>            arr.add(interval);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">0</span>] &gt; right) &#123;<br>            <span class="hljs-comment">// 如果当前区间在插入区间右侧 且 无交集</span><br><br>            <span class="hljs-comment">// 先插入新区间</span><br>            <span class="hljs-keyword">if</span> (!used) &#123;<br>                arr.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left, right&#125;);<br>                used = <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>            arr.add(interval);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 产生交集, 更新left和right</span><br>            left = Math.min(interval[<span class="hljs-number">0</span>], left);<br>            right = Math.max(interval[<span class="hljs-number">1</span>], right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!used)<br>        arr.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left, right&#125;);<br>    <br>    <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.size()][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); ++i) &#123;<br>        ans[i] = arr.get(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0056_合并区间</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0056_%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0056_%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals<span class="hljs-comment">[i]</span> = <span class="hljs-comment">[starti, endi]</span> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。<br><br>示例 1：<br><br>输入：intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,6]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[15,18]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[15,18]</span>]</span><br></code></pre></td></tr></table></figure><h4 id="方法1：贪心"><a href="#方法1：贪心" class="headerlink" title="方法1：贪心"></a>方法1：贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    begin 维护前一个区间的开头</span><br><span class="hljs-comment">    end 维护前一个区间的结尾</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    若 end &lt; 当前区间的开头，则不产生交集。 将前一个区间添加到结果集并跟新新的begin和end</span><br><span class="hljs-comment">    否则产生交集。 end = Math.max(end, 当前区间的结尾)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>    <span class="hljs-keyword">if</span> (intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    Arrays.sort(intervals, (o1, o2)-&gt; o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>] ? o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>] : o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">int</span> start = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (end &lt; intervals[i][<span class="hljs-number">0</span>]) &#123;<br>            arr.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;start, end&#125;);<br>            start = intervals[i][<span class="hljs-number">0</span>];<br>            end = intervals[i][<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            end = Math.max(end, intervals[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加最后一个区间</span><br>    arr.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;start, end&#125;);<br><br>    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.size()][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] t : arr)<br>        res[k++] = t;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0055_跳跃游戏</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0055_%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0055_%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nix">给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br><br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br><br>判断你是否能够到达最后一个下标。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="方法1：贪心"><a href="#方法1：贪心" class="headerlink" title="方法1：贪心"></a>方法1：贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    记录能到达的最远下标xMax。 </span><br><span class="hljs-comment">    如果 xMax &lt; i, 说明没法到达</span><br><span class="hljs-comment">    如果 xMax &gt;= n - 1, 说明可以到达</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 判断最远距离能否到达最后一个下标</span><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (xMax &gt;= nums.length - <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 如果最远距离无法到达当前位置，则返回false</span><br>        <span class="hljs-keyword">if</span> (xMax &lt; i)   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        xMax = Math.max(xMax, i + nums[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0054_螺旋矩阵</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0054_%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0054_%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> arr;<br>    <br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = col - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>, bottom = row - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>        <span class="hljs-comment">//　向右走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) &#123;<br>            arr.add(matrix[top][i]);<br>        &#125;<br>        top++;<br><br>        <span class="hljs-comment">//　向下走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = top; j &lt;= bottom; j++) &#123;<br>            arr.add(matrix[j][right]);<br>        &#125;<br>        right--;<br><br>        <span class="hljs-comment">//　向左走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = right; i &gt;= left &amp;&amp; top &lt;= bottom; i--) &#123;<br>            arr.add(matrix[bottom][i]);<br>        &#125;<br>        bottom--;<br><br>        <span class="hljs-comment">//　向上走</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = bottom; i &gt;= top &amp;&amp; left &lt;= right; i--) &#123;<br>            arr.add(matrix[i][left]);<br>        &#125;<br>        left++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0053_最大子序和</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0053_%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0053_%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><br>示例 1：<br><br>输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br></code></pre></td></tr></table></figure><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最大连续子序列的和</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(包括nums[i - 1]: 前提dp[i-1] &gt;= 0 | 不包括nums[i - 1])</span><br><span class="hljs-comment">             dp[i - 1] + nums[i]  | nums[i]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> xMax = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>)<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>        <span class="hljs-keyword">else</span><br>            dp[i] = nums[i];<br>        <br>        xMax = Math.max(xMax, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    由于dp[i]只与dp[i-1]有关，因此用一个变量记录即可。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> xMax = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;<br>        <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)<br>            sum = x;<br>        <span class="hljs-keyword">else</span><br>            sum += x;<br>        <br>        xMax = Math.max(xMax, sum);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0052_N皇后ii</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0052_N%E7%9A%87%E5%90%8Eii/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0052_N%E7%9A%87%E5%90%8Eii/</url>
    
    <content type="html"><![CDATA[<h3 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span>[] col;<br><span class="hljs-keyword">boolean</span>[] dg;<br><span class="hljs-keyword">boolean</span>[] fdg;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    col = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>    dg = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>];<br>    fdg = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">char</span>[][] str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        Arrays.fill(str[i], <span class="hljs-string">&#x27;.&#x27;</span>);<br>    <br>    dfs(str, <span class="hljs-number">0</span>, n);<br><br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] str, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == n) &#123;<br>        ++cnt;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; n; y++) &#123;<br>        <span class="hljs-keyword">if</span> (!col[y] &amp;&amp; !dg[x + y] &amp;&amp; !fdg[x - y + n]) &#123;<br>            col[y] = dg[x + y] = fdg[x - y + n] = <span class="hljs-keyword">true</span>;<br>            str[x][y] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br><br>            dfs(str, x + <span class="hljs-number">1</span>, n);<br><br>            col[y] = dg[x + y] = fdg[x - y + n] = <span class="hljs-keyword">false</span>;<br>            str[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0051_N皇后</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0051_N%E7%9A%87%E5%90%8E/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0051_N%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> 皇后问题 研究的是如何将 <span class="hljs-built_in">n</span> 个皇后放置在 <span class="hljs-built_in">n</span>×<span class="hljs-built_in">n</span> 的棋盘上，并且使皇后彼此之间不能相互攻击。<br><br>给你一个整数 <span class="hljs-built_in">n</span> ，返回所有不同的 <span class="hljs-built_in">n</span> 皇后问题 的解决方案。<br></code></pre></td></tr></table></figure><h4 id="方法1-回溯"><a href="#方法1-回溯" class="headerlink" title="方法1: 回溯"></a>方法1: 回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    col[]: 记录列是否已经放置</span><br><span class="hljs-comment">    dg[]: 正对角线是否已经放置</span><br><span class="hljs-comment">    fdg[]: 斜对角线是否已经放置</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">boolean</span>[] col;<br><span class="hljs-keyword">boolean</span>[] dg;<br><span class="hljs-keyword">boolean</span>[] fdg;<br>List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br>    col = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>    dg = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>];<br>    fdg = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">char</span>[][] str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        Arrays.fill(str[i], <span class="hljs-string">&#x27;.&#x27;</span>);<br>    <br>    dfs(str, <span class="hljs-number">0</span>, n);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] str, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == n) &#123;<br>        <span class="hljs-comment">// 保存结果</span><br>        List&lt;String&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>                sb.append(str[i][j]);<br>            arr.add(sb.toString());<br>        &#125;<br><br>        res.add(arr);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; n; y++) &#123;<br>        <span class="hljs-keyword">if</span> (!col[y] &amp;&amp; !dg[x + y] &amp;&amp; !fdg[x - y + n]) &#123;<br>            col[y] = dg[x + y] = fdg[x - y + n] = <span class="hljs-keyword">true</span>;<br>            str[x][y] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br><br>            dfs(str, x + <span class="hljs-number">1</span>, n);<br><br>            col[y] = dg[x + y] = fdg[x - y + n] = <span class="hljs-keyword">false</span>;<br>            str[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0050_Pow(x, n)</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0050_Pow(x,%20n)/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0050_Pow(x,%20n)/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">实现 pow(x, <span class="hljs-built_in">n</span>) ，即计算 x 的 <span class="hljs-built_in">n</span> 次幂函数（即，xn）。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：x = <span class="hljs-number">2.00000</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1024.00000</span><br></code></pre></td></tr></table></figure><h4 id="方法1：快速幂"><a href="#方法1：快速幂" class="headerlink" title="方法1：快速幂"></a>方法1：快速幂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    本质上利用的是：1 2 4 8 16 32 ... 能组成任意数的和。</span><br><span class="hljs-comment">    比如：x ^ k ： k的二进制是 10110011     那么第0、1、4、5、8位需要累乘对应的 x ^ i </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 快速幂</span><br>    <span class="hljs-keyword">long</span> t = n;<br>    <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) &#123;<br>        x = <span class="hljs-number">1</span> / x;<br>        t = -t;<br>    &#125;<br><br>    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">while</span> (t &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((t &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>            res = res * x;<br>        &#125;<br><br>        x = x * x;<br>        t &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0049_字母异位词分组</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0049_%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0049_%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。<br><br>示例:<br><br>输入: [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出:<br>[<br>  [<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>],<br>  [<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],<br>  [<span class="hljs-string">&quot;bat&quot;</span>]<br>]<br></code></pre></td></tr></table></figure><h4 id="方法1：哈希表"><a href="#方法1：哈希表" class="headerlink" title="方法1：哈希表"></a>方法1：哈希表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    建立&lt;String, List&lt;Srring&gt;&gt;的哈希表。</span><br><span class="hljs-comment">    对于每一个String, 进行排序。 如果排序后相同说明属于同一组。</span><br><span class="hljs-comment">*/</span><br><br>List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>    Map&lt;String, List&lt;String&gt;&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (String s : strs) &#123;<br>        <span class="hljs-comment">// 对s进行排序</span><br>        <span class="hljs-keyword">char</span>[] c = s.toCharArray();<br>        Arrays.sort(c);<br>        String t = <span class="hljs-keyword">new</span> String(c);<br>        <br>        <span class="hljs-keyword">if</span> (!m.containsKey(t))<br>            m.put(t, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        <br>        m.get(t).add(s);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : m.entrySet()) &#123;<br>        res.add(entry.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0048_旋转图像</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0048_%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0048_%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span> × <span class="hljs-built_in">n</span> 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 <span class="hljs-number">90</span> 度。<br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、转置</span><br><span class="hljs-comment">    2、交换列</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-comment">// 转置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>            <span class="hljs-keyword">int</span> t = matrix[i][j];<br>            matrix[i][j] = matrix[j][i];<br>            matrix[j][i] = t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对换列</span><br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = col - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">int</span> t = matrix[i][l];<br>            matrix[i][l] = matrix[i][r];<br>            matrix[i][r] = t;<br>        &#125;<br><br>        l++;<br>        r--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0047_全排列ii</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0047_%E5%85%A8%E6%8E%92%E5%88%97ii/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0047_%E5%85%A8%E6%8E%92%E5%88%97ii/</url>
    
    <content type="html"><![CDATA[<h3 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    全排列去重：</span><br><span class="hljs-comment">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])</span><br><span class="hljs-comment">            continue;</span><br><span class="hljs-comment">*/</span><br><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br><br>    Arrays.sort(nums);<br>    List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    dfs(nums, used, arr);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">boolean</span>[] used, List&lt;Integer&gt; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> ArrayList(arr));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (used[i])<br>            <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-comment">// 全排列去重方式</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br><br>        arr.add(nums[i]);<br>        used[i] = <span class="hljs-keyword">true</span>;<br><br>        dfs(nums, used, arr);<br><br>        arr.remove(arr.size() - <span class="hljs-number">1</span>);<br>        used[i] = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0046_全排列</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0046_%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0046_%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br><br>    List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br><br>    dfs(nums, used, arr);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">boolean</span>[] used, List&lt;Integer&gt; arr)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口： arr.length == nums.length</span><br>    <span class="hljs-keyword">if</span> (nums.length == arr.size()) &#123;<br>        res.add(<span class="hljs-keyword">new</span> ArrayList(arr));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 选择列表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (used[i])    <span class="hljs-keyword">continue</span>;<br><br>        used[i] = <span class="hljs-keyword">true</span>;<br>        arr.add(nums[i]);<br><br>        dfs(nums, used, arr);<br><br>        used[i] = <span class="hljs-keyword">false</span>;<br>        arr.remove(arr.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0045_跳跃游戏ii</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0045_%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0045_%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">给定一个非负整数数组，你最初位于数组的第一个位置。<br><br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br><br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br><br><span class="hljs-section">示例:</span><br><br><span class="hljs-section">输入: [2,3,1,1,4]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i]: 走到下标为i的点所需的最小步数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从0过来[前提是 0 + nums[0] &gt;= i] | 从1过来 | ... | 从i-1过来)</span><br><span class="hljs-comment">            min(dp[0] + 1 | dp[1] + 1 | ... | dp[i-1] + 1)</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    遍历[0, i - 1], 若能够跳到i则更新最小步数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N ^ 2)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 从DP的角度来看</span><br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];  <span class="hljs-comment">// 走到下标为i的点需要的最小步数</span><br>    Arrays.fill(dp, n);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 想前找能够到达该点的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (j + nums[j] &gt;= i)<br>                dp[i] = Math.min(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2：贪心"><a href="#方法2：贪心" class="headerlink" title="方法2：贪心"></a>方法2：贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    维护每一跳能够跳跃的最大位置。</span><br><span class="hljs-comment">    当 i 走到最大位置，更新下一跳的最大位置并跳跃次数 + 1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxEnd = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 记录能跳的最远的位置</span><br>        maxEnd = Math.max(maxEnd, nums[i] + i);<br><br>        <span class="hljs-comment">// 走到该跳的最远处，更新边界，跳跃次数 + 1</span><br>        <span class="hljs-keyword">if</span> (i == end) &#123;<br>            end = maxEnd;<br>            cnt++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0043_字符串相乘</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0043_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0043_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h3 id="方法1：大数乘法"><a href="#方法1：大数乘法" class="headerlink" title="方法1：大数乘法"></a>方法1：大数乘法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    核心操作：c[i][j] += a[i] * b[j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>    num1 = <span class="hljs-keyword">new</span> StringBuilder(num1).reverse().toString();<br>    num2 = <span class="hljs-keyword">new</span> StringBuilder(num2).reverse().toString();<br><br>    <span class="hljs-keyword">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num1.length() + num2.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num1.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; num2.length(); j++)<br>            c[i + j] += (num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理进位</span><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.length; i++) &#123;<br>        c[i] += t;<br>        t = c[i] / <span class="hljs-number">10</span>;<br>        c[i] %= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = c.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; c[index] == <span class="hljs-number">0</span>)<br>        index--;<br>    <br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>)<br>        res.append(c[index--]);<br>    <br>    <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数乘法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0042_接雨水</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0042_%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0042_%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">给定 n 个非负整数表示每个宽度为 <span class="hljs-number">1</span> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h4 id="方法1：单调栈"><a href="#方法1：单调栈" class="headerlink" title="方法1：单调栈"></a>方法1：单调栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    维护一个单调递减的栈。若当前数 &gt; 栈顶元素, 并且栈中数量 &gt;= 2, 则可以形成凹槽。</span><br><span class="hljs-comment">    雨水容量: (Math.min(nums[i], nums[st.peek()]) - top) * (i - st.peek() - 1)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-comment">// 单调栈：单调递减栈</span><br>    <span class="hljs-keyword">int</span> n = height.length;<br>    Stack&lt;Integer&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <br>        <span class="hljs-keyword">while</span> (!st.isEmpty() &amp;&amp; height[i] &gt; height[st.peek()]) &#123;<br>            <span class="hljs-keyword">int</span> top = height[st.pop()];<br>            <span class="hljs-keyword">if</span> (st.isEmpty())   <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 两个柱子无法形成凹槽</span><br>            res += (Math.min(height[i], height[st.peek()]) - top) * (i - st.peek() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        st.push(i);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0041_缺失的第一个正整数</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0041_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0041_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br><br>进阶：你可以实现时间复杂度为 <span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span> 并且只使用常数级别额外空间的解决方案吗？<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：nums = <span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="方法1：原地哈希"><a href="#方法1：原地哈希" class="headerlink" title="方法1：原地哈希"></a>方法1：原地哈希</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    将 1 ~ n 范围内的数映射到下标 0 ~ n - 1</span><br><span class="hljs-comment">    最后判断 (i + 1) != nums[i]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 将[1, n]映射到[0, n - 1]上</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 原地哈希</span><br>        <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">int</span> t = nums[i];<br>            nums[i] = nums[t - <span class="hljs-number">1</span>];<br>            nums[t - <span class="hljs-number">1</span>] = t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原地哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0040_组合总和ii</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0040_%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0040_%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii/</url>
    
    <content type="html"><![CDATA[<h4 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    核心点：</span><br><span class="hljs-comment">        (1) 只能选一次，下一层从i+1开始</span><br><span class="hljs-comment">        (2) 去重。if (i &gt; index &amp;&amp; nums[i] == nums[i-1])    continue;</span><br><span class="hljs-comment">*/</span><br><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>    Arrays.sort(candidates);<br><br>    List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    dfs(candidates, <span class="hljs-number">0</span>, target, arr);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> target, List&lt;Integer&gt; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>)<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(arr));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; candidates[i])<br>            <span class="hljs-keyword">break</span>;<br>        <br>        <span class="hljs-comment">// 去重</span><br>        <span class="hljs-keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br><br>        target -= candidates[i];<br>        arr.add(candidates[i]);<br><br>        dfs(candidates, i + <span class="hljs-number">1</span>, target, arr);<br><br>        target += candidates[i];<br>        arr.remove(arr.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0039_组合总和</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0039_%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0039_%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">给定一个无重复元素的数组 candidates 和一个目标数 <span class="hljs-keyword">target</span> ，找出 candidates 中所有可以使数字和为 <span class="hljs-keyword">target</span> 的组合。<br><br>candidates 中的数字可以无限制重复被选取。<br><br>说明：<br><br>所有数字（包括 <span class="hljs-keyword">target</span>）都是正整数。<br>解集不能包含重复的组合。 <br>示例 <span class="hljs-number">1</span>：<br><br>输入：candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">7</span>,<br>所求解集为：<br>[<br>  [<span class="hljs-number">7</span>],<br>  [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>]<br></code></pre></td></tr></table></figure><h4 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    组合的思想：由于可以重复取，因此下一层依然从第i个出发</span><br><span class="hljs-comment">*/</span><br><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> n = candidates.length;<br><br>    <span class="hljs-comment">// 排序是剪枝的前提</span><br>    Arrays.sort(candidates);<br>    List&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    dfs(candidates, <span class="hljs-number">0</span>, target, arr);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> target, List&lt;Integer&gt; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>)    res.add(<span class="hljs-keyword">new</span> ArrayList(arr));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 选择列表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i &lt; candidates.length; i++) &#123;<br>        <span class="hljs-comment">// 剪枝：因为是sort过的，后面的只会越来越大</span><br>        <span class="hljs-keyword">if</span> (candidates[i] &gt; target)<br>            <span class="hljs-keyword">return</span>;<br>        <br>        target -= candidates[i];<br>        arr.add(candidates[i]);<br><br>        <span class="hljs-comment">// 因为可以重复选取，继续从i开始</span><br>        dfs(candidates, i, target, arr);<br><br>        arr.remove(arr.size() - <span class="hljs-number">1</span>);<br>        target += candidates[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0038_外观数列</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0038_%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0038_%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">给定一个正整数 n ，输出外观数列的第 n 项。<br><br>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。<br><br>前五项如下：<br><br><span class="hljs-bullet">1.</span>     1<br><span class="hljs-bullet">2.</span>     11<br><span class="hljs-bullet">3.</span>     21<br><span class="hljs-bullet">4.</span>     1211<br><span class="hljs-bullet">5.</span>     111221<br></code></pre></td></tr></table></figure><h4 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    双指针统计连续相同的区间，组成 k个n 的形式</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;1&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        StringBuilder t = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span> cnt = sb.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sb.length(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (sb.charAt(j) == cnt)<br>                k++;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.append(k + <span class="hljs-string">&quot;&quot;</span> + cnt);<br>                k = <span class="hljs-number">1</span>;<br>                cnt = sb.charAt(j);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理最后一个</span><br>        t.append(k + <span class="hljs-string">&quot;&quot;</span> + cnt);<br>        <br>        sb = t;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0037_解数独</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0037_%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0037_%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">编写一个程序，通过填充空格来解决数独问题。<br><br>一个数独的解法需遵循如下规则：<br><br>数字 1<span class="hljs-string">-9</span> 在每一行只能出现一次。<br>数字 1<span class="hljs-string">-9</span> 在每一列只能出现一次。<br>数字 1<span class="hljs-string">-9</span> 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 &#x27;.&#x27; 表示。<br></code></pre></td></tr></table></figure><h4 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span>[][] row = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-keyword">boolean</span>[][] col = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-keyword">boolean</span>[][][] cell = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-keyword">int</span> t = board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                row[i][t] = <span class="hljs-keyword">true</span>;<br>                col[j][t] = <span class="hljs-keyword">true</span>;<br>                cell[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][t] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    backtrack(board, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">9</span>) &#123;<br>        j = <span class="hljs-number">0</span>;<br>        i ++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">9</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)<br>        <span class="hljs-keyword">return</span> backtrack(board, i, j + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>; n &lt;= <span class="hljs-number">9</span>; ++n) &#123;<br>            <span class="hljs-keyword">if</span> (!row[i][n] &amp;&amp; !col[j][n] &amp;&amp; !cell[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][n]) &#123;<br>                board[i][j] = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;0&#x27;</span> + n);<br>                row[i][n] = col[j][n] = cell[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][n] = <span class="hljs-keyword">true</span>;<br><br>                <span class="hljs-comment">// 找到一种可能就直接返回</span><br>                <span class="hljs-keyword">if</span> (backtrack(board, i, j + <span class="hljs-number">1</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>                board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                row[i][n] = col[j][n] = cell[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][n] = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0036_有效的数独</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0036_%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0036_%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。<br><br>数字 1<span class="hljs-string">-9</span> 在每一行只能出现一次。<br>数字 1<span class="hljs-string">-9</span> 在每一列只能出现一次。<br>数字 1<span class="hljs-string">-9</span> 在每一个以粗实线分隔的 3x3 宫内只能出现一次<br></code></pre></td></tr></table></figure><h4 id="方法1：搜索"><a href="#方法1：搜索" class="headerlink" title="方法1：搜索"></a>方法1：搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    rd[i][t]: 第i行是否出现过数字t</span><br><span class="hljs-comment">    cd[j][t]: 第j行是否出现过数字t</span><br><span class="hljs-comment">    cell[i/3][j/3][t]: 第[i/3][j/3]的小方格是否出现过数字t</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">boolean</span>[][] rd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-keyword">boolean</span>[][] cd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br><span class="hljs-keyword">boolean</span>[][][] cell = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = board.length;<br>    <span class="hljs-keyword">int</span> col = board[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-keyword">int</span> t = board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>                <span class="hljs-keyword">if</span> (rd[i][t] == <span class="hljs-keyword">true</span> || cd[j][t] == <span class="hljs-keyword">true</span> || cell[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][t] == <span class="hljs-keyword">true</span>)    <br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>                rd[i][t] = cd[j][t] = cell[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][t] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0035_搜索插入位置</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0035_%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0035_%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    寻找 &lt; x 的右边界r, [r + 1, n - 1]后移一位，插入到 r + 1.</span><br><span class="hljs-comment">    如果所有元素 &gt;= target, 则插入到 r</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br><br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有元素都 &gt; target, 则插入到r</span><br>    <span class="hljs-keyword">if</span> (nums[r] &gt;= target)<br>        <span class="hljs-keyword">return</span> r;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0034_搜索元素的第一个和最后一个位置</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0034_%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0034_%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fortran">给定一个按照升序排列的整数数组 nums，和一个目标值 <span class="hljs-keyword">target</span>。找出给定目标值在数组中的开始位置和结束位置。<br><br>如果数组中不存在目标值 <span class="hljs-keyword">target</span>，返回 [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]。<br><br>进阶：你可以设计并实现时间复杂度为 O(<span class="hljs-built_in">log</span> n) 的算法解决此问题吗？<br> <br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">8</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h4 id="方法1：二分"><a href="#方法1：二分" class="headerlink" title="方法1：二分"></a>方法1：二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-comment">// 寻找 &lt;= target 的右边界</span><br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nums[l] != target)  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-comment">// 最后一个位置依然用二分，这里为了偷懒使用了线性扫描</span><br>    <span class="hljs-keyword">int</span> index = r;<br>    <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index] == target)<br>        index--;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;index + <span class="hljs-number">1</span>, r&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0033_搜索旋转排序数组</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0033_%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0033_%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">给你 旋转后 的数组 nums 和一个整数 <span class="hljs-keyword">target</span> ，如果 nums 中存在这个目标值 <span class="hljs-keyword">target</span> ，则返回它的索引，否则返回 <span class="hljs-number">-1</span> 。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="方法1：二分"><a href="#方法1：二分" class="headerlink" title="方法1：二分"></a>方法1：二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    (1) 二分法寻找 &gt;= nums[0] 的右边界r</span><br><span class="hljs-comment">    (2) 若target &gt;= nums[0], 则在区间[0, r]二分查找</span><br><span class="hljs-comment">    (3) 否则在[r + 1, n - 1] 二分查找</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到 &gt;= nums[0] 的右边界</span><br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[<span class="hljs-number">0</span>])<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (target &gt;= nums[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> find(nums, <span class="hljs-number">0</span>, l, target);<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> find(nums, l + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, target);<br><br>&#125;<br><br><span class="hljs-comment">// 二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target)    <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) l++;<br>        <span class="hljs-keyword">else</span>    r--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0032_最长有效括号</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0032_%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0032_%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">给你一个只包含 &#x27;(&#x27; 和 &#x27;)&#x27; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：s = <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长有效括号的长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(s[i] == &#x27;(&#x27; || s[i] == &#x27;)&#x27;)</span><br><span class="hljs-comment">             如果s[i] == &#x27;(&#x27;, 则dp[i] = 0;</span><br><span class="hljs-comment">             如果s[i] == &#x27;)&#x27;, 则观察 index = i - dp[i-1] - 1 的位置是否为&#x27;(&#x27;, 若不是则为0, 若是则dp[i] = dp[i-1] + 2. 并且若dp[index - 1] &gt; 0, 则进行累加。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];  <span class="hljs-comment">// 以下标i结尾的最长有效括号</span><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 只有遇到 &#x27;)&#x27; 才会进行判断</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 前一个有效括号的长度</span><br>            <span class="hljs-keyword">int</span> len = dp[i - <span class="hljs-number">1</span>];<br><br>            <span class="hljs-comment">// 判断 len - 1 的位置合法且为 &#x27;(&#x27;</span><br>            <span class="hljs-keyword">int</span> index = i - len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(index) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br><br>                <span class="hljs-comment">// 同时还要判断 dp[index - 1] 是否存在</span><br>                <span class="hljs-keyword">if</span> (index - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[index - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)<br>                    dp[i] += dp[index - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        xMax = Math.max(xMax, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0031_下一个排列</title>
    <link href="/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0031_%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2021/03/26/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0031_%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br><br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br><br>必须 原地 修改，只允许使用额外常数空间。<br><br>示例 1：<br><br>输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    (1) 从后向前寻找第一个升序对(i, j)</span><br><span class="hljs-comment">    (2) 如果没找到, 则说明整个数组降序，直接逆转返回即可。</span><br><span class="hljs-comment">    (3) 否则，在区间[j, n - 1]寻找第一个大于nums[i]的数k</span><br><span class="hljs-comment">    (4) 交换nums[i] 和 nums[k]</span><br><span class="hljs-comment">    (5) 逆转[j, n - 1]区间</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br><br>    <span class="hljs-comment">// 1、从后向前找第一个严格升序对</span><br>    <span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>, j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>        i--;<br>        j--;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果整个数组降序，则翻转即可</span><br>    <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span>) &#123;<br>        reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// [j, n - 1] 寻找第一个大于nums[i]的数</span><br>    <span class="hljs-keyword">int</span> k = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &gt;= j &amp;&amp; nums[k] &lt;= nums[i])<br>        k--;<br>    <br>    <span class="hljs-comment">// 交换nums[i]和nums[k]</span><br>    <span class="hljs-keyword">int</span> t = nums[k];<br>    nums[k] = nums[i];<br>    nums[i] = t;<br><br>    <span class="hljs-comment">// 翻转[j, n - 1]</span><br>    reverse(nums, j, n - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> t = nums[l];<br>        nums[l] = nums[r];<br>        nums[r] = t;<br><br>        l++;<br>        r--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0029_两数相除</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0029_%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0029_%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br><br>示例 1:<br><br><span class="hljs-section">输入: dividend = 10, divisor = 3</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</span><br></code></pre></td></tr></table></figure><h4 id="方法1：倍增思想"><a href="#方法1：倍增思想" class="headerlink" title="方法1：倍增思想"></a>方法1：倍增思想</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    考虑暴力情况: a不断的减去b直到小于b, 此时减的次数就是商。但是这样复杂度太高：比如 a = 2^31 - 1, b = 1。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    因此考虑 a - 2^k * b, 如果 a &gt;= 2^k * b , 则说明商的第k位为1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dividend, <span class="hljs-keyword">int</span> divisor)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> ((dividend &gt; <span class="hljs-number">0</span> &amp;&amp; divisor &lt; <span class="hljs-number">0</span>) || (dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &gt; <span class="hljs-number">0</span>))<br>        flag = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">long</span> x = Math.abs((<span class="hljs-keyword">long</span>)dividend);<br>    <span class="hljs-keyword">long</span> y = Math.abs((<span class="hljs-keyword">long</span>)divisor);<br><br>    <span class="hljs-comment">// 保存2^i * y</span><br>    <span class="hljs-keyword">long</span>[] exp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">32</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = y; i &lt;= x; i += i)<br>        exp[k++] = i;<br><br>    <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 从最高位开始比较</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">if</span> (x &gt;= exp[i]) &#123;<br>            x -= exp[i];<br>            res += <span class="hljs-number">1L</span> &lt;&lt; i;     <span class="hljs-comment">// 这里1必须是long类型的, 防止溢出。</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!flag)  res = -res;<br>    <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE)<br>        res = Integer.MAX_VALUE;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>位运算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0028_实现Strstr()</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0028_%E5%AE%9E%E7%8E%B0Strstr()/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0028_%E5%AE%9E%E7%8E%B0Strstr()/</url>
    
    <content type="html"><![CDATA[<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">核心要点：next[i]表示以 <span class="hljs-number">1</span>开头的前缀 和 以i结尾的后缀 相等的子串的最大长度。<br>         因此当 <span class="hljs-keyword">j </span>&gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != p[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] 的时候 <span class="hljs-keyword">j </span>退回到 next[<span class="hljs-keyword">j] </span>处，相等则<span class="hljs-keyword">j++。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword"> </span>        为什么 <span class="hljs-keyword">j </span>&gt; <span class="hljs-number">0</span> ? 因为 <span class="hljs-keyword">j </span>== <span class="hljs-number">0</span> 的时候处于起点位置，已经退无可退了。<br>         <br><br>如何构建next[]? <br>    p 匹配 p, 但是需要非平凡子串，因此 i从<span class="hljs-number">2</span> 开始。<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String haystack, String needle)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (needle.length() == <span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> n = haystack.length();<br>    <span class="hljs-keyword">int</span> m = needle.length();<br><br>    String s = <span class="hljs-string">&quot; &quot;</span> + haystack;<br>    String p = <span class="hljs-string">&quot; &quot;</span> + needle;<br><br>    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 构建next[]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; p.charAt(i) != p.charAt(j + <span class="hljs-number">1</span>))<br>            j = next[j];<br>        <br>        <span class="hljs-keyword">if</span> (p.charAt(i) == p.charAt(j + <span class="hljs-number">1</span>))<br>            j++;<br>        <br>        <span class="hljs-comment">// 走到这一步说明 p[i] == p[j + 1], 则j++之后，next[i] = j;</span><br>        next[i] = j;<br>    &#125;<br><br>    <span class="hljs-comment">// 已经获得了next[]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != p.charAt(j + <span class="hljs-number">1</span>))<br>            j = next[j];<br>        <br>        <span class="hljs-keyword">if</span> (s.charAt(i) == p.charAt(j + <span class="hljs-number">1</span>))<br>            j++;<br>        <br>        <span class="hljs-keyword">if</span> (j == m)<br>            <span class="hljs-keyword">return</span> i - m;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0030_串联所有单词的子串</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0030_%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0030_%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs applescript">给定一个字符串 s 和一些长度相同的单词 <span class="hljs-built_in">words</span>。找出 s 中恰好可以由 <span class="hljs-built_in">words</span> 中所有单词串联形成的子串的起始位置。<br><br>注意子串要与 <span class="hljs-built_in">words</span> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <span class="hljs-built_in">words</span> 中单词串联的顺序。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<br>  s = <span class="hljs-string">&quot;barfoothefoobarman&quot;</span>,<br>  <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h4 id="方法1：滑动窗口"><a href="#方法1：滑动窗口" class="headerlink" title="方法1：滑动窗口"></a>方法1：滑动窗口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    由于必须用到words中的所有单词，所以窗口大小是固定的。</span><br><span class="hljs-comment">    在s中分别枚举长度为w的子串，同时选择开头范围为[0, w - 1]来保证所有子串均可遍历到。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    判断集合相等：利用两个哈希表，分别记录窗口内集合与words集合，相等的时候就是符合条件的时候。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    窗口边界控制：在加入新单词之前需要将超过窗口的单词踢掉，具体为 j &gt;= i + m * w; 其中i为起点， m * w 为长度，当窗口满的时候 下标应该为 i + m * w - 1; 踢掉之后，新起点的下标为 i + (m - 1) * w;</span><br><span class="hljs-comment">*/</span><br><br>List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(String s, String[] words)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (words.length == <span class="hljs-number">0</span> || s.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res;<br><br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = words.length;<br>    <span class="hljs-keyword">int</span> w = words[<span class="hljs-number">0</span>].length();<br><br>    <span class="hljs-comment">// 滑动窗口 + 哈希表(判断集合)</span><br>    HashMap&lt;String, Integer&gt; m1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 记录words集合</span><br>    <span class="hljs-keyword">for</span> (String x : words) &#123;<br>        m1.put(x, m1.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 枚举可能开头的索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        HashMap&lt;String, Integer&gt; m2 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j + w &lt;= n; j += w) &#123;<br>            <span class="hljs-comment">// 先判断窗口是否满了</span><br>            <span class="hljs-keyword">if</span> (j &gt;= i + m * w) &#123;<br>                String sub = s.substring(j - m * w, j - (m - <span class="hljs-number">1</span>) * w);<br>                m2.put(sub, m2.get(sub) - <span class="hljs-number">1</span>);<br><br>                <span class="hljs-keyword">if</span> (m1.containsKey(sub) &amp;&amp; m2.get(sub) &lt; m1.get(sub))<br>                    cnt--;<br>            &#125;<br><br>            <span class="hljs-comment">// 加入窗口</span><br>            String newWord = s.substring(j, j + w);<br>            m2.put(newWord, m2.getOrDefault(newWord, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (m1.containsKey(newWord) &amp;&amp; m2.get(newWord) &lt;= m1.get(newWord))<br>                cnt++;<br>            <br>            <span class="hljs-keyword">if</span> (cnt == m)<br>                res.add(j - (m - <span class="hljs-number">1</span>) * w);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0027_移除元素</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0027_%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0027_%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">给你一个数组 nums 和一个值 <span class="hljs-keyword">val</span>，你需要 原地 移除所有数值等于 <span class="hljs-keyword">val</span> 的元素，并返回移除后数组的新长度。<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == val) &#123;<br>            k++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        nums[i - k] = nums[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums.length - k;<br>&#125;   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0026_删除有序数组中的重复项</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0026_%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0026_%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用向前覆盖的思想。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录重复元素的个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>            k++;<br>        <span class="hljs-keyword">else</span><br>            nums[i - k] = nums[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums.length - k;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0025_K个一组翻转链表</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0025_K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0025_K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], k = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h4 id="方法1：栈"><a href="#方法1：栈" class="headerlink" title="方法1：栈"></a>方法1：栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    准备一个容量为K的栈，满了则尾插，没满则说明是最后几个则进行头插。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 用一个大小为k的栈来进行翻转</span><br>    ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    ListNode curNode = dummyNode;<br>    Stack&lt;ListNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 压入k个进栈</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            ListNode post = head.next;<br>            head.next = <span class="hljs-keyword">null</span>;<br><br>            st.push(head);<br>            <br>            <span class="hljs-comment">// 如果不足k个则退出</span><br>            head = post;<br>            <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">break</span>;   <br>        &#125;<br><br>        <span class="hljs-comment">// 进行尾插</span><br>        <span class="hljs-keyword">if</span> (st.size() == k) &#123;<br>            <span class="hljs-keyword">while</span> (!st.isEmpty()) &#123;<br>                curNode.next = st.pop();<br>                curNode = curNode.next;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 如果不足k个则进行头插到curNode后面</span><br>            <span class="hljs-keyword">while</span> (!st.isEmpty()) &#123;<br>                ListNode t = st.pop();<br>                t.next = curNode.next;<br>                curNode.next = t;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2：模拟"><a href="#方法2：模拟" class="headerlink" title="方法2：模拟"></a>方法2：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    先向后遍历是否有K个，没有则直接退出，否则进行K - 1次头插</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    dummyNode.next = head;<br><br>    ListNode curNode = dummyNode;<br><br>    <span class="hljs-keyword">while</span> (curNode != <span class="hljs-keyword">null</span>) &#123;<br>        ListNode q = curNode;<br>        <span class="hljs-comment">// 查看后续节点是否还有k个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; q != <span class="hljs-keyword">null</span>; i++)<br>            q = q.next;<br>        <br>        <span class="hljs-comment">// 不足k个直接返回</span><br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <br>        <span class="hljs-comment">// 有k个, 则头插k-1次</span><br>        ListNode tail = curNode.next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k - <span class="hljs-number">1</span>; j++) &#123;<br>            ListNode t = tail.next;<br><br>            tail.next = t.next;<br>            t.next = curNode.next;<br>            curNode.next = t;<br>        &#125;<br><br>        curNode = tail;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0024_两两交换链表中的节点</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0024_%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0024_%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br><br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    两两交换则必须要求至少有两个节点。</span><br><span class="hljs-comment">    因此 curNode.next != null &amp;&amp; curNode.next.next != null</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    交换逻辑:</span><br><span class="hljs-comment">        firstNode = curNode.next;           记录第一个节点</span><br><span class="hljs-comment">        secondNode = curNode.next.next;     记录第二个节点</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        ListNode ne = secondNode.next;      记录第二个节点的后继节点</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        secondNode.next = curNode.next;     第二个节点后继指向curNode.next</span><br><span class="hljs-comment">        firstNode.next = ne;                第一个节点后继指向ne</span><br><span class="hljs-comment">        curNode.next = secondNode;          curNode后继指向第二个节点</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        curNode = firstNode;                更新curNode节点</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> head;<br>    <br>    ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    dummyNode.next = head;<br>    ListNode curNode = dummyNode;<br><br>    ListNode firstNode;<br>    ListNode secondNode;<br><br>    <span class="hljs-keyword">while</span> (curNode.next != <span class="hljs-keyword">null</span> &amp;&amp; curNode.next.next != <span class="hljs-keyword">null</span>) &#123;<br>        firstNode = curNode.next;<br>        secondNode = curNode.next.next;<br>        <br>        ListNode ne = secondNode.next;<br><br>        secondNode.next = curNode.next;<br>        firstNode.next = ne;<br>        curNode.next = secondNode;<br><br>        curNode = firstNode;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0023_合并K个有序链表</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0023_%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0023_%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给你一个链表数组，每个链表都已经按升序排列。<br><br>请你将所有链表合并到一个升序链表中，返回合并后的链表。<br><br>示例 1：<br><br>输入：lists = <span class="hljs-comment">[<span class="hljs-comment">[1,4,5]</span>,<span class="hljs-comment">[1,3,4]</span>,<span class="hljs-comment">[2,6]</span>]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4,5,6]</span><br></code></pre></td></tr></table></figure><h4 id="方法1：优先队列"><a href="#方法1：优先队列" class="headerlink" title="方法1：优先队列"></a>方法1：优先队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    建立优先队列，将每个非空链表加入到小顶堆中。</span><br><span class="hljs-comment">    每次弹出堆顶，并将下一个非空节点加入到堆中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>    ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    ListNode curNode = dummyNode;<br><br>    PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.val - o2.val);<br>    <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)<br>            pq.offer(node);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>        ListNode t = pq.poll();<br>        ListNode ne = t.next;<br>        curNode.next = t;<br>        curNode = curNode.next;<br><br>        <span class="hljs-keyword">if</span> (ne != <span class="hljs-keyword">null</span>) pq.offer(ne);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先队列</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0022_括号生成</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0022_%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0022_%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">数字 <span class="hljs-built_in">n</span> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    一个合法的括号序列：任意前缀中左括号的数量 &gt;= 右括号的数量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    回溯法：</span><br><span class="hljs-comment">        递归出口: 左括号用完 &amp;&amp; 右括号用完</span><br><span class="hljs-comment">        选择列表：左括号 || 右括号</span><br><span class="hljs-comment">        剪枝：如果左括号剩余数量 &gt; 右括号剩余数量则不满足</span><br><span class="hljs-comment">*/</span><br><br>List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    dfs(n, n, sb);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, StringBuilder sb)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>        res.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 始终保证 左括号剩余数量 &lt;= 右括号剩余数量</span><br>    <span class="hljs-keyword">if</span> (left &gt; right)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>        sb.append(<span class="hljs-string">&quot;(&quot;</span>);<br>        dfs(left - <span class="hljs-number">1</span>, right, sb);<br>        sb.setLength(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span>) &#123;<br>        sb.append(<span class="hljs-string">&quot;)&quot;</span>);<br>        dfs(left, right - <span class="hljs-number">1</span>, sb);<br>        sb.setLength(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>括号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0021_合并两个有序链表</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0021_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0021-0040/LC0021_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>    ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    ListNode curNode = dummyNode;<br><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>            curNode.next = l1;<br>            l1 = l1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            curNode.next = l2;<br>            l2 = l2.next;<br>        &#125;<br><br>        curNode = curNode.next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) curNode.next = l1;<br>    <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) curNode.next = l2;<br><br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS</title>
    <link href="/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/"/>
    <url>/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>DNS提供的服务：提供主机名到IP地址的解析功能。</li><li>DNS协议运行于UDP协议之上，使用53号端口。</li></ul></blockquote><h3 id="DNS工作步骤"><a href="#DNS工作步骤" class="headerlink" title="DNS工作步骤"></a>DNS工作步骤</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) 用户输入网址，浏览器首先检查是否有主机名到IP地址的映射缓存<br>(<span class="hljs-number">2</span>) 没有就检查本地host文件看是否有<br>(<span class="hljs-number">3</span>) 没有就询问本地DNS服务器<br>(<span class="hljs-number">4</span>) 本地DNS服务器没有的话，就会询问根DNS服务器<br>(<span class="hljs-number">5</span>) 根DNS服务器返回顶级域服务器地址，本地DNS服务器接着询问顶级域服务器<br>(<span class="hljs-number">6</span>) 顶级域服务器返回权威DNS服务器地址，本地DNS服务器接着询问权威DNS服务器地址。<br>(<span class="hljs-number">7</span>) 权威DNS服务器返回IP地址返回给本地DNS服务器。<br>(<span class="hljs-number">8</span>) 本地DNS服务器将结果返回给主机。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP(%E9%87%8D%E8%A6%81)/"/>
    <url>/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP(%E9%87%8D%E8%A6%81)/</url>
    
    <content type="html"><![CDATA[<h3 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h3><blockquote><ul><li>HTTP(超文本传输协议)是web应用所使用的协议</li><li>HTTP使用TCP作为它的支撑运输的协议</li><li>HTTP是无状态的协议</li></ul></blockquote><h3 id="非持续连接-vs-持续连接"><a href="#非持续连接-vs-持续连接" class="headerlink" title="非持续连接 vs 持续连接"></a>非持续连接 vs 持续连接</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">非持续连接：每一个请求/响应对都是经过单独的TCP连接。<br>持续连接：所有的请求/响应对都是经过同一个TCP连接。<br><br>比如：客户端向服务端发送一个HTTP请求，假设该请求页面包含<span class="hljs-number">1</span>个<span class="hljs-selector-tag">HTML</span>页面和<span class="hljs-number">10</span>个JPEG图片，那么采用非持续连接就需要建立<span class="hljs-number">11</span>次TCP连接，而采用持续连接仅需要一个TCP连接。<br></code></pre></td></tr></table></figure><h3 id="HTTP请求格式和响应格式"><a href="#HTTP请求格式和响应格式" class="headerlink" title="HTTP请求格式和响应格式"></a>HTTP请求格式和响应格式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">请求报文:<br><span class="hljs-code">    请求行：</span><br><span class="hljs-code">        方法 URL 版本</span><br><span class="hljs-code"></span><br><span class="hljs-code">    首部行: </span><br><span class="hljs-code">        host</span><br><span class="hljs-code">        Connection</span><br><span class="hljs-code">        ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    实体：</span><br><span class="hljs-code"></span><br><span class="hljs-code">响应报文：</span><br><span class="hljs-code">    状态行:</span><br><span class="hljs-code">        版本 状态码 短语</span><br><span class="hljs-code"></span><br><span class="hljs-code">    首部行：</span><br><span class="hljs-code">        Connection</span><br><span class="hljs-code">        Date</span><br><span class="hljs-code">        Last-Modified</span><br><span class="hljs-code">        Content-Length</span><br><span class="hljs-code">        Content-Type</span><br><span class="hljs-code">        ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    实体：</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h3 id="HTTP常见的状态码和含义"><a href="#HTTP常见的状态码和含义" class="headerlink" title="HTTP常见的状态码和含义"></a>HTTP常见的状态码和含义</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">200</span>: 成功<br><span class="hljs-number">204</span>：与<span class="hljs-number">200</span>相同，响应头没有body数据<br><span class="hljs-number">206</span>：是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。<br><br><span class="hljs-number">301</span>:表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。<br><span class="hljs-number">302</span>：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br><span class="hljs-symbol">301 </span>和 <span class="hljs-number">302</span> 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。<br><br><span class="hljs-number">400</span>:表示客户端请求的报文有错误<br><span class="hljs-number">403</span>:表示服务器禁止访问资源<br><span class="hljs-number">404</span>:资源未找到<br><br><span class="hljs-number">500</span>:与 <span class="hljs-number">400</span> 类型，是个笼统通用的错误码<br><span class="hljs-number">503</span>:表示服务器当前很忙，暂时无法响应服务器<br></code></pre></td></tr></table></figure><h3 id="Get-和-Post-的区别"><a href="#Get-和-Post-的区别" class="headerlink" title="Get 和 Post 的区别"></a>Get 和 Post 的区别</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Get:向服务器获取资源; Post向指定的URI提交数据，数据保存在<span class="hljs-selector-tag">body</span>中。<br>Get:是安全且幂等的; Post不是安全也不是幂等的。<br><br>安全性：请求方法不会「破坏」服务器上的资源。<br>幂等性: 多次执行相同的操作，结果都是「相同」的。<br></code></pre></td></tr></table></figure><h3 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">由于HTTP是无状态协议，如果想要保存用户的状态信息，则出现了Cookie机制和<span class="hljs-keyword">Session</span>机制。<br><br>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，获取状态信息。<br><br>然后Cookie需要保存的信息比较多，比如<span class="hljs-type">name</span>，<span class="hljs-keyword">value</span>，maxAge等。如果HTTP请求每次都需要携带Cookie完整信息，那么增加了客户端与服务端的数据传输量。因此就出现了<span class="hljs-keyword">Session</span>机制，同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 SessionID。<br><br><span class="hljs-keyword">Session</span>是一种服务端的机制，用户信息保存在服务器端，服务端为每一个客户创建<span class="hljs-keyword">Session</span>并利用SessionID进行关联。<br></code></pre></td></tr></table></figure><h3 id="HTTP-和-HTTPS-有哪些区别？"><a href="#HTTP-和-HTTPS-有哪些区别？" class="headerlink" title="HTTP 和 HTTPS 有哪些区别？"></a>HTTP 和 HTTPS 有哪些区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0020_有效的括号</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0020_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0020_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Stack&lt;Character&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(i);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>            st.push(c);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> ((c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !st.isEmpty() &amp;&amp; st.peek() == <span class="hljs-string">&#x27;(&#x27;</span>) ||<br>                (c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; !st.isEmpty() &amp;&amp; st.peek() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) ||<br>                (c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; !st.isEmpty() &amp;&amp; st.peek() == <span class="hljs-string">&#x27;[&#x27;</span>))<br>                st.pop();<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st.isEmpty())   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>括号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0019_删除链表的倒数第N个节点</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0019_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0019_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">给你一个链表，删除链表的倒数第 <span class="hljs-built_in">n</span> 个结点，并且返回链表的头结点。<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    dummyNode.next = head;<br>    ListNode curNode = dummyNode;<br><br>    ListNode fastNode = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        fastNode = fastNode.next;<br>    <br>    <span class="hljs-keyword">while</span> (fastNode != <span class="hljs-keyword">null</span>) &#123;<br>        curNode = curNode.next;<br>        fastNode = fastNode.next;<br>    &#125;<br><br>    curNode.next = curNode.next.next;<br><br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0018_四数之和</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0018_%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0018_%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br><br>注意：答案中不可以包含重复的四元组。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：nums = <span class="hljs-selector-attr">[1,0,-1,0,-2,2]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-selector-attr">[[-2,-1,1,2]</span>,<span class="hljs-selector-attr">[-2,0,0,2]</span>,<span class="hljs-selector-attr">[-1,0,0,1]</span>]<br></code></pre></td></tr></table></figure><h4 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">4</span>)    <span class="hljs-keyword">return</span> res;<br>    Arrays.sort(nums);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>        <br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])   <br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">int</span> l = j + <span class="hljs-number">1</span>, r = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-keyword">int</span> sum = nums[i] + nums[j] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                    res.add(<span class="hljs-keyword">new</span> ArrayList(Arrays.asList(nums[i], nums[j], nums[l], nums[r])));<br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++l]);<br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[--r]);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++l]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[--r]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0017_电话号码的字母组合</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0017_%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0017_%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">给定一个仅包含数字 <span class="hljs-number">2</span>-<span class="hljs-number">9</span> 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dfs(String s, int index, StringBuilder sb);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    递归出口：index == s.length();</span><br><span class="hljs-comment">    选择列表：s.charAt(index)对应的字符集</span><br><span class="hljs-comment">    下一层：dfs(s, index + 1, sb)</span><br><span class="hljs-comment">*/</span><br><br>String[] str = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> res;<br><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    dfs(digits, <span class="hljs-number">0</span>, sb);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String digits, <span class="hljs-keyword">int</span> index, StringBuilder sb)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>        res.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> t = digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    String choose = str[t];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; choose.length(); i++) &#123;<br>        <span class="hljs-keyword">char</span> c = choose.charAt(i);<br>        sb.append(c);<br><br>        dfs(digits, index + <span class="hljs-number">1</span>, sb);<br><br>        sb.setLength(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0016_最接近的三数之和</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0016_%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0016_%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">int</span> xMin = Integer.MAX_VALUE; <span class="hljs-comment">// 记录与target的最小差距</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录最小差距时的和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> l = i + <span class="hljs-number">1</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> sum = nums[i] + nums[l] + nums[r];<br><br>            <span class="hljs-keyword">if</span> (Math.abs(sum - target) &lt; xMin) &#123;<br>                res = sum;<br>                xMin = Math.abs(sum - target);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (sum == target)  <span class="hljs-keyword">return</span> target;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)<br>                r--;<br>            <span class="hljs-keyword">else</span><br>                l++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0015_三数之和</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0015_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0015_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br><br>注意：答案中不可以包含重复的三元组。<br><br>示例 1：<br><br>输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]<br>输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]<br></code></pre></td></tr></table></figure><h4 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    先排序，最外层枚举每个起点。内层利用双指针枚举[i + 1, n - 1]范围内的两两组合。如果 &gt; target, 则移动右指针，如果 &lt; target, 则移动左指针</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    如果去重？</span><br><span class="hljs-comment">        最外层的起点：if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])  continue;   // 起点不能重复</span><br><span class="hljs-comment">        内部的双指针：</span><br><span class="hljs-comment">            while (j &lt; k &amp;&amp; nums[j] == nums[++j]);</span><br><span class="hljs-comment">            while (j &lt; k &amp;&amp; nums[k] == nums[--k]);</span><br><span class="hljs-comment">*/</span><br><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    <br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">break</span>;<br>        <br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-keyword">int</span> l = i + <span class="hljs-number">1</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[l] + nums[r] == <span class="hljs-number">0</span>) &#123;<br>                res.add(Arrays.asList(nums[i], nums[l], nums[r]));<br>                <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++l]);<br>                <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[--r]);<br>            &#125; <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[l] + nums[r] &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++l]);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[--r]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0014_最长公共前缀</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0014_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0014_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    核心思想：挨个进行比较</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String ans = strs[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; j&lt; ans.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;<br>            <span class="hljs-keyword">if</span>(ans.charAt(j) != strs[i].charAt(j))<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ans = ans.substring(<span class="hljs-number">0</span>, j);<br>        <span class="hljs-keyword">if</span>(ans.equals(<span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0013_罗马数字转整数</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0013_%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0013_%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">将罗马数字转换为整数<br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    当遇到nums[i+1] &gt; nums[i], 则减去相应的数，否则不断累加</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    m.put(<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-number">1</span>);<br>    m.put(<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-number">5</span>);<br>    m.put(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">10</span>);<br>    m.put(<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-number">50</span>);<br>    m.put(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">100</span>);<br>    m.put(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-number">500</span>);<br>    m.put(<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1000</span>);<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">char</span> c1 = s.charAt(i);<br>        <span class="hljs-keyword">char</span> c2 = s.charAt(i + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span> (m.get(c1) &lt; m.get(c2))<br>            res -= m.get(c1);<br>        <span class="hljs-keyword">else</span><br>            res += m.get(c1);<br>    &#125;<br><br>    <span class="hljs-comment">// 累加最后一个字符对应的数字</span><br>    res += m.get(s.charAt(s.length() - <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0012_整数转罗马数字</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0012_%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0012_%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">罗马数字包含以下七种字符： <span class="hljs-built_in">I</span>， <span class="hljs-variable">V</span>， <span class="hljs-variable">X</span>， <span class="hljs-variable">L</span>，<span class="hljs-built_in">C</span>，<span class="hljs-built_in">D</span> 和 <span class="hljs-variable">M</span>。<br><br>字符          数值<br><span class="hljs-built_in">I</span>             <span class="hljs-number">1</span><br><span class="hljs-variable">V</span>             <span class="hljs-number">5</span><br><span class="hljs-variable">X</span>             <span class="hljs-number">10</span><br><span class="hljs-variable">L</span>             <span class="hljs-number">50</span><br><span class="hljs-built_in">C</span>             <span class="hljs-number">100</span><br><span class="hljs-built_in">D</span>             <span class="hljs-number">500</span><br><span class="hljs-variable">M</span>             <span class="hljs-number">1000</span><br><br><span class="hljs-built_in">I</span> 可以放在 <span class="hljs-variable">V</span> <span class="hljs-punctuation">(</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span> 和 <span class="hljs-variable">X</span> <span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-punctuation">)</span> 的左边，来表示 <span class="hljs-number">4</span> 和 <span class="hljs-number">9</span>。<br><span class="hljs-variable">X</span> 可以放在 <span class="hljs-variable">L</span> <span class="hljs-punctuation">(</span><span class="hljs-number">50</span><span class="hljs-punctuation">)</span> 和 <span class="hljs-built_in">C</span> <span class="hljs-punctuation">(</span><span class="hljs-number">100</span><span class="hljs-punctuation">)</span> 的左边，来表示 <span class="hljs-number">40</span> 和 <span class="hljs-number">90</span>。 <br><span class="hljs-built_in">C</span> 可以放在 <span class="hljs-built_in">D</span> <span class="hljs-punctuation">(</span><span class="hljs-number">500</span><span class="hljs-punctuation">)</span> 和 <span class="hljs-variable">M</span> <span class="hljs-punctuation">(</span><span class="hljs-number">1000</span><span class="hljs-punctuation">)</span> 的左边，来表示 <span class="hljs-number">400</span> 和 <span class="hljs-number">900</span>。<br><br>示例 <span class="hljs-number">1</span><span class="hljs-operator">:</span><br><br>输入<span class="hljs-operator">:</span> <span class="hljs-number">3</span><br>输出<span class="hljs-operator">:</span> <span class="hljs-string">&quot;III&quot;</span><br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    存储所有可能情况，从大到小进行转化。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    String[] s = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>, <span class="hljs-number">900</span>, <span class="hljs-number">1000</span>&#125;;<br><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">12</span>;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (num &gt;= nums[index]) &#123;<br>            sb.append(s[index]);<br>            num -= nums[index];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            index--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0011_盛最多水的容器</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0011_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0011_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (<span class="hljs-selector-tag">i</span>, ai) 。在坐标内画 n 条垂直线，垂直线 <span class="hljs-selector-tag">i</span> 的两个端点分别为 (<span class="hljs-selector-tag">i</span>, ai) 和 (<span class="hljs-selector-tag">i</span>, <span class="hljs-number">0</span>) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-selector-attr">[1,8,6,2,5,4,8,3,7]</span><br>输出：<span class="hljs-number">49</span> <br></code></pre></td></tr></table></figure><h4 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    初始指针i=0, j=n-1; 盛水容量：min(nums[i], nums[j]) * (j - i);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    移动哪个指针呢？显然移动的时候会导致宽度下降，因此只能提高短板才可能增加容量，因此移动较短的那个。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度:O(N)</span><br><span class="hljs-comment">    空间复杂度:O(1)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> sum = Math.min(height[l], height[r]) * (r - l);<br>        xMax = Math.max(xMax, sum);<br>        <br>        <span class="hljs-keyword">if</span> (height[l] &lt;= height[r])<br>            l++;<br>        <span class="hljs-keyword">else</span><br>            r--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0009_回文数</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0009_%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0009_%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm">给你一个整数 <span class="hljs-keyword">x</span> ，如果 <span class="hljs-keyword">x</span> 是一个回文整数，返回 <span class="hljs-keyword">true</span> ；否则，返回 <span class="hljs-keyword">false</span> 。<br><br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<span class="hljs-number">121</span> 是回文，而 <span class="hljs-number">123</span> 不是。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">121</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x &gt; <span class="hljs-number">0</span> &amp;&amp; x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (res &lt; x) &#123;<br>        res = res * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res == x || res / <span class="hljs-number">10</span> == x;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0008_字符串转整数</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0008_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0008_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">请你来实现一个 my<span class="hljs-constructor">Atoi(<span class="hljs-params">string</span> <span class="hljs-params">s</span>)</span> 函数，使其能将字符串转换成一个 <span class="hljs-number">32</span> 位有符号整数。<br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    步骤：</span><br><span class="hljs-comment">        1、trim()去除首尾空格</span><br><span class="hljs-comment">        2、判断正负</span><br><span class="hljs-comment">        3、首字符是符号位则跳过</span><br><span class="hljs-comment">        4、碰到数字字符进行累加(注意判断溢出)</span><br><span class="hljs-comment">        5、碰到非数字字符则直接返回res.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-comment">// 去除前后空白</span><br>    s = s.trim();<br>    <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 判断正负</span><br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        flag = -<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(i);<br><br>        <span class="hljs-comment">// 如果首位字符是符号则跳过</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>))<br>            <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-comment">// 如果出现任意非数字字符，则返回res</span><br>        <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <br>            <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span> || (res == Integer.MAX_VALUE / <span class="hljs-number">10</span> &amp;&amp; (c - <span class="hljs-string">&#x27;0&#x27;</span>) &gt; Integer.MAX_VALUE % <span class="hljs-number">10</span>)) &#123;<br>            <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>        &#125;<br>            <span class="hljs-keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span> || (res == Integer.MIN_VALUE / <span class="hljs-number">10</span> &amp;&amp; -(c - <span class="hljs-string">&#x27;0&#x27;</span>) &lt; (Integer.MIN_VALUE % <span class="hljs-number">10</span>))) &#123;<br>                <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>            &#125;<br><br>            res = res * <span class="hljs-number">10</span> + flag * (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0007_整数反转</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0007_%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0007_%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm">给你一个 <span class="hljs-number">32</span> 位的有符号整数 <span class="hljs-keyword">x</span> ，返回将 <span class="hljs-keyword">x</span> 中的数字部分反转后的结果。<br><br>如果反转后整数超过 <span class="hljs-number">32</span> 位的有符号整数的范围 [−<span class="hljs-number">231</span><span class="hljs-punctuation">,</span>  <span class="hljs-number">231</span> − <span class="hljs-number">1</span>] ，就返回 <span class="hljs-number">0</span>。<br><br>假设环境不允许存储 <span class="hljs-number">64</span> 位整数（有符号或无符号）。<br> <br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br>输出：<span class="hljs-number">321</span><br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用取余并不断乘10来进行翻转。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意溢出情况：</span><br><span class="hljs-comment">    res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; digit &gt; Integer.MAX_VALUE % 10)</span><br><span class="hljs-comment">    res &lt; Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; digit &lt; Integer.MIN_VALUE % 10)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <br>    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> digit = x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span> || (res == Integer.MAX_VALUE / <span class="hljs-number">10</span> &amp;&amp; digit &gt; Integer.MAX_VALUE % <span class="hljs-number">10</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span> || (res == Integer.MIN_VALUE / <span class="hljs-number">10</span> &amp;&amp; digit &lt; Integer.MIN_VALUE % <span class="hljs-number">10</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        res = res * <span class="hljs-number">10</span> + digit;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0006_Z字型变换</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0006_Z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0006_Z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tp">将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 <span class="hljs-keyword">Z</span> 字形排列。<br><br>比如输入字符串为 <span class="hljs-string">&quot;PAYPALISHIRING&quot;</span> 行数为 <span class="hljs-number">3</span> 时，排列如下：<br><br><span class="hljs-keyword">P</span>   A   H   N<br>A <span class="hljs-keyword">P</span> L S I I G<br><span class="hljs-keyword">Y</span>   I   <span class="hljs-keyword">R</span><br><br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<span class="hljs-string">&quot;PAHNAPLSIIGYIR&quot;</span>。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：s = <span class="hljs-string">&quot;PAYPALISHIRING&quot;</span>, numRows = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;PAHNAPLSIIGYIR&quot;</span><br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    每一行对应一个StringBuilder, 当走到0行或者numRow行则换头。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度:O(N)</span><br><span class="hljs-comment">    空间复杂度:O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span>)   <span class="hljs-keyword">return</span> s;<br><br>    List&lt;StringBuilder&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(numRows);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>        arr.add(<span class="hljs-keyword">new</span> StringBuilder());<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> flag = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span> || row == numRows - <span class="hljs-number">1</span>)<br>            flag = -flag;<br>        <br>        <span class="hljs-keyword">char</span> c = s.charAt(i);<br>        arr.get(row).append(c);<br><br>        row += flag;<br>    &#125;<br><br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (StringBuilder x : arr)<br>        res.append(x);<br>    <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0005_最长回文子串</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0005_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0005_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">给你一个字符串 s，找到 s 中最长的回文子串。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><h4 id="方法1：中心拓展法"><a href="#方法1：中心拓展法" class="headerlink" title="方法1：中心拓展法"></a>方法1：中心拓展法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    枚举每个位置，考虑奇数情况和偶数情况。如果s[l] == s[r], 则不断向两边拓展。</span><br><span class="hljs-comment">    此时回文子串的长度为(r - l - 1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N ^ 2)</span><br><span class="hljs-comment">    空间复杂度：O(1)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">// 奇数情况</span><br>        <span class="hljs-keyword">int</span> l1 = i - <span class="hljs-number">1</span>, r1 = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l1 &gt;= <span class="hljs-number">0</span> &amp;&amp; r1 &lt; s.length() &amp;&amp; s.charAt(l1) == s.charAt(r1)) &#123;<br>            l1--;<br>            r1++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (r1 - l1 - <span class="hljs-number">1</span> &gt; res.length()) res = s.substring(l1 + <span class="hljs-number">1</span>, r1);<br><br>        <span class="hljs-comment">// 偶数情况</span><br>        <span class="hljs-keyword">int</span> l2 = i, r2 = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l2 &gt;= <span class="hljs-number">0</span> &amp;&amp; r2 &lt; s.length() &amp;&amp; s.charAt(l2) == s.charAt(r2)) &#123;<br>            l2--;<br>            r2++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (r2 - l2 - <span class="hljs-number">1</span> &gt; res.length()) res = s.substring(l2 + <span class="hljs-number">1</span>, r2);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中心拓展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0001_两个正序数组的中位数</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0004_%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0004_%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br><br>示例 1：<br><br>输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><h4 id="方法1：暴力法"><a href="#方法1：暴力法" class="headerlink" title="方法1：暴力法"></a>方法1：暴力法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    相当于合并两个有序数组，最后取中位数即可。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度:O(M + N)</span><br><span class="hljs-comment">    空间复杂度:O(M + N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums1.length;<br>    <span class="hljs-keyword">int</span> m = nums2.length;<br><br>    <span class="hljs-keyword">int</span>[] t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + m];<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;<br>        <span class="hljs-keyword">if</span> (nums1[i] &lt;= nums2[j]) &#123;<br>            t[k++] = nums1[i++];<br>        &#125; <span class="hljs-keyword">else</span><br>            t[k++] = nums2[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt; n)<br>        t[k++] = nums1[i++];<br>    <br>    <span class="hljs-keyword">while</span> (j &lt; m)<br>        t[k++] = nums2[j++];<br>    <br>    <span class="hljs-keyword">if</span> (t.length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> (t[t.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + t[t.length / <span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)t[t.length / <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2：递归"><a href="#方法2：递归" class="headerlink" title="方法2：递归"></a>方法2：递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    将问题转化为：</span><br><span class="hljs-comment">        求两个正序数组中第k小的数。当 k = (m + n) / 2时，显然就是答案。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    核心思想：</span><br><span class="hljs-comment">        分别取两个数组的第 k / 2 个元素。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        如果s1[i + k / 2] &gt; s2[j + k / 2], 说明 s2的前k/2元素都小于等于第k个小数。因此在剩下的数中寻找第 k - k / 2 小数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        如果s1[i + k / 2] &lt;= s2[j + k / 2&gt;, 说明 s1的前k/2个元素都小雨的呢关于第k小的数。因此也可以将问题规模减半。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        考虑边界情况：如果s1的长度 m &lt; k / 2, 则当s1[m - 1] &lt;= s2[k / 2 - 1]。则第k小数是s2[k - m - 1];</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度:O(log(N + M))</span><br><span class="hljs-comment">    空间复杂度:O(log(N + M))</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> total = nums1.length + nums2.length;<br><br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> l = findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">int</span> r = findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> (l + r) / <span class="hljs-number">2.0</span>;<br>    &#125; <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">1.0</span>;<br>&#125;<br><br><span class="hljs-comment">// 始终保证：nums1的剩余长度 &lt; nums2的剩余长度</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums1.length - i &gt; nums2.length - j)<br>        <span class="hljs-keyword">return</span> findKth(nums2, j, nums1, i, k);<br>    <br>    <span class="hljs-comment">// 如果nums1所有元素都比第k小的数小。</span><br>    <span class="hljs-keyword">if</span> (i == nums1.length)<br>        <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br>    <br>    <span class="hljs-keyword">int</span> si = Math.min(i + k / <span class="hljs-number">2</span>, nums1.length);<br>    <span class="hljs-keyword">int</span> sj = j + k / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (nums1[si - <span class="hljs-number">1</span>] &gt; nums2[sj - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findKth(nums1, si, nums2, j, k - (si - i));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0001_无重复字符的最长字串</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0003_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0003_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br><br>示例 1:<br><br><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><h4 id="方法1：滑动窗口"><a href="#方法1：滑动窗口" class="headerlink" title="方法1：滑动窗口"></a>方法1：滑动窗口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    滑动窗口的思想：窗口内维护无重复字符的连续子串，如果出现了重复字符则需要不断调整左边界直到无重复字符。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    此外，还需要记录窗口内出现的字符。用哈希表记录字符与索引的映射。当重复字符的下标index处于窗口范围内[j, i], 则j需要调整为index + 1, 若是在窗口外则不影响。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N)</span><br><span class="hljs-comment">    空间复杂度：O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;   <br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    Map&lt;Character, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; s.length(); r++) &#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(r);<br>        <span class="hljs-keyword">if</span> (m.containsKey(c)) &#123;<br>            l = Math.max(l, m.get(c) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        m.put(c, r);<br><br>        xMax = Math.max(xMax, r - l + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0002_两数相加</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0002_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0002_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br><br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br><br>示例1：<br><br>输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><h4 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    由于链表从小数位开始记录，因此无需逆转。直接模拟数组的两数相加即可。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N)</span><br><span class="hljs-comment">    空间复杂度：O(1)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function">ListNode <span class="hljs-title">solve</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>    ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    ListNode curNode = dummyNode;<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) &#123;<br>            t += l1.val;<br>            l1 = l1.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) &#123;<br>            t += l2.val;<br>            l2 = l2.next;<br>        &#125;<br><br>        curNode.next = <span class="hljs-keyword">new</span> ListNode(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>        curNode = curNode.next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-number">0</span>)<br>        curNode.next = <span class="hljs-keyword">new</span> ListNode(t);<br>    <br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0001_两数之和</title>
    <link href="/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0001_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/03/25/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0001_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br><br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br><br>你可以按任意顺序返回答案。<br><br><br>示例 1：<br><br>输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><h4 id="方法1：暴力法"><a href="#方法1：暴力法" class="headerlink" title="方法1：暴力法"></a>方法1：暴力法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    两层循环找出所有的整数对，若和为target则返回两者下标。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N ^ 2)</span><br><span class="hljs-comment">    空间复杂度: O(1)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] solve(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2：哈希表"><a href="#方法2：哈希表" class="headerlink" title="方法2：哈希表"></a>方法2：哈希表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    在遍历数组的过程中，记录已经出现过的数字。如果出现过 target - nums[i], 则表明满足条件。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N)</span><br><span class="hljs-comment">    空间复杂度：O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] solve(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    Map&lt;Integer, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (m.containsKey(target - nums[i]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;m.get(target - nums[i]), i&#125;;<br>        <br>        m.put(nums[i], i);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0044_通配符匹配</title>
    <link href="/2021/03/23/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0044_%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
    <url>/2021/03/23/%E7%AE%97%E6%B3%95/LeetCode0041-0060/LC0044_%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">给定一个字符串 <span class="hljs-comment">(s)</span> 和一个字符模式 <span class="hljs-comment">(p)</span> ，实现一个支持 <span class="hljs-string">&#x27;?&#x27;</span> 和 <span class="hljs-string">&#x27;*&#x27;</span> 的通配符匹配。<br><br><span class="hljs-string">&#x27;?&#x27;</span> 可以匹配任何单个字符。<br><span class="hljs-string">&#x27;*&#x27;</span> 可以匹配任意字符串（包括空字符串）。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">与<span class="hljs-symbol">LC0010_</span>正则表达式类似。<br>不同的是：<br>    (<span class="hljs-number">1</span>) <span class="hljs-string">&#x27;.&#x27;</span> 相当于 <span class="hljs-string">&#x27;?&#x27;</span><br>    (<span class="hljs-number">2</span>) 由于<span class="hljs-string">&#x27;*&#x27;</span>可以相当于任意字符，因此匹配<span class="hljs-number">0</span>次时不需要 j &gt;= <span class="hljs-number">2</span>; 匹配多次时不需要 s[i] == p[j<span class="hljs-number">-1</span>]<br><br>    匹配<span class="hljs-number">0</span>次：dp[i][j<span class="hljs-number">-1</span>]<br>    匹配<span class="hljs-number">1</span>次：dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>    匹配<span class="hljs-number">2</span>次：dp[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-2</span>]<br><br>    dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] || ... || <br>    dp[i<span class="hljs-number">-1</span>][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-1</span>] || ... ||<br><br>    因此 dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-1</span>][j]<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br><br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    p = <span class="hljs-string">&quot; &quot;</span> + p;<br><br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-comment">// 不为&#x27;*&#x27;</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="hljs-string">&#x27;?&#x27;</span>))<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] || dp[i][j];<br>            <br>            <span class="hljs-comment">// 为&#x27;*&#x27;</span><br>            <span class="hljs-keyword">if</span> (p.charAt(j) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 匹配0次</span><br>                dp[i][j] = dp[i][j-<span class="hljs-number">1</span>] || dp[i][j];<br><br>                <span class="hljs-comment">// 匹配多次</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] || dp[i][j];<br>            &#125;<br>        &#125;    <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>线性DP</tag>
      
      <tag>通配符匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0010_正则表达式</title>
    <link href="/2021/03/23/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0010_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/03/23/%E7%AE%97%E6%B3%95/LeetCode0001-0020/LC0010_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <span class="hljs-string">&#x27;.&#x27;</span> 和 <span class="hljs-string">&#x27;*&#x27;</span> 的正则表达式匹配。<br><br><span class="hljs-string">&#x27;.&#x27;</span> 匹配任意单个字符<br><span class="hljs-string">&#x27;*&#x27;</span> 匹配零个或多个前面的那一个元素<br><br>示例 <span class="hljs-number">1</span>：<br>输入：s = <span class="hljs-comment">&quot;aa&quot;</span> p = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-keyword">false</span><br>解释：<span class="hljs-comment">&quot;a&quot;</span> 无法匹配 <span class="hljs-comment">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">dp[i][j] : s串前i个字符是否能够和p串前j个字符匹配<br><br>集合划分：以p[j]是否为<span class="hljs-string">&#x27;*&#x27;</span>进行划分<br>         如果不是<span class="hljs-string">&#x27;*&#x27;</span>, 则只有当s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &amp;&amp; dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] == true. 才能够匹配。<br>         <br>         如果是<span class="hljs-string">&#x27;*&#x27;</span>, 则可能匹配<span class="hljs-number">0</span>次, <span class="hljs-number">1</span>次.... n次。<br>         dp[i][j] = dp[i][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>] &amp;&amp; s[i] || dp[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-2</span>] &amp;&amp; s[i] &amp;&amp; s[i<span class="hljs-number">-1</span>] || ...<br>         <br>        于此同时我们可以发现 dp[i<span class="hljs-number">-1</span>][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-2</span>] &amp; s[i<span class="hljs-number">-1</span>] || ...<br><br>        因此 dp[i][j] = dp[i][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-1</span>][j] &amp; s[i]<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br><br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    p = <span class="hljs-string">&quot; &quot;</span> + p;<br><br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] || dp[i][j];<br>            <br>            <span class="hljs-keyword">if</span> (p.charAt(j) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 匹配0次: j &gt;= 2</span><br>                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span>) <br>                    dp[i][j] = dp[i][j-<span class="hljs-number">2</span>] || dp[i][j];<br><br>                <span class="hljs-comment">// 匹配多次: s[i] == p[j - 1]</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j - <span class="hljs-number">1</span>) || p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] || dp[i][j];<br>            &#125;<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之操作系统</title>
    <link href="/2021/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="OSI七层模型？"><a href="#OSI七层模型？" class="headerlink" title="OSI七层模型？"></a>OSI七层模型？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">物理层：通过媒介传输比特,确定机械及电气范围。<span class="hljs-comment">(比特)</span><br>数据链路层：将比特组装成帧和点到点的传递。<span class="hljs-comment">(帧)</span><br>网络层：负责数据包从源到宿的传递和网际互连。<span class="hljs-comment">(包)</span><br>传输层: 提供端到端的可靠报文传递和错误恢复。<span class="hljs-comment">(段)</span><br>会话层：建立、管理和终止会话。<span class="hljs-comment">(会话协议数据单元)</span><br>表示层：对数据进行翻译、加密和压缩。<span class="hljs-comment">(表示协议数据单元)</span><br>应用层: 允许方法OSI环境的手段。<span class="hljs-comment">(应用协议数据单元)</span><br></code></pre></td></tr></table></figure><h2 id="从一个URL到获取页面的过程？"><a href="#从一个URL到获取页面的过程？" class="headerlink" title="从一个URL到获取页面的过程？"></a>从一个URL到获取页面的过程？</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(<span class="hljs-number">1</span>) 浏览器查询DNS，获取域名对应的<span class="hljs-built_in">IP</span>地址。具体过程包括: 浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的host文件、像本地DNS服务器进行查询。<br><br>(<span class="hljs-number">2</span>) 获取对应的<span class="hljs-built_in">IP</span>地址以后，向服务器请求建立连接，发起TCP三次握手。<br><br>(<span class="hljs-number">3</span>) 连接建立以后，浏览器发起HTTP请求<br><br>(<span class="hljs-number">4</span>) 浏览器收到请求以后，处理请求并返回相应的视图。<br><br>(<span class="hljs-number">5</span>) 浏览器解析并渲染视图。如果有对<span class="hljs-keyword">js</span>、css及图片等静态资源的引用，则重复HTTP请求获取相应的资源。<br><br>(<span class="hljs-number">6</span>) 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。<br></code></pre></td></tr></table></figure><h3 id="Session的实现原理-和-Cookie的实现原理？"><a href="#Session的实现原理-和-Cookie的实现原理？" class="headerlink" title="Session的实现原理 和 Cookie的实现原理？"></a>Session的实现原理 和 Cookie的实现原理？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。<br><br><span class="hljs-keyword">Session</span> 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。使用上比 Cookie 简单一些，相应的也增加了服务器的存储压力。<br><br>总体来说：Cookie 通过在客户端记录信息确定用户身份，<span class="hljs-keyword">Session</span> 通过在服务器端记录信息确定用户身份。<br></code></pre></td></tr></table></figure><h3 id="Session和Cooike的关系？禁用Cookie对Session的影响？"><a href="#Session和Cooike的关系？禁用Cookie对Session的影响？" class="headerlink" title="Session和Cooike的关系？禁用Cookie对Session的影响？"></a>Session和Cooike的关系？禁用Cookie对Session的影响？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Session</span> 的实现常常依赖于 Cookie 机制。一般默认情况下，服务器存储 <span class="hljs-keyword">session</span> 的 sessionid 是通过 cookie 存到浏览器里。如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，<span class="hljs-keyword">session</span> 失效。但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用 <span class="hljs-keyword">session</span>。<br><br><span class="hljs-number">1</span>、通过 url 重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中 携带 sessionid 参数。<br><span class="hljs-number">2</span>、服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。<br><span class="hljs-number">3</span>、通过 Http 协议其他 <span class="hljs-keyword">header</span> 字段，服务器每次返回时设置该 <span class="hljs-keyword">header</span> 字段信息，浏览器中 js 读取该 <span class="hljs-keyword">header</span> 字段，请求服务器时，js 设置携带该 <span class="hljs-keyword">header</span> 字段。<br></code></pre></td></tr></table></figure><h3 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">forward 是服务器请求资源，服务器直接访问目标地址的 <span class="hljs-built_in">URL</span>, 把那个 <span class="hljs-built_in">URL</span> 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址.<br><br>redirect 是服务端根据逻辑，发送一个状态码 , 告诉浏览器重新去请求那个地址。所以地址栏显示的是新的<span class="hljs-built_in">URL</span>.<br></code></pre></td></tr></table></figure><h3 id="内网和外网的区别？ABC三类地址的划分？"><a href="#内网和外网的区别？ABC三类地址的划分？" class="headerlink" title="内网和外网的区别？ABC三类地址的划分？"></a>内网和外网的区别？ABC三类地址的划分？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">外网 <span class="hljs-built_in">IP</span> 是全世界唯一的 <span class="hljs-built_in">IP</span> 地址，仅分配给一个网络设备。公网 <span class="hljs-built_in">IP</span> 地址全世界仅分配给一个网络设备。<br><br>内网 <span class="hljs-built_in">IP</span> 局域网，网线都是连接在同一个 交换机上面的，也就是说它们的 <span class="hljs-built_in">IP</span> 地址是由交换机或者路由器进行分配的。内网用户的电脑都是经过交换机和路由器之后才能连到 外网。Internet 上的用户也无法直接访问到内网用户。不同内网的内网地址可以相同。<br><br><span class="hljs-built_in">IP</span>地址 = 网络地址 + 主机地址。<br>A类网络：以<span class="hljs-number">0</span>开头前<span class="hljs-number">8</span>位。<span class="hljs-number">0</span> ~ <span class="hljs-number">127</span><br>B类地址：以<span class="hljs-number">10</span>开头前<span class="hljs-number">16</span>位。<span class="hljs-number">128</span> ~ <span class="hljs-number">191</span><br>C类地址：以<span class="hljs-number">110</span>开头前<span class="hljs-number">24</span>位。<span class="hljs-number">192</span> ~ <span class="hljs-number">223</span><br></code></pre></td></tr></table></figure><h3 id="网关和子网掩码的关系？"><a href="#网关和子网掩码的关系？" class="headerlink" title="网关和子网掩码的关系？"></a>网关和子网掩码的关系？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">子网掩码：用来判断任意两台计算机的 <span class="hljs-built_in">ip</span> 地址是否属于同一子网络的根据。<br><br>网关实质上是一个在不同子段网路中传输数据的设备。<br><br>子网掩码相同，不需要网关即可通讯，子网掩码不同，需要网关才能通讯。<br></code></pre></td></tr></table></figure><h3 id="MAC地址和IP地址的关系？"><a href="#MAC地址和IP地址的关系？" class="headerlink" title="MAC地址和IP地址的关系？"></a>MAC地址和IP地址的关系？</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">MAC</span> 地址是硬件地址，定位全球唯一主机机器，在网络底层的物理传输过程中，是通 过物理地址来识别主机的，它一定是全球唯一的，对应数据链路层。<br><br>IP 地址是网络拓扑地址，定位全球唯一网络结构中的主机。对应网路层。<br></code></pre></td></tr></table></figure><h3 id="什么是DNS服务器？"><a href="#什么是DNS服务器？" class="headerlink" title="什么是DNS服务器？"></a>什么是DNS服务器？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DNS</span> 是指：域名服务器 (Domain Name Server)。在 Internet 上域名与 <span class="hljs-built_in">IP</span> 地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识 <span class="hljs-built_in">IP</span> 地址，它们之间的转 换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 就是进行域名解析的服务器 。一个<span class="hljs-built_in">ip</span>是可以供多个域名解析的,但是域名解析到的一个地址是一对一的。底层使用UDP协议。<br></code></pre></td></tr></table></figure><h3 id="IP如何映射到MAC地址？"><a href="#IP如何映射到MAC地址？" class="headerlink" title="IP如何映射到MAC地址？"></a>IP如何映射到MAC地址？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用ARP协议, 位于网络层。<br><br>工作原理:<br>    (<span class="hljs-number">1</span>) 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 <span class="hljs-built_in">IP</span> 地址和 MAC 地址之间的对应关系。当源主机要发送数据时，首先检查 ARP 列表中是否有对应 <span class="hljs-built_in">IP</span> 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 ARP 数据包。<br><br>    (<span class="hljs-number">2</span>) 当本网络的所有主机收到该 ARP 数据包时，首先检查数据包中的 <span class="hljs-built_in">IP</span> 地址是否是自己 的 <span class="hljs-built_in">IP</span> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <span class="hljs-built_in">IP</span> 和 MAC 地址写入到 ARP 列表中, 然后将自己的MAC地址回复给源主机。<br><br>    (<span class="hljs-number">3</span>) 如果目标 <span class="hljs-built_in">IP</span> 与自己不在同一个网段，这种情况需要将包发给默认网关，所以主要获取网关的 MAC 地址。<br></code></pre></td></tr></table></figure><h3 id="TCP是如何保证可靠传输的？"><a href="#TCP是如何保证可靠传输的？" class="headerlink" title="TCP是如何保证可靠传输的？"></a>TCP是如何保证可靠传输的？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">保证可靠传输最主要的是：<br>    <span class="hljs-comment">(1)</span> 拥塞控制<br>    <span class="hljs-comment">(2)</span> 流量控制<br>    <span class="hljs-comment">(3)</span> ARQ协议<br>    <br>    除此之外还有：超时传送、丢弃重复、校验和、分割合适数据包。<br></code></pre></td></tr></table></figure><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h3 id="TCP-和-UDP-的区别？"><a href="#TCP-和-UDP-的区别？" class="headerlink" title="TCP 和 UDP 的区别？"></a>TCP 和 UDP 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">TCP：面向连接、面向字节流、一对一； UDP：无连接、面向报文、一对一、一对多、 多对多。 <br><br>TCP 的优点：可靠，稳定. 缺点：慢，效率低，占用系统资源高，易被攻击 <br><br>UDP 的优点：快，UDP 是一个无状态的传输协议 缺点： 不可靠，不稳定<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数DP</title>
    <link href="/2021/03/22/Acwing/%E8%AE%A1%E6%95%B0DP/"/>
    <url>/2021/03/22/Acwing/%E8%AE%A1%E6%95%B0DP/</url>
    
    <content type="html"><![CDATA[<h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">一个正整数 <span class="hljs-built_in">n</span> 可以表示成若干个正整数之和，形如：<span class="hljs-built_in">n</span>=<span class="hljs-symbol">n1</span>+<span class="hljs-symbol">n2</span>+…+nk，其中 <span class="hljs-symbol">n1</span>≥<span class="hljs-symbol">n2</span>≥…≥nk,k≥<span class="hljs-number">1</span>。<br><br>我们将这样的一种表示称为正整数 <span class="hljs-built_in">n</span> 的一种划分。<br><br>现在给定一个正整数 <span class="hljs-built_in">n</span>，请你求出 <span class="hljs-built_in">n</span> 共有多少种不同的划分方法。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC312_戳气球</title>
    <link href="/2021/03/22/%E7%AE%97%E6%B3%95/LC0312_%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <url>/2021/03/22/%E7%AE%97%E6%B3%95/LC0312_%E6%88%B3%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs inform7">有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。<br><br>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums<span class="hljs-comment">[i - 1]</span> * nums<span class="hljs-comment">[i]</span> * nums<span class="hljs-comment">[i + 1]</span> 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。<br><br>求所能获得硬币的最大数量。<br><br> <br>示例 1：<br>输入：nums = <span class="hljs-comment">[3,1,5,8]</span><br>输出：167<br>解释：<br>    nums = <span class="hljs-comment">[3,1,5,8]</span> --&gt; <span class="hljs-comment">[3,5,8]</span> --&gt; <span class="hljs-comment">[3,8]</span> --&gt; <span class="hljs-comment">[8]</span> --&gt; <span class="hljs-comment">[]</span><br>    coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167<br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[1,5]</span><br>输出：10<br></code></pre></td></tr></table></figure><h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 打完所有[i+1, j-1]的气球所能获得的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以最后一个气球作为分界点</span><br><span class="hljs-comment">             (第i+1个 | 第i+2个 | 第k个 | ... | 第j-1个)</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    则dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 辅助数组。首尾添加1</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];<br>    temp[<span class="hljs-number">0</span>] = temp[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        temp[i+<span class="hljs-number">1</span>] = nums[i];<br>    <br>    <span class="hljs-comment">// 枚举长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">3</span>; len &lt;= n + <span class="hljs-number">2</span>; len++) &#123;<br>        <span class="hljs-comment">// 枚举左边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;= n + <span class="hljs-number">2</span> - len; l++) &#123;<br>            <span class="hljs-comment">// 确定右边界</span><br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 枚举切割点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l + <span class="hljs-number">1</span>; k &lt; r; k++)<br>                dp[l][r] = Math.max(dp[l][r], dp[l][k] + dp[k][r] + temp[l] * temp[k] * temp[r]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/2021/03/22/Acwing/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2021/03/22/Acwing/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">设有 <span class="hljs-built_in">N</span> 堆石子排成一排，现在要将这 <span class="hljs-built_in">N</span> 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和,找出一种合理的方法，使总的代价最小，输出最小代价。<br></code></pre></td></tr></table></figure><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 所有将第i堆到第j堆合并为一个的方案中的代价的最小值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以最后一次的分界线来分类。</span><br><span class="hljs-comment">             (第i堆和[i+1, j]合并 | [i, i + 1]与[i + 2, j]合并 | ... | [i, j - 1] 和第j堆合并)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j] = dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1];</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] pre;<br><span class="hljs-keyword">int</span>[][] dp;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 处理前缀和</span><br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] + nums[i];<br>    <br>    dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br><br>    helper(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 合并区间[l, r]的最小代价</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (dp[l][r] != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> dp[l][r];<br>    <br>    <span class="hljs-comment">// 枚举每个分界线</span><br>    <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt; r; k++) &#123;<br>        res = Math.min(res, helper(nums, l, k) + helper(nums, k + <span class="hljs-number">1</span>, r) + pre[r] - pre[l - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[l][r] = res;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性DP</title>
    <link href="/2021/03/22/Acwing/%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2021/03/22/Acwing/%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。<br><br>        7<br>     <span class="hljs-number"> 3 </span>  8<br>   <span class="hljs-number"> 8 </span> <span class="hljs-number"> 1 </span>  0<br> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 7 </span> <span class="hljs-number"> 4 </span>  4<br>4  <span class="hljs-number"> 5 </span> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 6 </span>  5<br></code></pre></td></tr></table></figure><h4 id="方法1：自顶向下"><a href="#方法1：自顶向下" class="headerlink" title="方法1：自顶向下"></a>方法1：自顶向下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    7</span><br><span class="hljs-comment">    3 8</span><br><span class="hljs-comment">    8 1 0</span><br><span class="hljs-comment">    2 7 4 4</span><br><span class="hljs-comment">    4 5 2 6 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 所有从(0, 0)走到(i, j)的路径的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从上面来 | 从左上方来)</span><br><span class="hljs-comment">             max(dp[i-1][j] | dp[i-1][j-1]) + matrix[i][j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++) <br>            dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= col; k++)<br>        xMax = Math.max(dp[row][k], xMax);<br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br><span class="hljs-comment">// 优化：跟01背包相似，都与第i-1层的第j个和第j-1个有关</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[col + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j-<span class="hljs-number">1</span>]) + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= col; k++)<br>        xMax = Math.max(dp[k], xMax);<br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2：自底向上"><a href="#方法2：自底向上" class="headerlink" title="方法2：自底向上"></a>方法2：自底向上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    7</span><br><span class="hljs-comment">    3 8</span><br><span class="hljs-comment">    8 1 0</span><br><span class="hljs-comment">    2 7 4 4</span><br><span class="hljs-comment">    4 5 2 6 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 所有从最底部走到(i, j)的路径的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从下面来 | 从右下方来)</span><br><span class="hljs-comment">             max(dp[i+1][j] | dp[i+1][j+1]) + matrix[i][j]</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个长度为 <span class="hljs-built_in">N</span> 的数列，求数值严格单调递增的子序列的长度最长是多少。<br><br>子序列：不要求连续<br></code></pre></td></tr></table></figure><h4 id="方法1：朴素版"><a href="#方法1：朴素版" class="headerlink" title="方法1：朴素版"></a>方法1：朴素版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i]：以下标i结尾的最长上升子序列的长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(比nums[0]大 | 比nums[1]大 | ... | 比nums[i-1]大)</span><br><span class="hljs-comment">            max(dp[0] | dp[1] | ... | dp[n - 1]) + 1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        xMax = Math.max(dp[i], xMax);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="方法2：二分法优化"><a href="#方法2：二分法优化" class="headerlink" title="方法2：二分法优化"></a>方法2：二分法优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于二分法的优化。</span><br><span class="hljs-comment">    g[i]: 最大长度为i的递增子序列中序列的最小值</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    那么在遍历nums[i]的过程中，只需要在g[]中寻找 &lt; nums[i] 的右边界r，那么 dp[i] = r + 1; g[r + 1] = nums[i]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    g[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <br>        <span class="hljs-comment">// 在g[]中寻找 &lt; nums[i] 的右边界</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g[mid] &lt; nums[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前最大长度</span><br>        len = Math.max(len, r + <span class="hljs-number">1</span>);<br>        g[r + <span class="hljs-number">1</span>] = nums[i];<br>        dp[i] = r + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="延申：打印字典序最小的最长上升子序列"><a href="#延申：打印字典序最小的最长上升子序列" class="headerlink" title="延申：打印字典序最小的最长上升子序列"></a>延申：打印字典序最小的最长上升子序列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 假如说我们已经拿到了dp[] 和 xMax</span><br><br>    <span class="hljs-comment">// 如果出现dp[i] = 3, dp[i + 1] = 3, 那么显然nums[i+1] &lt; nums[i]。因此后者才是字典序最小的。</span><br><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[xMax];<br>    <span class="hljs-keyword">int</span> k = xMax - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = xMax; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// dp[i] == j, 则添加进res中</span><br>        <span class="hljs-keyword">if</span> (dp[i] == j) &#123;<br>            res[k--] = nums[i];<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个长度分别为 N 和 M 的字符串 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，求既是 <span class="hljs-selector-tag">A</span> 的子序列又是 <span class="hljs-selector-tag">B</span> 的子序列的字符串长度最长是多少。<br></code></pre></td></tr></table></figure><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 所有 即出现在第一个序列的前i个字符中，且出现在第二个序列的前j个字符中 的子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以 a[i] 和 b[j] 是否包含在子序列中为划分依据</span><br><span class="hljs-comment">         max (包含a[i] | 包含b[j] | 都包含 | 都不包含)</span><br><span class="hljs-comment">         max (dp[i][j-1] | dp[i-1][j] | dp[i-1][j-1] + 1 | dp[i-1][j-1])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>    <span class="hljs-comment">// 子序列没有连续的要求</span><br>    <span class="hljs-comment">// dp[i][j]: 字符串1的前i个字符和字符串2前j个字符的最长公共子序列的长度</span><br><br>    <span class="hljs-keyword">int</span> n = text1.length();<br>    <span class="hljs-keyword">int</span> m = text2.length();<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 包含s1[i]或者s2[j]</span><br>            dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>]);<br><br>            <span class="hljs-comment">// 如果s1[i] == s2[j], 则包含s1[i]和s2[j]</span><br>            <span class="hljs-keyword">if</span> (text1.charAt(i) == text2.charAt(j))<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>], dp[i][j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个字符串 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，现在要将 <span class="hljs-selector-tag">A</span> 经过若干操作变为 <span class="hljs-selector-tag">B</span>，可进行的操作有：<br>    删除–将字符串 <span class="hljs-selector-tag">A</span> 中的某个字符删除。<br>    插入–在字符串 <span class="hljs-selector-tag">A</span> 的某个位置插入某个字符。<br>    替换–将字符串 <span class="hljs-selector-tag">A</span> 中的某个字符替换为另一个字符。<br>现在请你求出，将 <span class="hljs-selector-tag">A</span> 变为 <span class="hljs-selector-tag">B</span> 至少需要进行多少次操作。<br></code></pre></td></tr></table></figure><h4 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = word1.length();<br>    <span class="hljs-keyword">int</span> n = word2.length();<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 需要增dp[i][j+1]、删dp[i+1][j]、改dp[i][j]的情况</span><br>            dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(dp[i][j+<span class="hljs-number">1</span>], Math.min(dp[i][j], dp[i+<span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">// 相等则啥也不用改</span><br>            <span class="hljs-keyword">if</span> (word1.charAt(i) == word2.charAt(j))<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>], dp[i][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2021/03/20/Acwing/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/20/Acwing/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    01背包模型：</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品只能选择一次。</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">        (选第i物品[前提是能装得下] | 不选第i个物品)</span><br><span class="hljs-comment">        (dp[i - 1][j - v[i]] + w[i] | dp[i - 1][j])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版本</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag01</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-comment">// 不选择第i个物品</span><br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br><br>            <span class="hljs-comment">// 选取第i个物品</span><br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) <br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    优化版</span><br><span class="hljs-comment">    dp[i]这一层仅使用到了dp[i-1]这一层，因此可以优化为一维。</span><br><span class="hljs-comment">    由于第i层的是通过第i-1层的第j位和第j-v[i]位来更新，因此优化成1维的时候，必须保证j-v[i]还没有被覆盖。因此需要从大到小进行更新。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag01</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;= v[i]; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    完全背包模型:</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品可以选取无数次。</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">            (不选第i个物品 | 选1个 | 选2个 | ... | 选k个)</span><br><span class="hljs-comment">            (dp[i-1][j] | dp[i-1][j - v[i]] + w[i] | dp[i-1][j - 2 * v[i]] + 2 * w[i] | ... | dp[i-1][j - k * v[i]] + k * w[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k++)<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化1：</span><br><span class="hljs-comment">    dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2v] + 2w + .... + dp[i-1][j-kv] + kw)</span><br><span class="hljs-comment">    dp[i][j-v] = max(          dp[i-1][j-v], dp[i-1][j-2v] + w, ... + dp[i-1][j-kv] + (k-1)w)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    因此dp[i][j] = max(dp[i-1][j], dp[i][j-v] + w) </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i+<span class="hljs-number">1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化2：</span><br><span class="hljs-comment">        dp[i][j]需要第i-1层的第j个和第i层的第j-v[i]个有关。因此可以优化成一维。</span><br><span class="hljs-comment">        需要保证j从小到大更新。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag03</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v[i]; j &lt;= V; j++) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    多重背包模型：</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品最多包含s个。</span><br><span class="hljs-comment">        s[i]: 第i个物品的个数</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">            (不选第i个物品 | 选1个 | 选2个 | ... | 选s个)</span><br><span class="hljs-comment">            (dp[i-1][j] | dp[i-1][j - v[i]] + w[i] | dp[i-1][j - 2 * v[i]] + 2 * w[i] | ... | dp[i-1][j - s * v[i]] + s * w[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] s, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">// 优化版：二进制优化, 将s[i]分解成1、2、4、8..., 然后转换成01背包问题</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (k &lt;= s) &#123;<br>    v[cnt] = a * k;<br>    w[cnt] = b * k;<br>    s -= k;<br>    k *= <span class="hljs-number">2</span>;<br>    cnt++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>    v[cnt] = a * s;<br>    w[cnt] = b * s;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合背包"><a href="#组合背包" class="headerlink" title="组合背包"></a>组合背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    组合背包模型：</span><br><span class="hljs-comment">        有N组物品和一个容量为V的背包，每个组只能选择一个。</span><br><span class="hljs-comment">        v[i][k]: 第i组的第k个物品的体积</span><br><span class="hljs-comment">        w[i][k]: 第i组的第k个物品的价值</span><br><span class="hljs-comment">        s[i]: 第i组一共有多少个物品</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(不从第i组选择 | 从第i组选第1个物品 | ... | 从第i组选第k个物品)</span><br><span class="hljs-comment">             (dp[i-1][j] | dp[i-1][j - v[i-1][1]] + w[i-1][1] | ... | dp[i-1][j - v[i-1][k]] + w[i-1][k])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag04</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] v, <span class="hljs-keyword">int</span>[][] w, <span class="hljs-keyword">int</span>[] s, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-comment">// 不选择</span><br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k++) &#123;<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - v[i][k] + w[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化：第i层的第j个只与第i-1层的第j个和第i-1层的第j-v[i][k]有关，因此优化方案与01背包一样</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i][k])<br>                dp[j] = Math.max(dp[j], dp[j - v[i][k] + w[i][k]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之Java基础</title>
    <link href="/2021/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BJava%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BJava%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="StringBuilder-和-StringBuffer-的异同点"><a href="#StringBuilder-和-StringBuffer-的异同点" class="headerlink" title="StringBuilder 和 StringBuffer 的异同点"></a>StringBuilder 和 StringBuffer 的异同点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">相同点：底层都是<span class="hljs-keyword">char</span>数组<br>不同点：前者是线程不安全的，后者是线程安全的(通过Synchronized修饰)<br></code></pre></td></tr></table></figure><h3 id="Java数组对象的内存分配"><a href="#Java数组对象的内存分配" class="headerlink" title="Java数组对象的内存分配"></a>Java数组对象的内存分配</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">基础类型的数组，分配在栈内存中，是连续分配的。<br><br>对象数组，对象引用连续分配在栈内存中。实际对象分配在堆内存，不是连续分配的<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="创建对象的方式有哪些？"><a href="#创建对象的方式有哪些？" class="headerlink" title="创建对象的方式有哪些？"></a>创建对象的方式有哪些？</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) new<br>(<span class="hljs-number">2</span>) clone()<br>(<span class="hljs-number">3</span>) 反射<br>(<span class="hljs-number">4</span>) 序列化<br></code></pre></td></tr></table></figure><h3 id="深拷贝-和-浅拷贝"><a href="#深拷贝-和-浅拷贝" class="headerlink" title="深拷贝 和 浅拷贝"></a>深拷贝 和 浅拷贝</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">浅拷贝：在堆内存中，将该对象复制了一份，也就是说产生了一个新的对象。<br><span class="hljs-code">       新对象的属性如果是基本类型，拷贝的就是基本类型的值；</span><br><span class="hljs-code">       如果属性是引用类型，拷贝的就是内存地址。</span><br><span class="hljs-code"></span><br><span class="hljs-code">深拷贝：在堆内存中，将该对象复制了一份，也就是说产生了一个新的对象。</span><br><span class="hljs-code">       在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</span><br></code></pre></td></tr></table></figure><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">== 用来比较栈中的值是否相等。对于基础类型直接比较值，对于引用类型比较地址值。</span><br><br>equals 用来比较堆中对象的内容是否相等。<br><br>Object类中的equals()用的是 ==, 因此如果不重写equals()的话，相当于使用 ==。<br></code></pre></td></tr></table></figure><h3 id="自动拆箱和自动装箱"><a href="#自动拆箱和自动装箱" class="headerlink" title="自动拆箱和自动装箱"></a>自动拆箱和自动装箱</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">拆箱和装箱是指：基础类型和它们对应的包装类之间的转换。拆箱是把包装类型变成基本类型；装箱是把基本类型变成包装类型。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    <url>/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 堆是一个完全二叉树</span><br><span class="hljs-comment">// 核心操作：down(int x) 和 up(int x)</span><br><span class="hljs-comment">// 如果是从下标0开始，则父亲下标为(x - 1) / 2; 如果是从下标1开始，则父亲下标为 x / 2;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(size);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            data.add(arr[i]);<br>        <br>        <span class="hljs-comment">// 从最后一个叶子节点的父节点开始进行down, 即可O(N)实现堆化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            down(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 上浮操作 : 用于添加元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 当不是根节点时，不断与其父节点进行比较。</span><br>        <span class="hljs-comment">// 如果比根节点更小，则进行交换。继续上浮</span><br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; data.get(index) &lt; data.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &#123;<br>            Collections.swap(data, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始t为当前节点，代表值最小的位置</span><br>        <span class="hljs-keyword">int</span> t = index;<br>        <span class="hljs-comment">// 如果左孩子存在，当前最小节点则与左孩子进行比较。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span> &lt; data.size() &amp;&amp; data.get(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>) &lt; data.get(t))<br>            t = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 如果右孩子存在，当前最小节点则与左孩子进行比较。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span> &lt; data.size() &amp;&amp; data.get(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>) &lt; data.get(t))<br>            t = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 如果当前节点不是最小节点，则进行交换。继续下沉。</span><br>        <span class="hljs-keyword">if</span> (t != index) &#123;<br>            Collections.swap(data, t, index);<br>            down(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-comment">// 末尾添加新元素，然后不断上浮</span><br>        data.add(v);<br>        up(data.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 提取堆顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = data.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 末尾元素与堆顶元素交换，然后不断下沉</span><br>        Collections.swap(data, <span class="hljs-number">0</span>, data.size() - <span class="hljs-number">1</span>);<br>        data.remove(data.size() - <span class="hljs-number">1</span>);<br>        down(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集[Acwing]</title>
    <link href="/2021/03/18/Acwing/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/03/18/Acwing/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Acwing837-连通块中点的数量"><a href="#Acwing837-连通块中点的数量" class="headerlink" title="Acwing837_连通块中点的数量"></a>Acwing837_连通块中点的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 合并两个集合：必须先累加size再合并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            size[find(b)] += size[find(a)];<br>            p[find(a)] = find(b);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回x所在连通块的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size[find(x)];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing240-食物链"><a href="#Acwing240-食物链" class="headerlink" title="Acwing240_食物链"></a>Acwing240_食物链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要额外维护当前节点到根节点的距离</span><br><span class="hljs-comment">// 到根节点距离为0 : 与根节点同类</span><br><span class="hljs-comment">// 到根节点距离为1 : 能够吃根节点</span><br><span class="hljs-comment">// 到根节点距离为2 : 能够被根节点吃</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩过程中维护到根节点的距离</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                root</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">              /   d[p[x]]</span><br><span class="hljs-comment">            p[x]</span><br><span class="hljs-comment">            /</span><br><span class="hljs-comment">           /  d[x]</span><br><span class="hljs-comment">          x</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x]) &#123;<br>            <span class="hljs-keyword">int</span> u = find(p[x]); <span class="hljs-comment">// 寻找它当前根节点的父节点</span><br>            <span class="hljs-comment">// 它到新父节点的距离 = 它原来父节点的距离 + 它原来父节点到新父节点的距离</span><br>            d[x] = (d[x] + d[p[x]]) % M;    <br>            p[x] = u;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 与 b 是否同类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br><br>        <span class="hljs-comment">// 如果a和b已经同属于一个集合了，则判断到根节点的距离是否相等</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == d[b] % M;<br>        <br>        <span class="hljs-comment">// 否则，需要将两者放入同一个集合，并更新d[pa]到pb的距离</span><br>        <span class="hljs-comment">// 由于 a 和 b 同类， 所以 (d[a] + d[pa]) % M == d[b] % M</span><br>        <span class="hljs-comment">// 因此 d[pa] = (d[b] - d[a] + M) % M  --- 加M是以防d[a] - d[b] &lt; 0</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 是否能吃 b</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br>        <br>        <span class="hljs-comment">// 如果已经是同类，则a能吃b的前提是 a到根节点的距离 - 1 == b到根节点的距离</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == (d[b] + <span class="hljs-number">1</span>) % M;<br>        <br>        <span class="hljs-comment">// 否则加入同一集合，并维护a吃b的关系</span><br>        <span class="hljs-comment">// (d[a] + d[pa]) % M == (d[b] + 1) % M;</span><br>        <span class="hljs-comment">// d[pa] = (d[b] + 1 - d[a] + M) % M;</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] + <span class="hljs-number">1</span> - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-comment">// 维护并查集的个数</span><br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            p[i] = i;<br>        <br>        <span class="hljs-keyword">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            p[find(a)] = find(b);<br>            size--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            <span class="hljs-comment">// 必须数量相加再合并</span><br>            size[find(b)] += size[find(a)];<br>            p[find(a)] = find(b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护到祖宗节点的并查集"><a href="#维护到祖宗节点的并查集" class="headerlink" title="维护到祖宗节点的并查集"></a>维护到祖宗节点的并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩过程中维护到根节点的距离</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                root</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">              /   d[p[x]]</span><br><span class="hljs-comment">            p[x]</span><br><span class="hljs-comment">            /</span><br><span class="hljs-comment">           /  d[x]</span><br><span class="hljs-comment">          x</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x]) &#123;<br>            <span class="hljs-keyword">int</span> u = find(p[x]); <span class="hljs-comment">// 寻找它当前根节点的父节点</span><br>            <span class="hljs-comment">// 它到新父节点的距离 = 它原来父节点的距离 + 它原来父节点到新父节点的距离</span><br>            d[x] = (d[x] + d[p[x]]) % M;    <br>            p[x] = u;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 与 b 是否同类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br><br>        <span class="hljs-comment">// 如果a和b已经同属于一个集合了，则判断到根节点的距离是否相等</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == d[b] % M;<br>        <br>        <span class="hljs-comment">// 否则，需要将两者放入同一个集合，并更新d[pa]到pb的距离</span><br>        <span class="hljs-comment">// 由于 a 和 b 同类， 所以 (d[a] + d[pa]) % M == d[b] % M</span><br>        <span class="hljs-comment">// 因此 d[pa] = (d[b] - d[a] + M) % M  --- 加M是以防d[a] - d[b] &lt; 0</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 是否能吃 b</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br>        <br>        <span class="hljs-comment">// 如果已经是同类，则a能吃b的前提是 a到根节点的距离 - 1 == b到根节点的距离</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == (d[b] + <span class="hljs-number">1</span>) % M;<br>        <br>        <span class="hljs-comment">// 否则加入同一集合，并维护a吃b的关系</span><br>        <span class="hljs-comment">// (d[a] + d[pa]) % M == (d[b] + 1) % M;</span><br>        <span class="hljs-comment">// d[pa] = (d[b] + 1 - d[a] + M) % M;</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] + <span class="hljs-number">1</span> - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之操作系统</title>
    <link href="/2021/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span>、进程是资源分配的最小单位；线程是任务执行<span class="hljs-comment">(资源调度)</span>的最小单位。<br><br><span class="hljs-number">2</span>、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵；多个线程共享进程的地址空间和数据，因此线程的维护和切换代价比进程要低很多。<br><br><span class="hljs-number">3</span>、进程之间的需要以IPC的方式进行通信；线程由于共享进程的全局变量和静态变量，因此通信更为方便。<br></code></pre></td></tr></table></figure><h3 id="进程调度算法有哪些？"><a href="#进程调度算法有哪些？" class="headerlink" title="进程调度算法有哪些？"></a>进程调度算法有哪些？</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) 先来先服务<br>(<span class="hljs-number">2</span>) 时间片轮转<br>(<span class="hljs-number">3</span>) 短作业优先<br>(<span class="hljs-number">4</span>) 优先级调度<br>(<span class="hljs-number">5</span>) 多级反馈队列 <span class="hljs-selector-attr">[详细了解]</span><br></code></pre></td></tr></table></figure><h3 id="5种IO模型"><a href="#5种IO模型" class="headerlink" title="5种IO模型"></a>5种IO模型</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gcode">同步 <span class="hljs-attr">vs 异步</span><br><span class="hljs-attr">阻塞 vs 非阻塞</span><br><span class="hljs-attr"></span><br><span class="hljs-attr">(1</span>) 阻塞式IO<br>    <br><span class="hljs-comment">(2)</span> 非阻塞式IO<br>    <br><span class="hljs-comment">(3)</span> 多路复用IO<br><br><span class="hljs-comment">(4)</span> 信号驱动IO<br><br><span class="hljs-comment">(5)</span> 异步IO<br></code></pre></td></tr></table></figure><h3 id="进程的通信方式有哪些？线程呢？"><a href="#进程的通信方式有哪些？线程呢？" class="headerlink" title="进程的通信方式有哪些？线程呢？"></a>进程的通信方式有哪些？线程呢？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode">进程间的通信方式：<br>    <span class="hljs-comment">(1)</span> 匿名管道：<br>    <span class="hljs-comment">(2)</span> 管道<span class="hljs-comment">(有名管道)</span><br>    <span class="hljs-comment">(3)</span> 消息队列<br>    <span class="hljs-comment">(4)</span> 信号量<br>    <span class="hljs-comment">(5)</span> 共享内存<br>    <span class="hljs-comment">(7)</span> 套接字<br><br>线程间的通信方式：<br>    <span class="hljs-comment">(1)</span> 互斥量: 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。<br>    <span class="hljs-comment">(2)</span> 信号量<br></code></pre></td></tr></table></figure><h3 id="什么是僵尸进程-什么是孤儿进程-有什么危害"><a href="#什么是僵尸进程-什么是孤儿进程-有什么危害" class="headerlink" title="什么是僵尸进程? 什么是孤儿进程? 有什么危害?"></a>什么是僵尸进程? 什么是孤儿进程? 有什么危害?</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">僵尸进程：<br>    一个进程fork了子进程，如果子进程退出，但是它的父进程没有调用wait/waitpid获取子进程的状态信息，那么子进程的进程描述符等一系列信息还会保存在系统中。这样的进程我们称为僵尸进程。<br><br>    危害：僵尸进程是一个早已死亡的进程，但是在进程表中仍占用了一个位置，而进程表的容量是有限的，如果僵尸进程过多的话可能导致系统无法产生新的进程，导致系统瘫痪。<br><br>处理僵尸进程：<br>    (<span class="hljs-number">1</span>) 修改父进程。子进程死亡后会发送SIGCHLD信号给父进程，父进程收到此信号后调用wait/waitpid进行处理。<br>    (<span class="hljs-number">2</span>) 杀死父进程。杀死父进程后，僵尸进程会进化为孤儿进程，继而由<span class="hljs-number">1</span>号进程<span class="hljs-keyword">init</span>接管，<span class="hljs-keyword">init</span>进程会负责处理孤儿进程。<br><br>孤儿进程：<br>    父进程运行结束，但子进程还在运行 (未运行结束) 的子进程就称为孤儿进程。 <br>    <br>    孤儿进程最终会被 <span class="hljs-keyword">init</span> 进程 (进程号为 <span class="hljs-number">1</span>) 所收养，因此 <span class="hljs-keyword">init</span> 进程此时变成孤儿进程 的父进程，并由 <span class="hljs-keyword">init</span> 进程对它们完成状态收集工作。<br></code></pre></td></tr></table></figure><h3 id="CPU上下文切换有几种？系统中断进行了几次上下文切换？"><a href="#CPU上下文切换有几种？系统中断进行了几次上下文切换？" class="headerlink" title="CPU上下文切换有几种？系统中断进行了几次上下文切换？"></a>CPU上下文切换有几种？系统中断进行了几次上下文切换？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">上下文切换是一种将<span class="hljs-meta">CPU</span>资源从一个进程分配给另外一个进程的机制。操作系统需要先保存当前进程的状态(内存空间的指针，指令执行的位置等)，然后才能加载另外一个进程的状态并执行。<br><br><span class="hljs-meta">CPU</span>的上下文切换分为三种：进程上下文切换、线程上下文切换、中断上下文切换。<br><br>(<span class="hljs-number">1</span>) 系统调用过程中也会发生 <span class="hljs-meta">CPU</span> 上下文切换。<span class="hljs-meta">CPU</span> 寄存器会先保存用户态的状态，然后加载内核态相关内容。系统调用结束之后，<span class="hljs-meta">CPU</span> 寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次 <span class="hljs-meta">CPU</span> 上下文切换。<br><br>(<span class="hljs-number">2</span>) 进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调 用的上下文则不会，因为其未发生进程的变化。<br><br>(<span class="hljs-number">3</span>) 内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。 线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。而线程自己的 私有数据，如栈和寄存器等，上下文切换时需要保存。<br></code></pre></td></tr></table></figure><h3 id="虚拟内存的实现方式有哪些？分别有什么缺陷？"><a href="#虚拟内存的实现方式有哪些？分别有什么缺陷？" class="headerlink" title="虚拟内存的实现方式有哪些？分别有什么缺陷？"></a>虚拟内存的实现方式有哪些？分别有什么缺陷？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 请求分页存储管理。将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如 <span class="hljs-number">4</span>KB、<span class="hljs-number">8</span>KB 或 <span class="hljs-number">16</span>KB 等，并以页面作为内存空间的最小分配单位，一个程序的一个页面 可以存放在任意一个物理页面里。页是信息的物理单位。<br><br><span class="hljs-comment">(2)</span> 请求分段存储管理。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组 相对完整的逻辑信息。段是信息的逻辑单位。<br><br>分页存储的缺点：产生内部碎片 <br>分段存储的缺点：产生外部碎片 <br><br><span class="hljs-comment">(3)</span> 采用段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组 合起来使用。这样做的目的就是想同时获得分段和分页的好处，但又避免了单独分段或单独分页的缺陷<br></code></pre></td></tr></table></figure><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h3 id="什么是中断？产生中断的方式有哪些？"><a href="#什么是中断？产生中断的方式有哪些？" class="headerlink" title="什么是中断？产生中断的方式有哪些？"></a>什么是中断？产生中断的方式有哪些？</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对 程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。<br><br>(<span class="hljs-number">1</span>) 由计算机硬件异常或故障引起的中断，称为内部异常中断<span class="hljs-comment">;</span><br>(<span class="hljs-number">2</span>) 由程序中执行了引起中断的指令而造成的中断，称为软中断（系统调用相关的中断)<span class="hljs-comment">;</span><br>(<span class="hljs-number">3</span>) 由外部设备请求引起的中断，称为外部中断<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="什么会导致用户态陷入内核态？"><a href="#什么会导致用户态陷入内核态？" class="headerlink" title="什么会导致用户态陷入内核态？"></a>什么会导致用户态陷入内核态？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 系统调用：操作系统提供的函数就被称为系统调用（system <span class="hljs-keyword">call</span>）。程序的执行一般是在用户态下 执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、 读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是 系统调用。<br><br><span class="hljs-comment">(2)</span> 异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时 会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如 缺页异常。<br><br><span class="hljs-comment">(3)</span> 外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号， 这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程 序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序 中执行后续操作等。<br></code></pre></td></tr></table></figure><h3 id="陷阱与中断的区别？"><a href="#陷阱与中断的区别？" class="headerlink" title="陷阱与中断的区别？"></a>陷阱与中断的区别？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 陷阱指令可以使执行流程从用户态陷入内核并把控制权转移给操作系统，使得用户程序 可以调用内核函数和使用硬件从而获得操作系统所提供的服务，比如用视频软件放一个 电影，视频软件就发出陷阱使用显示器和声卡从而访问硬件。<br><br><span class="hljs-comment">(2)</span> 中断是由外部事件导致并且它发生的时间是不可预测的，这一点和陷阱不同。外部事件 主要是指时钟中断，硬件中断等。CPU 决定切换到另一个进程运行，就会产生一个时 钟中断，切换到下一个进程运行。<br></code></pre></td></tr></table></figure><h3 id="同步与互斥的关系？"><a href="#同步与互斥的关系？" class="headerlink" title="同步与互斥的关系？"></a>同步与互斥的关系？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法 限制访问者对资源的访问顺序，即访问是无序的。 <br><br><span class="hljs-comment">(2)</span> 同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。<br><br>实现同步和互斥的方式<br>    <span class="hljs-comment">(1)</span> 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>    <span class="hljs-comment">(2)</span> 互斥量：为协调共同对一个共享资源的单独访问而设计的。 <br>    <span class="hljs-comment">(3)</span> 信号量：为控制一个具有有限数量用户资源而设计。 <br>    <span class="hljs-comment">(4)</span> 事 件：用来通知线程有一些事件已发生，从而启动后继任务的开始。<br></code></pre></td></tr></table></figure><h3 id="死锁产生的条件？"><a href="#死锁产生的条件？" class="headerlink" title="死锁产生的条件？"></a>死锁产生的条件？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">互斥条件 <span class="hljs-comment">(Mutual exclusion)</span>：资源不能被共享，只能由一个进程使用。<br>请求与保持条件 <span class="hljs-comment">(Hold and wait)</span>：已经得到资源的进程可以再次申请新的资源。<br>非抢占条件 <span class="hljs-comment">(No pre-emption)</span>：已经分配的资源不能从相应的进程中被强制地剥夺。<br>循环等待条件 <span class="hljs-comment">(Circular wait)</span>：系统中若干进程组成环路，该环路中每个进程都在等待 相邻进程正占用的资源。<br></code></pre></td></tr></table></figure><h3 id="IO多路复用的select、poll和epoll的区别"><a href="#IO多路复用的select、poll和epoll的区别" class="headerlink" title="IO多路复用的select、poll和epoll的区别"></a>IO多路复用的select、poll和epoll的区别</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">(<span class="hljs-number">1</span>) <span class="hljs-keyword">select</span> 函数监视文件描述符，调用后 <span class="hljs-keyword">select</span> 函数会阻塞，直到有描述符就绪，或者超时，函数返回，当 <span class="hljs-keyword">select</span> 函数返回后，就可以遍历描述符，找到就绪的描述符。<span class="hljs-keyword">select</span> 的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制 <br><br>(<span class="hljs-number">2</span>) poll 没有最大限制（但是数量过大后性能也是会下降）。和 <span class="hljs-keyword">select</span> 函数一样，poll 返回后， 需要轮询来获取就绪的描述符。<br><br>(<span class="hljs-number">3</span>) epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下多路复用 IO 接口 <span class="hljs-keyword">select</span>/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的 情况下的系统 CPU 利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听 的描述符集，只要遍历那些被内核 IO 事件异步唤醒而加入 Ready 队列的描述符集合 就行了。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算器问题</title>
    <link href="/2021/03/11/%E7%AE%97%E6%B3%95/%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/%E8%AE%A1%E7%AE%97%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/11/%E7%AE%97%E6%B3%95/%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/%E8%AE%A1%E7%AE%97%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="利用双栈解决所有计算器问题"><a href="#利用双栈解决所有计算器问题" class="headerlink" title="利用双栈解决所有计算器问题"></a>利用双栈解决所有计算器问题</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">利用数字栈nums和字符栈ops解决计算器问题：<br><br>遍历字符串：<br>    若是空格，跳过。<br>    若是&#x27;(&#x27;，压入ops中，等待与之匹配的&#x27;)&#x27;。<br>    若是&#x27;)&#x27;, 取ops和nums进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums。<br>    若是操作符，若ops栈顶的操作符优先级大于该操作符，则先计算栈顶的操作。直到遇到左括号或者没有操作符。否则压入ops中。<br>    若是数字，则一直累计直到遇到非数字，将数字压入nums中。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 建立字符串优先级</span><br>        m.put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);<br>        m.put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);<br>        m.put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 去掉所有空格</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 将所有&quot;(-&quot; 改为 &quot;(0-&quot;</span><br>        s = s.replaceAll(<span class="hljs-string">&quot;\\(-&quot;</span>, <span class="hljs-string">&quot;(0-&quot;</span>);<br><br>        Stack&lt;Character&gt; ops = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        Stack&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.push(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                ops.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 一直计算直到遇到左括号为止</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-keyword">char</span> op = ops.peek();<br>                    <span class="hljs-keyword">if</span> (op != <span class="hljs-string">&#x27;(&#x27;</span>)<br>                        cal(ops, nums);<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        ops.pop();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">int</span> j = i;<br>                    <span class="hljs-keyword">while</span> (j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(j) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                        sum = sum * <span class="hljs-number">10</span> + (s.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                        j++;<br>                    &#125;<br>                    nums.push(sum);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 碰到新操作符</span><br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">char</span> prev = ops.peek();<br>                        <span class="hljs-comment">// 如果之前的运算优先级更大，则先计算</span><br>                        <span class="hljs-keyword">if</span> (m.get(prev) &gt;= m.get(c))<br>                            cal(ops, nums);<br>                        <span class="hljs-keyword">else</span> <br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    ops.push(c);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的计算完</span><br>        <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>)<br>            cal(ops, nums);<br><br>        <span class="hljs-keyword">return</span> nums.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(Stack&lt;Character&gt; ops, Stack&lt;Integer&gt; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> a = nums.pop();<br>        <span class="hljs-keyword">int</span> b = nums.pop();<br>        <span class="hljs-keyword">char</span> op = ops.pop();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) ans = b + a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) ans = b - a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) ans = b * a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>) ans = b / a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) ans = (<span class="hljs-keyword">int</span>)Math.pow(b, a);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;%&#x27;</span>) ans = b % a;<br>        nums.push(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>计算器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC300_最长上升子序列</title>
    <link href="/2021/03/06/%E7%AE%97%E6%B3%95/LC0300_%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/03/06/%E7%AE%97%E6%B3%95/LC0300_%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    算法思想：</span><br><span class="hljs-comment">        dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment">        从[0, i - 1]从查找，如果遇到 nums[j] &lt; nums[i], 则 dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N ^ 2)</span><br><span class="hljs-comment">    空间复杂度: O(N) </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 记录最长递增子序列</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 初始化为1</span><br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从[0, n - 1]寻找比 nums[i] 小的数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        xMax = Math.max(xMax, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于二分法的优化。</span><br><span class="hljs-comment">    g[i]: 最大长度为i的递增子序列中序列的最小值</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    那么在遍历nums[i]的过程中，只需要在g[]中寻找 &lt; nums[i] 的右边界r，那么 dp[i] = r + 1; g[r + 1] = nums[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    例如：g[3] = 4; // 1 2 4</span><br><span class="hljs-comment">          g[4] = 6; // 1 2 4 6</span><br><span class="hljs-comment">          nums[i] = 5, 则g[4] = 5; // 1 2 4 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    g[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g[mid] &lt; nums[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前最大长度</span><br>        len = Math.max(len, r + <span class="hljs-number">1</span>);<br>        g[r + <span class="hljs-number">1</span>] = nums[i];<br>        dp[i] = r + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何获取最小字典序"><a href="#如何获取最小字典序" class="headerlink" title="如何获取最小字典序"></a>如何获取最小字典序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    此时dp[i]记录了以i结尾的最长上升子序列的长度；</span><br><span class="hljs-comment">    如果整个序列递增，那么显然dp[i]中的值从小到大依次递增。</span><br><span class="hljs-comment">    如果dp[i]中出现了相等的值，比如：</span><br><span class="hljs-comment">    1 2 5 3;    dp[2] = 3, dp[3] = 3;   显然后者的字典序更小</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[xMax];<br><span class="hljs-keyword">int</span> k = xMax - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = xMax; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// dp[i] == j, 则添加进res中</span><br>    <span class="hljs-keyword">if</span> (dp[i] == j) &#123;<br>        res[k--] = nums[i];<br>        j--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据类型</title>
    <link href="/2021/03/06/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/03/06/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="redisObject类型"><a href="#redisObject类型" class="headerlink" title="redisObject类型"></a>redisObject类型</h3><blockquote><p>Redis是基于内存的K-V存储系统，其中 key 类型一般为字符串，而 value 类型则为 redis 对象(string, list, set…)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>数据类型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表</title>
    <link href="/2021/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/"/>
    <url>/2021/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="跳表简介"><a href="#跳表简介" class="headerlink" title="跳表简介"></a>跳表简介</h2><blockquote><ul><li>在有序链表的基础上添加跳跃功能减少不必要的搜索。</li><li>搜索、删除、添加的时间复杂度为 O(N * logN)。</li><li>跳表按层构造，高层相当于底层的’快速通道’</li></ul></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 定义链表节点Node</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>        K key;<br>        V value;<br>        Node&lt;K, V&gt;[] nexts; <span class="hljs-comment">// 存放后继节点数组</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> Node&lt;K, V&gt; first;   <span class="hljs-comment">// 首部虚拟节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-comment">// 跳表元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEVEL = <span class="hljs-number">32</span>;    <span class="hljs-comment">// 跳表最大层数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> level = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 记录有效层数</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkipList</span><span class="hljs-params">()</span> </span>&#123;<br>        first = <span class="hljs-keyword">new</span> Node&lt;&gt;();<br>        first.nexts = <span class="hljs-keyword">new</span> Node[MAX_LEVEL];<br>    &#125;<br><br>    <span class="hljs-comment">// 生成随机层数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (Math.random() &lt; <span class="hljs-number">0.25</span> &amp;&amp; level &lt; MAX_LEVEL)<br>            level++;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索get-K-key-设计"><a href="#搜索get-K-key-设计" class="headerlink" title="搜索get(K key)设计"></a>搜索get(K key)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、从首节点开始，一直找到第一个 &gt;= key 的下一个节点</span><br><span class="hljs-comment">    2、如果相等，则直接返回；否则从下一层继续寻找</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;<br><br>    Node&lt;K, V&gt; node = first;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-comment">// 若当前节点的key == key, 则找到了直接返回</span><br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> node.nexts[i].value;<br>        <br>        <span class="hljs-comment">// 没找到则从node.nexts[i-1]开始搜索</span><br>    &#125; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加put-K-key-V-value-设计"><a href="#添加put-K-key-V-value-设计" class="headerlink" title="添加put(K key, V value)设计"></a>添加put(K key, V value)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>  <br>    Node&lt;K, V&gt; node = first;  <br>    Node&lt;K, V&gt;[] prevs = <span class="hljs-keyword">new</span> Node[level];         <span class="hljs-comment">// 存放每次发生跳层的节点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-comment">// 若node.nexts[i].key == key, 则覆盖value</span><br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>) &#123;<br>            node.nexts[i].value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 记录发生跳转的节点</span><br>        prevs[i] = node;    <br>    &#125; <br><br>    <span class="hljs-comment">// 不存在改key, 则此时node是前驱节点, i == -1</span><br>    Node&lt;K, V&gt; newNode = <span class="hljs-keyword">new</span> Node(key, value);<br>    <span class="hljs-keyword">int</span> rdLevel = randomLevel();<br>    newNode.nexts = <span class="hljs-keyword">new</span> Node&lt;&gt;[rdLevel];<br><br>    <span class="hljs-comment">// 调整层数为[0, level - 1]的后继指向</span><br>    <span class="hljs-comment">// 如果rdLevel &gt; level, 则调整头节点next</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rdLevel; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; level) &#123;<br>            newNode.nexts[i] = prevs[i].nexts[i];<br>            prevs[i].nexts[i] = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            first.nexts[i] = newNode;<br>        &#125;<br>    &#125;<br><br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除remove-K-key-设计"><a href="#删除remove-K-key-设计" class="headerlink" title="删除remove(K key)设计"></a>删除remove(K key)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;<br>    Node&lt;K, V&gt; node = first;  <br>    Node&lt;K, V&gt;[] prevs = <span class="hljs-keyword">new</span> Node[level];         <span class="hljs-comment">// 存放每次发生跳层的节点</span><br>    <span class="hljs-keyword">boolean</span> exist = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>)<br>            exist = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 找到key则进入下一层并记录所有发生跳转的节点</span><br>        prevs[i] = node;    <br>    &#125; <br><br>    <span class="hljs-comment">// 如果没找到则返回null</span><br>    <span class="hljs-keyword">if</span> (!exist) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 调整所有前驱的后继</span><br>    Node&lt;K, V&gt; removeNode = node.nexts[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; removeNode.nexts.length; i++) &#123;<br>        prevs[i].nexts[i] = removeNode.nexts[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 更新跳表的层数, 从头节点出发寻找next[i]不为空的层数</span><br>    <span class="hljs-keyword">int</span> newLevel = level;<br>    <span class="hljs-keyword">while</span> (newLevel &gt; <span class="hljs-number">0</span> &amp;&amp; first.nexts[newLevel] == <span class="hljs-keyword">null</span>)<br>        newLevel--;<br>    <br>    level = newLevel;<br><br>    size--;<br>    <span class="hljs-keyword">return</span> removeNode.value;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>跳表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2021/03/05/Acwing/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2021/03/05/Acwing/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>前缀和与差分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2021/03/04/Acwing/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2021/03/04/Acwing/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="Acwing791-高精度加法"><a href="#Acwing791-高精度加法" class="headerlink" title="Acwing791_高精度加法"></a>Acwing791_高精度加法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-comment">// 将两个大数字符串翻转</span><br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录进位情况</span><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length() || i &lt; b.length(); i++) &#123;<br>        <span class="hljs-comment">// 按位累加</span><br>        <span class="hljs-keyword">if</span> (i &lt; a.length()) t += a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; b.length()) t += b.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        sb.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-number">0</span>) sb.append(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing792-高精度减法"><a href="#Acwing792-高精度减法" class="headerlink" title="Acwing792_高精度减法"></a>Acwing792_高精度减法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sub</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-comment">// 默认 a &gt; b</span><br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录借位情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        t -= a[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; b.length()) <br>            t -= b[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <span class="hljs-comment">// 此时t若小于0则发生借位, t若大于0则没发生借位</span><br>        <span class="hljs-comment">// (t + 10) % 10, 可以保证无论是否发生借位都可以是正数</span><br>        sb.append((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);   <span class="hljs-comment">// 核心步骤</span><br>        t = t &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = sb.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index--;<br>    <br>    sb.delete(index + <span class="hljs-number">1</span>, sb.length());<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing793-高精度乘法"><a href="#Acwing793-高精度乘法" class="headerlink" title="Acwing793_高精度乘法"></a>Acwing793_高精度乘法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    情况1：大数 x 个位数</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    t += A[i] * b;  t /= 10;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br><br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        t += (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * b;<br><br>        res.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果此时 t == 87, 需要先添加7, 再添加8</span><br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-number">0</span>) &#123;<br>        sb.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 12345 x 0, 会存在前导0</span><br>    <span class="hljs-keyword">int</span> index = sb.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index--;<br>    <br>    sb = sb.delete(index + <span class="hljs-number">1</span>, sb.length());<br>    <br>    <span class="hljs-keyword">return</span> res.reverse().toString();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    情况2: 大数 x 大数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    c[i+j] += a[i] * b[j];</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul2</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length() + b.length()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.length(); j++) &#123;<br>            c[i][j] += (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (b.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理数组c的进位</span><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.length; i++) &#123;<br>        c[i] = (c[i] + t) % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = c.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; c[index] == <span class="hljs-number">0</span>)<br>        index--;<br>    <br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &gt;= <span class="hljs-number">0</span>; i--)<br>        sb.append(c[i]);<br><br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing794-高精度除法"><a href="#Acwing794-高精度除法" class="headerlink" title="Acwing794_高精度除法"></a>Acwing794_高精度除法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    高精度 / 低精度</span><br><span class="hljs-comment">    核心思想： r = r * 10 + A[i];  r / 10;  r %= b;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 保存余数</span><br><span class="hljs-keyword">int</span>[] res; <span class="hljs-comment">// 保存商</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">div</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        r = r * <span class="hljs-number">10</span> + (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        sb.append(r / b);<br>        r %= b;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除商的前导0</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; sb.length() - <span class="hljs-number">1</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index++;<br><br>    <span class="hljs-comment">// [index, sb.length() - 1]</span><br>    res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sb.length() - index];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; sb.length(); i++)<br>        res[k++] = sb.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    高精度 / 高精度</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>高精度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2021/03/04/Acwing/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2021/03/04/Acwing/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="二分法思想"><a href="#二分法思想" class="headerlink" title="二分法思想"></a>二分法思想</h2><blockquote><p>二分法常用于有序状态的数组中，通过中点值与条件的比较一下筛选掉一半的处理规模，从而使时间复杂度从O(N)降到O(logN)</p></blockquote><blockquote><ul><li>整数二分</li><li>小数二分</li></ul></blockquote><h3 id="Acwing789-数的范围"><a href="#Acwing789-数的范围" class="headerlink" title="Acwing789_数的范围"></a>Acwing789_数的范围</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    元素k的起始位置和终止位置，没找到则返回[-1, -1]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1、寻找 &gt;= k 的左边界l和 &lt;= k 的右边界r</span><br><span class="hljs-comment">    2、如果边界处的值不等于k, 则说明k不存在</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] num_score(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <br>    <span class="hljs-comment">// 寻找 &gt;= k 的左边界</span><br>    <span class="hljs-keyword">int</span> l1 = <span class="hljs-number">0</span>, r1 = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l1 &lt; r1) &#123;<br>        <span class="hljs-keyword">int</span> mid1 = (l1 + r1) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 如果中点处的值 &gt;= k, 则缩小右边界的范围，因为[mid1, r1]肯定都 &gt;= k</span><br>        <span class="hljs-keyword">if</span> (nums[mid1] &gt;= k)<br>            r1 = mid1;<br>        <span class="hljs-comment">// 否则说明[l1, mid1]都 &lt; k, 那么 &gt;= k的左边界只可能在[mid1 + 1, r1]之间</span><br>        <span class="hljs-keyword">else</span><br>            l1 = mid1 + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果边界处的值不等于k则说明元素不存在</span><br>    <span class="hljs-keyword">if</span> (nums[l1] != k)  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-comment">// 寻找 &lt;= k 的右边界</span><br>    <span class="hljs-keyword">int</span> l2 = <span class="hljs-number">0</span>, r2 = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l2 &lt; r2) &#123;<br>        <span class="hljs-comment">// 如果是使得l = mid, 则应该 + 1</span><br>        <span class="hljs-keyword">int</span> mid2 = (l2 + r2 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 如果中点处的值 &lt;= k, 则缩小右边界的范围，因为[l2, mid2]肯定都 &lt;= k</span><br>        <span class="hljs-keyword">if</span> (nums[mid2] &lt;= k)<br>            l2 = mid1;<br>        <span class="hljs-comment">// 否则说明[mid2, r2]都 &gt; k, 那么 &gt;= k的左边界只可能在[l2, mid2 - 1]之间</span><br>        <span class="hljs-keyword">else</span><br>            l2 = mid2 - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l1, l2&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing790-数的三次方根"><a href="#Acwing790-数的三次方根" class="headerlink" title="Acwing790_数的三次方根"></a>Acwing790_数的三次方根</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    计算数的三次方根</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">three_sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> l = -<span class="hljs-number">100</span>, r = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 通过精度来控制循环, 一半比要求的精度低两个数量级</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1e-8</span>) &#123;<br>        <span class="hljs-keyword">double</span> mid = (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">double</span> t = mid * mid * mid;<br>        <span class="hljs-keyword">if</span> (t &lt; target)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <br>    System.out.printf(<span class="hljs-string">&quot;%.6f&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>二分法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/03/04/Acwing/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/04/Acwing/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="归并排序的思想"><a href="#归并排序的思想" class="headerlink" title="归并排序的思想"></a>归并排序的思想</h2><blockquote><p>归并排序是基于 <strong>分治</strong> 和 <strong>递归</strong> 的思想。</p><ul><li>选取数组中间点为分割点</li><li>递归排序左子数组和右子数组</li><li>归并两个有序的子数组</li></ul></blockquote><h3 id="Acwing787-归并排序模板"><a href="#Acwing787-归并排序模板" class="headerlink" title="Acwing787_归并排序模板"></a>Acwing787_归并排序模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：子数组无元素或只剩一个元素</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 选取中间点作为分割点</span><br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 递归排序左右数组</span><br>    merge_sort(nums, l, mid);<br>    merge_sort(nums, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">// 归并两个有序数组</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j])<br>            temp[k++] = nums[i++];<br>        <span class="hljs-keyword">else</span><br>            temp[k++] = nums[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)    temp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)   temp[k++] = nums[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        nums[i] = temp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing788-逆序对的数量"><a href="#Acwing788-逆序对的数量" class="headerlink" title="Acwing788_逆序对的数量"></a>Acwing788_逆序对的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用归并排序的思想，在归并两个有序数组的时候对逆序对进行累加</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N * logN)</span><br><span class="hljs-comment">    空间复杂度：O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 返回数组区间[l, r]的逆序对数量</span><br><span class="hljs-comment">// 那么总的逆序对为 左边的逆序对 + 右边的逆序对 + 左右数组形成的逆序对</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">mergeSort_findReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：数组无元素或只有一个元素无法形成逆序对，返回0</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 累加左数组的逆序对和右数组的逆序对</span><br>    <span class="hljs-keyword">long</span> res = mergeSort_findReverse(nums, l, mid) + mergeSort_findReverse(nums, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">// 两个有序数组归并的过程中继续累加逆序对</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>            temp[k++] = nums[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// i &lt; j 但是 nums[i] &gt; nums[j], 则[i, mid]均大于nums[j]</span><br>            temp[k++] = nums[j++];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)    temp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)   temp[k++] = nums[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        nums[i] = temp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/03/04/Acwing/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/04/Acwing/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="快排的思想"><a href="#快排的思想" class="headerlink" title="快排的思想"></a>快排的思想</h2><blockquote><p>快速排序是基于 <strong>分治</strong> 和 <strong>递归</strong> 的思想。</p><ul><li>选取分界点x。</li><li>双指针处理，使得 &lt;= x 的都在左边， &gt;= x 的都在右边。</li><li>递归排序左右子数组, 递归出口为子数组无元素或只有一个元素。</li></ul></blockquote><h3 id="Acwing785-快排模板"><a href="#Acwing785-快排模板" class="headerlink" title="Acwing785_快排模板"></a>Acwing785_快排模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    时间复杂度: O(N ^ logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：子数组无元素或只剩一个元素</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 1、选取数组中存在的值作为分界值</span><br>    <span class="hljs-keyword">int</span> x = nums[l + (r - l) / <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 2、保证 &lt;= x 的都在左边， &gt;= x 的都在右边</span><br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br><br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> t = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3、递归处理左右子数组</span><br>    quick_sort(nums, l, j);<br>    quick_sort(nums, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing786-寻找第k小的数"><a href="#Acwing786-寻找第k小的数" class="headerlink" title="Acwing786_寻找第k小的数"></a>Acwing786_寻找第k小的数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于快排的思想将小的数放在数组右边，大的数放在数组左边</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    当右子数组长度 len &gt;= k时，说明第k大的数是右数组的第k大的数</span><br><span class="hljs-comment">    当右子数组长度 len &lt; k时, 说明第k大的数是左数组的第(k - len)大的数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    递归的向相应的子数组中寻找，直到数组中只剩下一个元素则为目标值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 当只剩下一个数的时候，说明找到了第K小的数</span><br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> arr[l];<br>    <br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> target = arr[(l + r) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (arr[i] &lt; target);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (arr[j] &gt; target);<br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> len = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (len &gt;= k)<br>        <span class="hljs-keyword">return</span> findKth(arr, l, j, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findKth(arr, j + <span class="hljs-number">1</span>, r, k - len);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
