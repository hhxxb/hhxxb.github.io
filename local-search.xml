<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试题之Redis</title>
    <link href="/2021/04/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BRedis/"/>
    <url>/2021/04/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BRedis/</url>
    
    <content type="html"><![CDATA[<h3 id="Redis支持哪几种数据类型"><a href="#Redis支持哪几种数据类型" class="headerlink" title="Redis支持哪几种数据类型"></a>Redis支持哪几种数据类型</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">string</span><br>hash<br><span class="hljs-built_in">list</span><br><span class="hljs-keyword">set</span><br>zset<br></code></pre></td></tr></table></figure><h3 id="Redis数据淘汰机制"><a href="#Redis数据淘汰机制" class="headerlink" title="Redis数据淘汰机制"></a>Redis数据淘汰机制</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs processing">过期策略：我们在设置<span class="hljs-built_in">key</span>的时候如果设置了一个过期时间，到了过期时间这个<span class="hljs-built_in">key</span>就应该失效，按道理来说这些失效的<span class="hljs-built_in">key</span>就应该从内存中删掉。redis 会将每个设置了过期时间的 <span class="hljs-built_in">key</span> 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 <span class="hljs-built_in">key</span>。除了定时遍历之外，它还会使用惰性策略来删除过期的 <span class="hljs-built_in">key</span>，所谓惰性策略就是在客户端访问这个 <span class="hljs-built_in">key</span> 的时候，redis 对 <span class="hljs-built_in">key</span> 的过期时间进行检查，如果过期了就立即删除。定时删除是集中处理，惰性删除是零散处理。<br>    <span class="hljs-number">1</span>、定期删除：redis默认每秒进行<span class="hljs-number">10</span>次扫描，每次扫描并不是扫描整个<span class="hljs-built_in">key</span>集合，而是采用一种贪心的策略：<br>        (<span class="hljs-number">1</span>) 随机挑选<span class="hljs-number">20</span>个<span class="hljs-built_in">key</span><br>        (<span class="hljs-number">2</span>) 删除其中过期的<span class="hljs-built_in">key</span><br>        (<span class="hljs-number">3</span>) 如果过期<span class="hljs-built_in">key</span>占比超过<span class="hljs-number">1</span>/<span class="hljs-number">4</span>,则重复步骤(<span class="hljs-number">1</span>)<br>        为了防止扫描循环过度，设置扫描时间的上限，默认为<span class="hljs-number">25</span>ms。<br><br>    <span class="hljs-number">2</span>、懒惰删除：客户端在访问这个<span class="hljs-built_in">key</span>的时候才进行过期时间的检查，过期了则删掉。<br>    <br>当redis使用内存超过maxmemory的时候，提供了<span class="hljs-number">8</span>个淘汰策略：<br>    <span class="hljs-number">1</span>、noeviction：对于写请求会拒绝，读请求没有影响。这样可以保证不丢失数据。<br>    <span class="hljs-number">2</span>、allkeys-LRU<br>    <span class="hljs-number">3</span>、allkeys-Random<br>    <span class="hljs-number">4</span>、allkeys-LFU<br>    <span class="hljs-number">5</span>、<span class="hljs-keyword">volatile</span>-LRU<br>    <span class="hljs-number">6</span>、<span class="hljs-keyword">volatile</span>-Random<br>    <span class="hljs-number">7</span>、<span class="hljs-keyword">volatile</span>-LFU<br>    <span class="hljs-number">8</span>、<span class="hljs-keyword">volatile</span>-TTL<br>    <br>    LRU:基于随机采样的近似LRU，每个<span class="hljs-built_in">key</span>维护一个最后访问时间，每次取出<span class="hljs-number">5</span>个<span class="hljs-built_in">key</span>，淘汰最旧一次访问的。<br></code></pre></td></tr></table></figure><h3 id="Redis持久化策略"><a href="#Redis持久化策略" class="headerlink" title="Redis持久化策略"></a>Redis持久化策略</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">方法<span class="hljs-number">1</span>：RDB快照备份<br>    RDB持久化就是将某个时刻的所有数据写到磁盘上，Redis在进行RDB持久化的时候会fork一个子进程，然后父进程继续处理客户端的请求，子进程进行持久化操作。<br>    <br>    刚开始的时候，父进程和子进程共享所有数据段和代码段，在持久化的过程中，子进程不会修改内存的数据结构，但是父进程需要响应客户端的请求来修改内存的数据结构。这个时候就需要利用<span class="hljs-constructor">COW(<span class="hljs-params">copy</span> <span class="hljs-params">on</span> <span class="hljs-params">write</span>)</span>机制来进行数据段页面的分离。<br><br>    具体来说，当父进程对其中一个页面进行修改的时候，会将共享的页面复制一份，然后对复制的页面进行修改，子进程仍然遍历之前的页面。所以对于子进程来说，因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「快照」的原因。接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了。<br><br>方法<span class="hljs-number">2</span>：AOF日志备份<br>    AOF日志记录了自Redis实例创建以来所有的修改指令，相等于增量备份。<br>    Redis 会在收到客户端修改指令后，先进行参数校验，如果没问题，就立即将该指令文本存储到 AOF 日志中，也就是先存到磁盘，然后再执行指令。这样即使遇到突发宕机，已经存储到 AOF 日志的指令进行重放一下就可以恢复到宕机前的状态。<br><br>    随着时间的推移,AOF日志会越来越大，因此需要对AOF进行重写。其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了<br></code></pre></td></tr></table></figure><h3 id="Redis事务机制"><a href="#Redis事务机制" class="headerlink" title="Redis事务机制"></a>Redis事务机制</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">multi<span class="hljs-regexp">/exec/</span>discard/watch<br><br>watch：乐观锁的思想<br>setnx：悲观锁的思想<br></code></pre></td></tr></table></figure><h3 id="Redis为什么快？"><a href="#Redis为什么快？" class="headerlink" title="Redis为什么快？"></a>Redis为什么快？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、完全基于内存<br>2、单线程<br>3、IO多路复用<br></code></pre></td></tr></table></figure><h3 id="Redis是否支持原子性？Redis是否支持回滚？"><a href="#Redis是否支持原子性？Redis是否支持回滚？" class="headerlink" title="Redis是否支持原子性？Redis是否支持回滚？"></a>Redis是否支持原子性？Redis是否支持回滚？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">Redis不支持严格意义上的原子性。对于一个事务中的命令，如果是出现了逻辑错误，比如赋值类型发生错误，Redis是不会检查的，这样的错误即使发生也不影响后面命令的执行。但是如果出现不合法的指令，那么事务就不会执行。<br><br>Redis不支持回滚。因为Redis认为发生了错误都是逻辑上的错误，这个应该在开发阶段就要进行检查。<br></code></pre></td></tr></table></figure><h3 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a>Redis主从同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">增量同步：<br><br>快照同步：<br></code></pre></td></tr></table></figure><h3 id="如何保证缓存和数据库的一致性"><a href="#如何保证缓存和数据库的一致性" class="headerlink" title="如何保证缓存和数据库的一致性"></a>如何保证缓存和数据库的一致性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。<br><br>那么，当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。<br><br>缓存雪崩的主要原因：<br><span class="hljs-code">    1、大量数据同时过期</span><br><span class="hljs-code">    2、Redis故障宕机</span><br><span class="hljs-code"></span><br><span class="hljs-code">解决方案：</span><br><span class="hljs-code">    针对大量数据同时过期：</span><br><span class="hljs-code">        1、均匀设置过期时间</span><br><span class="hljs-code">        2、热点数据永不过期</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    针对Redis故障宕机：</span><br><span class="hljs-code">        1、构建Redis集群</span><br></code></pre></td></tr></table></figure><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xquery">缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起<span class="hljs-built_in">为id</span>为“-<span class="hljs-number">1</span>”的数据<span class="hljs-built_in">或id</span>为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。<br><br>解决方案：<br>   <span class="hljs-number">1</span>、布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>   <span class="hljs-number">2</span>、从缓存取不到的数据，在数据库中也没有取到，这时也可以<span class="hljs-built_in">将key</span>-<span class="hljs-keyword">value</span>对写<span class="hljs-built_in">为key</span>-null，缓存有效时间可以设置短点，如<span class="hljs-number">30</span>秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一<span class="hljs-built_in">个id</span>暴力攻击<br></code></pre></td></tr></table></figure><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。<br><br>解决方案：<br>    1、互斥锁<br>    2、热点数据永不过期<br></code></pre></td></tr></table></figure><h3 id="Redis是如何提供服务的？"><a href="#Redis是如何提供服务的？" class="headerlink" title="Redis是如何提供服务的？"></a>Redis是如何提供服务的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">Redis采用的是基于事件驱动的IO多路复用模式。<br>当一个请求到来时，Redis进程就会被唤醒，接着读取来来自客户端的数据，解析命令，查找命令，并执行命令。<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之Docker</title>
    <link href="/2021/04/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BDocker/"/>
    <url>/2021/04/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BDocker/</url>
    
    <content type="html"><![CDATA[<h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker pull    拉去或更新指定的镜像<br>docker push    将镜像推送到远程仓库<br>docker rm    删除容器<br>docker rmi    删除镜像<br>docker images列出所有镜像<br>docker ps    列出所有容器<br>docker <span class="hljs-builtin-name">run</span>      启动镜像<br>docker stop     暂停容器<br>docker cp       复制文件<br>docker container<span class="hljs-built_in"> port </span>  查看端口映射<br><br>docker <span class="hljs-builtin-name">run</span> -p   端口映射<br>docker <span class="hljs-builtin-name">run</span> -v   目录映射<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发控制</title>
    <link href="/2021/04/17/Go%E8%AF%AD%E8%A8%80/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/04/17/Go%E8%AF%AD%E8%A8%80/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go提供三种并发控制手段：</p><p>Channel：使用channel控制子协程</p><p>WaitGroup：使用信号量机制控制子协程</p><p>Context：使用上下文控制子协程</p></blockquote><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用channel控制子协程的优点是实现简单，缺点是当需要大量创建协程时就需要相同数量的channel，而且对子协程继续派生出来的协程不方便控制<br></code></pre></td></tr></table></figure><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p><strong>适用于：某个goroutine需要等待其他几个gorountine全部完成</strong></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;<br>    state1 [<span class="hljs-number">3</span>]<span class="hljs-keyword">uint32</span>    <span class="hljs-comment">// 维护counter, waiter count, semphpre</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">counter: 当前还未执行结束的goroutie计数器<br>waiter count: 等待goroutine-group结束的goroutine数量，即有多少个等待者<br>semaphore: 信号量<br><br><span class="hljs-function"><span class="hljs-title">Add</span><span class="hljs-params">(delta int)</span></span>: 将delte加到counter中<br><span class="hljs-function"><span class="hljs-title">Wait</span><span class="hljs-params">()</span></span>: waiter count递增<span class="hljs-number">1</span>，并阻塞等待信号量semaphore<br><span class="hljs-function"><span class="hljs-title">Done</span><span class="hljs-params">()</span></span>: counter减<span class="hljs-number">1</span>，按照waiter数值释放相应次数的信号量<br></code></pre></td></tr></table></figure><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p><strong>context对于派生的gorountine有更强的控制力，它可以控制多级的gorountine。</strong></p><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-keyword">bool</span>)<br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>    Err() error<br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">Deadline(): 该方法返回一个deadline和标识是否已设置deadline的bool值，如果没有设置deadline，则ok==<span class="hljs-literal">false</span>,此时deadline为一个初始值的<span class="hljs-built_in">time</span>.<span class="hljs-built_in">Time</span>值。<br><br>Done(): 返回一个channel，需要在<span class="hljs-keyword">select</span>-<span class="hljs-keyword">case</span>中使用，如<span class="hljs-keyword">case</span>&lt;-<span class="hljs-keyword">context</span>.Done():。 当<span class="hljs-keyword">context</span>关闭后，Done()返回一个关闭的通道，关闭的通道仍然可读，据此goroutine可以收到关闭请求；当<span class="hljs-keyword">context</span>还未关闭，Done()返回nil<br><br>Err(): 描述<span class="hljs-keyword">context</span>关闭的原因：① 因deadline关闭， <span class="hljs-keyword">context</span> deadline exceeded; ②因主动关闭， <span class="hljs-keyword">context</span> canceled。 如果未关闭返回nil<br><br>Value(): 不用于控制树状分布的goroutine，而是在它们之间传递消息。<br></code></pre></td></tr></table></figure><h4 id="空context"><a href="#空context" class="headerlink" title="空context"></a>空context</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">context</span>包定义了一个空的<span class="hljs-built_in">context</span>，名为emptyCtx，用于<span class="hljs-built_in">context</span>的根节点，空的<span class="hljs-built_in">context</span>只是简单实现了Context，本身不包含任何值，仅用于其他<span class="hljs-built_in">context</span>的父节点。<br><span class="hljs-built_in">context</span>包定义了一个公用的emptyCtx全局变量，名为<span class="hljs-built_in">background</span>，可以通过<span class="hljs-built_in">context</span>.Background()获取它。<br><br><span class="hljs-built_in">context</span>包提供了四个方法创建不同类型的<span class="hljs-built_in">context</span>，使用这四个方法时如果没有父<span class="hljs-built_in">context</span>，则都需要传入<span class="hljs-built_in">background</span>，即将<span class="hljs-built_in">background</span>作为父节点：<br><span class="hljs-number">1</span>、WithCancel()<br><span class="hljs-number">2</span>、WithDeadline()<br><span class="hljs-number">3</span>、WithTimeout()<br><span class="hljs-number">4</span>、WithValue()<br></code></pre></td></tr></table></figure><h4 id="cacelCtx"><a href="#cacelCtx" class="headerlink" title="cacelCtx"></a>cacelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>    Context<br><br>    mu        sync.Mutex<br>    done      <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;             <span class="hljs-comment">// nil -&gt; chan struct&#123;&#125; -&gt; close chan(context被cancel会将通道关闭)</span><br>    children  <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;     <span class="hljs-comment">// 记录了由此context派生的所有child，如果此context被&quot;cancel&quot;，则所有child会被&quot;cancel&quot;</span><br>    err       error                     <span class="hljs-comment">// 在context被cancel时会指定一个error变量。 errors.New(&quot;context canceled&quot;)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(1) Done()接口的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;<br>        c.done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    &#125;<br><br>    d := c.done<br>    c.mu.UnLock()<br>    <span class="hljs-keyword">return</span> d<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) cancel()接口的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>    c.mu.Lock()<br><br>    c.err = err     <span class="hljs-comment">// 设置一个err，说明关闭原因</span><br>    <span class="hljs-built_in">close</span>(c.done)   <span class="hljs-comment">// 将channel关闭，以此通知派生的context</span><br><br>    <span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;     <span class="hljs-comment">// 遍历所有child，逐个调用cancel方法</span><br>        child.cancel(<span class="hljs-literal">false</span>, err)<br>    &#125;<br><br>    c.children = <span class="hljs-literal">nil</span><br>    c.mu.Unlock()<br><br>    <span class="hljs-keyword">if</span> removeFromParent &#123;               <span class="hljs-comment">// 正常情况下，需要将自己从parent中删除</span><br>        removeChild(c.Context, c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3) WithCancel()的实现</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1</span>、初始化一个cancelCtx实例<br><span class="hljs-number">2</span>、将cancelCtx实例添加到其父节点的children中（前提是父节点也可以被<span class="hljs-built_in">cancel</span>）<br><span class="hljs-number">3</span>、返回cancelCtx实例和<span class="hljs-built_in">cancel</span>()方法<br><br>将自身添加到父节点的过程：<br>    <span class="hljs-number">1</span>、如果父节点可以被<span class="hljs-built_in">cancel</span>，那么加入到父节点的children中即可<br>    <span class="hljs-number">2</span>、如果父节点不支持<span class="hljs-built_in">cancel</span>，则继续向上查询直到找到一个支持<span class="hljs-built_in">cancel</span>的节点并加入到该节点的children中<br>    <span class="hljs-number">3</span>、如果所有的父节点都不支持<span class="hljs-built_in">cancel</span>，则启动一个协程等待父节点的结束，再把当前context结束。<br></code></pre></td></tr></table></figure><p>(4) 一个典型的使用案例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    HandelRequest()处理某个请求，它又会创建两个协程，分别处理WriteRedis()和WriteDatabase()。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    main协程创建context,并把context在各子协程间传递，main协程在适当的时机可以&quot;cancel&quot;掉所有子协程。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandelRequest</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">go</span> WriteDatabase(ctx)<br><span class="hljs-keyword">go</span> WriteRedis(ctx)<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;handelrequest done&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;handeling&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteRedis</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;WriteRedis Done.&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;WriteRedis running&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteDatabase</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;WriteDatabase done&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;WriteDatabase running&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> HandelRequest(ctx)<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;its time to stop all subgoroutine&quot;</span>)<br>cancel()<br><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>    cancelCtx<br>    <br>    timer *time.Timer<br><br>    deadline time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>timerCtx在cancelCtx的基础上增加了deadline, 用于标示自动cancel的最终时间, 而timer就是触发自动cancel的定时器。<br>WithDeadline() 和 WithTimeout(), 一个设置的是最终时间，一个设置的是超时时间。本质是一样的。</p><p>(1) Deadline()接口的实现</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Deadline</span><span class="hljs-params">()</span></span>仅仅返回 timerCtx<span class="hljs-selector-class">.deadline</span> 而已，具体是由 WithDeadline() 和 WithTimeout() 设置<br></code></pre></td></tr></table></figure><p>(2) cancel()接口的实现</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>继承自cancelCtx, 只需要额外把timer关闭即可。<br>timerCtx关闭后，timerCtx<span class="hljs-selector-class">.cancelCtx</span>.err会存储关闭原因：<span class="hljs-number">1</span>、在deadline之前手动关闭，则于cancelCtx一样。 <span class="hljs-number">2</span>、deadline自动关闭，则显示context deadline exceeded。<br></code></pre></td></tr></table></figure><p>(3) WithDeadline()方法的实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1</span>、初始化一个timerCtx实例<br><span class="hljs-number">2</span>、将timeCtx实例添加到其父节点的children中（父节点也要可以被cancel）<br><span class="hljs-number">3</span>、启动定时器，定时器到期后会自动<span class="hljs-string">&quot;cancel&quot;</span><br><span class="hljs-number">4</span>、返回timerCtx实例和cancel<span class="hljs-literal">()</span>方法<br><br>func <span class="hljs-constructor">WithTimeout(<span class="hljs-params">parent</span> Context, <span class="hljs-params">timeout</span> <span class="hljs-params">time</span>.Duration)</span> (Context, CancelFun) &#123;<br>    return <span class="hljs-constructor">WithDeadline(<span class="hljs-params">parent</span>, <span class="hljs-params">time</span>.Now()</span>.<span class="hljs-constructor">Add(<span class="hljs-params">timeout</span>)</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>    Context<br>    key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(1) Value()接口的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 当前context查不到key时，会向父节点查找，直到找不到返回interface&#123;&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">if</span> c.key == key &#123;<br>        <span class="hljs-keyword">return</span> c.val<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) WithValue()的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span> &#123;<br>    <span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;valueCtx(parent, key, val)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之Go</title>
    <link href="/2021/04/16/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BGo/"/>
    <url>/2021/04/16/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BGo/</url>
    
    <content type="html"><![CDATA[<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">多个<span class="hljs-keyword">defer</span>语句遵循后进先出的原则。<br><span class="hljs-keyword">defer</span>的执行在<span class="hljs-keyword">return</span>语句之后,在函数退出之前。<br><span class="hljs-keyword">defer</span>可以修改函数返回值，对于匿名返回值，修改了返回值对于的局部变量，而没有修改返回值<br>                       对于有名返回值，修改了返回值<br></code></pre></td></tr></table></figure><h4 id="tag的用处"><a href="#tag的用处" class="headerlink" title="tag的用处"></a>tag的用处</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">tag</span> <span class="hljs-title">可以理解为 struct</span> 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。<span class="hljs-keyword">tag</span> <span class="hljs-title">丰富了代码的语义，增强了灵活性。</span><br></code></pre></td></tr></table></figure><h4 id="如何判断字符串切片是否相等？"><a href="#如何判断字符串切片是否相等？" class="headerlink" title="如何判断字符串切片是否相等？"></a>如何判断字符串切片是否相等？</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">方法<span class="hljs-number">1</span>：利用反射 reflect.<span class="hljs-constructor">DeepEqual(<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)</span>, 一般不推荐，反射会导致性能低<br>方法<span class="hljs-number">2</span>：遍历逐个比较<br></code></pre></td></tr></table></figure><h4 id="空的struct-的作用"><a href="#空的struct-的作用" class="headerlink" title="空的struct{}的作用"></a>空的struct{}的作用</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">使用空结构体 <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>&#125; 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。<br><br>比如：使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>&#125; 代替。<br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="init-什么时候执行"><a href="#init-什么时候执行" class="headerlink" title="init()什么时候执行"></a>init()什么时候执行</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">init()函数是Go程序初始化的一部分。由runtime初始化每一个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>初始化顺序为：<span class="hljs-keyword">import</span>-&gt;<span class="hljs-keyword">const</span>-&gt;<span class="hljs-keyword">var</span>-&gt;init<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>main()<br></code></pre></td></tr></table></figure><h4 id="Go-语言的局部变量分配在栈上还是堆上？"><a href="#Go-语言的局部变量分配在栈上还是堆上？" class="headerlink" title="Go 语言的局部变量分配在栈上还是堆上？"></a>Go 语言的局部变量分配在栈上还是堆上？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">具体是由编译器决定的，编译器会做逃逸分析。如果发现一个变量的作用域没有超出函数范围，则可以分配到栈上，否则必须分配到堆上。<br></code></pre></td></tr></table></figure><h4 id="两个interface可以比较嘛？"><a href="#两个interface可以比较嘛？" class="headerlink" title="两个interface可以比较嘛？"></a>两个interface可以比较嘛？</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Go语言中，<span class="hljs-keyword">interface</span>维护了两个字段，类型<span class="hljs-symbol">T</span>和值<span class="hljs-symbol">V</span>。类型<span class="hljs-symbol">V</span>记录了值<span class="hljs-symbol">T</span>所属的类型，值<span class="hljs-symbol">V</span>指向了具体的结构。<br><br>当两个<span class="hljs-symbol">interface</span>均为<span class="hljs-symbol">nil</span> 或者 <span class="hljs-symbol">T</span>和<span class="hljs-symbol">V</span>都一致，则为相等。<br></code></pre></td></tr></table></figure><h4 id="两个struct可以比较嘛？"><a href="#两个struct可以比较嘛？" class="headerlink" title="两个struct可以比较嘛？"></a>两个struct可以比较嘛？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">结构体可以比较，前提是：内部字段一样，而且所有字段均可比较。<br></code></pre></td></tr></table></figure><h4 id="两个-nil-可能不相等嘛？"><a href="#两个-nil-可能不相等嘛？" class="headerlink" title="两个 nil 可能不相等嘛？"></a>两个 nil 可能不相等嘛？</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">可能不相等，当一个接口值和一个非接口值进行比较的时候，会将非接口值转化为接口值再比较，而我们知道一个接口是维护了两个信息的，一个类型<span class="hljs-built_in">T</span>和值V，就算两个V都是nil，但是类型<span class="hljs-built_in">T</span>不一致，也会导致不相等。<br></code></pre></td></tr></table></figure><h4 id="Go的GC原理"><a href="#Go的GC原理" class="headerlink" title="Go的GC原理"></a>Go的GC原理</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Go</span>的<span class="hljs-selector-tag">GC</span>采用的是标记<span class="hljs-selector-tag">-</span>清除法，并在此基础上使用了三色标记法和写屏障技术，提高了效率。<br><br>标记<span class="hljs-selector-tag">-</span>清除法分为两个阶段：<br>    <span class="hljs-selector-tag">1</span>、标记阶段：从根对象出发查找并标记堆中所有存活的对象；<br>    <span class="hljs-selector-tag">2</span>、清除阶段：遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。<br><br>标记<span class="hljs-selector-tag">-</span>清除法有个最大的问题就是：在标记阶段需要<span class="hljs-selector-tag">STW</span>的暂停时间，标记结束之后用户程序才可以继续执行。为了能够异步执行，减少 <span class="hljs-selector-tag">STW</span> 的时间，<span class="hljs-selector-tag">Go</span> 语言采用了三色标记法。<br><br>三色标记算法将程序中的对象分成白色、黑色和灰色三类。<br>    白色：不确定对象。<br>    灰色：存活对象，子对象待处理。<br>    黑色：存活对象。<br><br>标记开始时，所有对象加入白色集合（这一步需 <span class="hljs-selector-tag">STW</span> ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。<br><br>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。但是三色标记法并发执行仍存在一个问题，即在 <span class="hljs-selector-tag">GC</span> 过程中，对象指针发生了改变，可能会造成一些对象遗漏。<br><br>比如初始过程：<span class="hljs-selector-tag">A</span>(黑)<span class="hljs-selector-tag">-</span>&gt;<span class="hljs-selector-tag">B</span>(灰)<span class="hljs-selector-tag">-</span>&gt;<span class="hljs-selector-tag">C</span>(白)<span class="hljs-selector-tag">-</span>&gt;<span class="hljs-selector-tag">D</span>(白)，正常情况，<span class="hljs-selector-tag">D</span>最终会被染成黑色。但是并发执行过程中，<span class="hljs-selector-tag">C-</span>&gt;<span class="hljs-selector-tag">D</span>的引用删除了，增加了<span class="hljs-selector-tag">A</span><span class="hljs-selector-tag">-</span>&gt;<span class="hljs-selector-tag">D</span>的引用，但是<span class="hljs-selector-tag">A</span>已经被染成黑色了，那么<span class="hljs-selector-tag">D</span>就没法处理了。<br><br>为了解决以上问题，垃圾收集器使用了写屏障（<span class="hljs-selector-tag">Write</span> <span class="hljs-selector-tag">Barrier</span>）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。<br><br>整体过程如下：<br>    <span class="hljs-selector-tag">1</span>）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)<br>    <span class="hljs-selector-tag">2</span>）使用三色标记法标记（<span class="hljs-selector-tag">Marking</span>, 并发）<br>    <span class="hljs-selector-tag">3</span>）标记结束(Mark Termination，需 STW)，关闭写屏障。<br>    <span class="hljs-selector-tag">4</span>）清理(Sweeping, 并发)<br></code></pre></td></tr></table></figure><h4 id="Slice的底层原理"><a href="#Slice的底层原理" class="headerlink" title="Slice的底层原理"></a>Slice的底层原理</h4><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dos">Slice的底层和一个数组关联起来，它维护了三个信息：指向数组的指针，切片长度，切片容量。<br><br>使用<span class="hljs-built_in">append</span>()向切片添加元素时，如果空间不足则会触发扩容操作。扩容的本质是分配一块更大的内存，将原切片的数据拷贝到新的切片，然后返回新的切片。<br><br>扩容策略：<br>    当容量 &lt; <span class="hljs-number">1024</span>, 则会翻倍。<br>    当容量 &gt; <span class="hljs-number">1024</span>, 增加<span class="hljs-number">25</span>%。<br><br>使用<span class="hljs-built_in">copy</span>()拷贝两个切片时，会逐个将源切片的数据拷贝到目的切片指向的数组中，数量取两个切片长度的最小值。<br>因此<span class="hljs-built_in">copy</span>()不会发送扩容。<br></code></pre></td></tr></table></figure><h4 id="map的底层原理"><a href="#map的底层原理" class="headerlink" title="map的底层原理"></a>map的底层原理</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">map</span>的整体思想还是数组+链表的链地址法思想。<br><br>hmap结构体维护以下信息：元素个数/bucket的大小/bucket数组/旧的bucket数组<br><br>比如现在bucket的大小B是<span class="hljs-number">8</span>，那么bucket数组的容量是<span class="hljs-number">2</span>^<span class="hljs-number">8</span>, 因此用hash值的后<span class="hljs-number">8</span>位来决定放到哪个桶中。<br><br>每个桶维护以下信息：tophash/data/<span class="hljs-built_in">overflow</span><br>tophash数组的作用是保存hash值的高<span class="hljs-number">8</span>位。<br>data存放所有的键值对，最多放<span class="hljs-number">8</span>对。<br><span class="hljs-built_in">overflow</span>指向下一个桶。<br><br>扩容条件：<br>    <span class="hljs-number">1</span>、负载因子大于<span class="hljs-number">6.5</span><br>    <span class="hljs-number">2</span>、<span class="hljs-built_in">overflow</span>的数量 &gt; <span class="hljs-number">2</span>^<span class="hljs-number">15</span><br><br>扩容策略：<br>    <span class="hljs-number">1</span>、增量扩容<br>    <span class="hljs-number">2</span>、等量扩容<br></code></pre></td></tr></table></figure><h4 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Go</span>的协程调度包含三个重要的实体：<span class="hljs-selector-tag">G</span>、<span class="hljs-selector-tag">M</span>、<span class="hljs-selector-tag">P</span><br><span class="hljs-selector-tag">G</span>是<span class="hljs-selector-tag">Go</span>协程、<span class="hljs-selector-tag">M</span>是工作线程、<span class="hljs-selector-tag">P</span>是协程调度器。<br><br>每个<span class="hljs-selector-tag">M</span>必须持有一个<span class="hljs-selector-tag">P</span>才能够执行程序，每个<span class="hljs-selector-tag">P</span>维护了一个局部的<span class="hljs-selector-tag">G</span>队列，每次从<span class="hljs-selector-tag">G</span>队列中取出一个协程放到<span class="hljs-selector-tag">M</span>中执行。与此同时，还有一个所有<span class="hljs-selector-tag">P</span>都共享的全局<span class="hljs-selector-tag">G</span>队列，每个<span class="hljs-selector-tag">P</span>周期性的从全局的<span class="hljs-selector-tag">G</span>队列中取出<span class="hljs-selector-tag">Go</span>协程执行。<br><br><span class="hljs-selector-tag">Go</span>的协程调度提供了一些调度策略：<br>(<span class="hljs-number">1</span>) 队列轮转：防止<span class="hljs-selector-tag">G</span>全局队列处于饥饿状态。<br>    每个<span class="hljs-selector-tag">P</span>维护一个局部的协程<span class="hljs-selector-tag">G</span>队列，<span class="hljs-selector-tag">P</span>依次将<span class="hljs-selector-tag">G</span>调度到<span class="hljs-selector-tag">M</span>中执行。<br>    同时每个<span class="hljs-selector-tag">P</span>会周期性的查看全局队列中是否有<span class="hljs-selector-tag">G</span>等待运行，如果有则调度到<span class="hljs-selector-tag">M</span>中执行，以防止全局队列中的<span class="hljs-selector-tag">G</span>处于饥饿状态。全局<span class="hljs-selector-tag">G</span>队列主要来自于从系统调用中恢复的<span class="hljs-selector-tag">G</span>。<br><br>(<span class="hljs-number">2</span>) 系统调用<br>    我们知道，当线程在执行系统调用时会发生阻塞，对应到调度器模型中，如果一个线程陷入阻塞状态，那么对应的<span class="hljs-selector-tag">P</span>的<span class="hljs-selector-tag">G</span>队列中的所有协程都得不到调度从而陷入阻塞。<br>    针对这种情况，有以下策略：  当一个<span class="hljs-selector-tag">G0</span>即将进入系统调用时，对应的<span class="hljs-selector-tag">M0</span>会释放<span class="hljs-selector-tag">P0</span>，从而某个冗余的<span class="hljs-selector-tag">M1</span>会获取<span class="hljs-selector-tag">P0</span>，继续执行队列中剩下的<span class="hljs-selector-tag">G</span>。当<span class="hljs-selector-tag">G0</span>结束系统调用后，如果<span class="hljs-selector-tag">M0</span>可以获取到一个空闲的<span class="hljs-selector-tag">P</span>，则继续执行<span class="hljs-selector-tag">G0</span>，否则将<span class="hljs-selector-tag">G0</span>放入全局队列中，将<span class="hljs-selector-tag">M0</span>放入缓存池中。<br><br>(<span class="hljs-number">3</span>) 工作量窃取<br>    针对有些处理器<span class="hljs-selector-tag">P</span>很繁忙，有些<span class="hljs-selector-tag">P</span>很空闲的情况，有以下策略：当一个处理器<span class="hljs-selector-tag">P</span>没有任务需要调度时，它会查询全局队列是否有协程需要调度，有则调度，否则从另一个正在运行的处理器中维护的局部<span class="hljs-selector-tag">G</span>队列中窃取协程，每次偷取一半。<br><br>(<span class="hljs-number">4</span>) 抢占式调度<br>    当某个协程执行时间过长，<span class="hljs-selector-tag">P</span>会暂停该协程的执行，转而调度其他等待的协程。类似时间片轮转的策略。<br></code></pre></td></tr></table></figure><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="有缓冲channel和无缓冲channel的区别"><a href="#有缓冲channel和无缓冲channel的区别" class="headerlink" title="有缓冲channel和无缓冲channel的区别"></a>有缓冲channel和无缓冲channel的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">对于无缓冲channel,发送方发送数据会阻塞直到接收方接收数据，接收方接收数据会阻塞直到发送方发送数据<br><br>对于有缓冲channel, 发送方发送数据，如果缓冲区满了则会阻塞，接收方接收数据，如果缓冲区空了则会阻塞。<br></code></pre></td></tr></table></figure><h4 id="互斥锁-和-读写锁"><a href="#互斥锁-和-读写锁" class="headerlink" title="互斥锁 和 读写锁"></a>互斥锁 和 读写锁</h4>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>Go语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2021/04/16/Go%E8%AF%AD%E8%A8%80/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/04/16/Go%E8%AF%AD%E8%A8%80/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><blockquote><p>Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。</p><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><p>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</p><p>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</p><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p></blockquote><h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">灰色：对象还在标记队列中等待<br>黑色：对象已经被标记，不会被清理<br>白色：对象未被标记，会被清理<br><br>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。<br><br>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。但是三色标记法并发执行仍存在一个问题，即在 <span class="hljs-built_in">GC</span> 过程中，如果对象指针发生了改变，可能会造成某些对象错误回收，因此利用了写屏障的机制，可以让<span class="hljs-built_in">GC</span>和goroutine安全的并发运行。<br></code></pre></td></tr></table></figure><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less">写屏障（<span class="hljs-selector-tag">Write</span> <span class="hljs-selector-tag">Barrier</span>）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。<br><br>一次完整的 <span class="hljs-selector-tag">GC</span> 分为四个阶段：<br><br><span class="hljs-selector-tag">1</span>）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)<br><span class="hljs-selector-tag">2</span>）使用三色标记法标记（<span class="hljs-selector-tag">Marking</span>, 并发）<br><span class="hljs-selector-tag">3</span>）标记结束(Mark Termination，需 STW)，关闭写屏障。<br><span class="hljs-selector-tag">4</span>）清理(Sweeping, 并发)<br></code></pre></td></tr></table></figure><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><blockquote><p>栈上分配内存比在堆上分配内存效率更高</p><p>栈上的内存不需要GC处理</p><p>堆上分配的内存使用完毕会经过GC处理</p><p>逃逸分析的目的是决定分配在堆上还是栈上</p><p>逃逸分析在编译阶段完成</p></blockquote><h4 id="逃逸策略"><a href="#逃逸策略" class="headerlink" title="逃逸策略"></a>逃逸策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">在函数中申请的新对象，编译器会根据该对象是否被函数外部引用来决定是否逃逸：<br>    1、没有引用，优先放在栈上。（消耗内存过大超过栈的空间，放在堆中）<br>    2、被引用了，必定放在堆上。<br></code></pre></td></tr></table></figure><h4 id="逃逸场景"><a href="#逃逸场景" class="headerlink" title="逃逸场景"></a>逃逸场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>、指针逃逸<br><br><span class="hljs-number">2</span>、栈空间不足<br><br><span class="hljs-number">3</span>、动态类型逃逸, 参数为<span class="hljs-class"><span class="hljs-keyword">interface</span></span>&#123;&#125;<br><br><span class="hljs-number">4</span>、闭包引用对象逃逸<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径问题</title>
    <link href="/2021/04/16/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/16/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Dijkstra算法-带权图的单源最短路径"><a href="#Dijkstra算法-带权图的单源最短路径" class="headerlink" title="Dijkstra算法: 带权图的单源最短路径"></a>Dijkstra算法: 带权图的单源最短路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不能处理负权边</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最短路径问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协程</title>
    <link href="/2021/04/16/Go%E8%AF%AD%E8%A8%80/%E5%8D%8F%E7%A8%8B/"/>
    <url>/2021/04/16/Go%E8%AF%AD%E8%A8%80/%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="调度模型"><a href="#调度模型" class="headerlink" title="调度模型"></a>调度模型</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">Go的调度器模型包含三个关键的实体： G M <span class="hljs-selector-tag">P</span><br>G：Go协程<br><span class="hljs-selector-tag">P</span>：协程调度器<br>M：工作线程<br><br>GOMAXPROCS可以设置<span class="hljs-selector-tag">P</span>的个数，一般来说M的个数略大于<span class="hljs-selector-tag">P</span>。<br><br>每个M必须持有一个<span class="hljs-selector-tag">P</span>才能够执行代码，每个<span class="hljs-selector-tag">P</span>维护了一个局部的G队列，<span class="hljs-selector-tag">P</span>每次将从局部G队列中取出一个Go协程放入到与之管理的M线程中执行。<br>与此同时，每个处理器还共享一个全局的G队列，每个<span class="hljs-selector-tag">P</span>周期性的从全局的G队列中取出Go协程执行。<br></code></pre></td></tr></table></figure><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>(1) 队列轮转<br>    每个P维护一个局部的协程G队列，P依次将G调度到M中执行。<br>    同时每个P会周期性的查看全局队列中是否有G等待运行，如果有则调度到M中执行，以防止全局队列中的G处于饥饿状态。全局G队列主要来自于从系统调用中恢复的G。</p><p>(2) 系统调用<br>    我们知道，当线程在执行系统调用时会发生阻塞，对应到调度器模型中，如果一个线程陷入阻塞状态，那么对应的P的G队列中的所有协程都得不到调度从而陷入阻塞。<br>    针对这种情况，有以下策略：  当一个G0即将进入系统调用时，对应的M0会释放P0，从而某个冗余的M1会获取P0，继续执行队列中剩下的G。当G0结束系统调用后，如果M0可以获取到一个空闲的P，则继续执行G0，否则将G0放入全局队列中，将M0放入缓存池中。</p><p>(3) 工作量窃取<br>    针对有些处理器P很繁忙，有些P很空闲的情况，有以下策略：当一个处理器P没有任务需要调度时，它会查询全局队列是否有协程需要调度，有则调度，否则从另一个正在运行的处理器中维护的局部G队列中窃取协程，每次偷取一半。</p><p>(4) 抢占式调度<br>    当某个协程执行时间过长，P会暂停该协程的执行，转而调度其他等待的协程。类似时间片轮转的策略。</p>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>select</title>
    <link href="/2021/04/16/Go%E8%AF%AD%E8%A8%80/select/"/>
    <url>/2021/04/16/Go%E8%AF%AD%E8%A8%80/select/</url>
    
    <content type="html"><![CDATA[<blockquote><p>select只能作用于管道，包括数据读取和写入</p><p>select的每个case只能操作一个管道，要么写入要么读取。如果管道中没有数据读取则会陷入阻塞，如果管道中没有空闲的缓冲区写入则会陷入阻塞。</p><p>当select的多个case均阻塞时，整个select会陷入阻塞。（没有default的情况下）</p><p>当select的多个case均没有阻塞，则会随机挑选一个case执行</p><p>select{}会陷入永久阻塞</p></blockquote><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> scase <span class="hljs-keyword">struct</span> &#123;<br>    c       *hchan          <span class="hljs-comment">// 操作的管道</span><br>    kind    <span class="hljs-keyword">uint16</span>          <span class="hljs-comment">// case类型</span><br>    elem    unsafe.Pointer  <span class="hljs-comment">// data elem</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>(1) 管道</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">scase结构体中的 c 字段指向了操作的管道，因此一个<span class="hljs-keyword">case</span>只能对应一个管道。如果<span class="hljs-keyword">case</span>中没有管道操作，那么会出现编译错误。<br></code></pre></td></tr></table></figure><p>(2) 类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span>语句的类型包括: 管道的值为<span class="hljs-literal">nil</span>、读管道、写管道、<span class="hljs-keyword">default</span>。<br>由于<span class="hljs-literal">nil</span>管道既不可以读，也不可以写，因此会被忽略。所以在<span class="hljs-keyword">case</span>语句中向值为<span class="hljs-literal">nil</span>的管道写数据不会触发<span class="hljs-built_in">panic</span><br></code></pre></td></tr></table></figure><p>(3) 数据</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">scase结构体中的elem表示数据的存放地址。<br>在类型为<span class="hljs-keyword">case</span>Recv的<span class="hljs-keyword">case</span>中，elem表示从管道读取数据的地址<br>在类型为<span class="hljs-keyword">case</span>Send的<span class="hljs-keyword">case</span>中，elem表示向管道写入数据的地址<br></code></pre></td></tr></table></figure><h4 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// selectgo()来随机选取未陷入阻塞的case执行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectgo</span><span class="hljs-params">(case0 *scase, order0 *<span class="hljs-keyword">uint16</span>, ncase <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>)</span></span><br></code></pre></td></tr></table></figure><p>1、通过随机函数将原始的case顺序打乱，使用打乱后的顺序就会表现随机性<br>2、遍历过程中如果发现某个case就绪就会跳出循环，并进行管道操作并返回<br>3、如果一直没有跳出循环，说明所有case均阻塞，则会走default的分支。<br>4、如果没有default分支，则select会陷入阻塞，等待所有管道，直到有管道就绪再开始新的循环。</p>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>select</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/2021/04/15/Go%E8%AF%AD%E8%A8%80/map/"/>
    <url>/2021/04/15/Go%E8%AF%AD%E8%A8%80/map/</url>
    
    <content type="html"><![CDATA[<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 字面量初始化</span><br>m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span> &#123;<br>    <span class="hljs-string">&quot;apple&quot;</span> : <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;banana&quot;</span> : <span class="hljs-number">1</span>,<br>&#125;<br><br><span class="hljs-comment">// make()初始化</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 仅声明的map的值为nil：进行添加操作会触发panic</span><br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// map的增删改查</span><br><span class="hljs-keyword">map</span>[<span class="hljs-string">&quot;fruit&quot;</span>] = <span class="hljs-number">3</span><br><span class="hljs-keyword">map</span>[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">4</span><br><span class="hljs-built_in">delete</span>(<span class="hljs-keyword">map</span>, <span class="hljs-string">&quot;fruit&quot;</span>)<br>v, exist := <span class="hljs-keyword">map</span>[<span class="hljs-string">&quot;apple&quot;</span>]    <span class="hljs-comment">// 如果不存在exist返回false, v为默认值</span><br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    count       <span class="hljs-keyword">int</span>             <span class="hljs-comment">// 元素个数</span><br>    B           <span class="hljs-keyword">uint8</span>           <span class="hljs-comment">// bucket数组的大小</span><br>    buckets     unsafe.Pointer  <span class="hljs-comment">// bucket数组，长度为2^B</span><br>    oldbuckets  unsafe.Pointer  <span class="hljs-comment">// 旧的bucket数组，用于扩容</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bucket数据结构"><a href="#bucket数据结构" class="headerlink" title="bucket数据结构"></a>bucket数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash   [<span class="hljs-number">8</span>]<span class="hljs-keyword">uint8</span>        <span class="hljs-comment">// 存储Hash值的高8位， 将Hash值低位相同的键存放到当前的bucket时会将高8位存放到该数组</span><br>    data      []<span class="hljs-keyword">byte</span>          <span class="hljs-comment">// 存放key-value数据，方式是: key/key/....key/value/value/.../value. 节省字节对齐带来的空间浪费</span><br>    overflow  *bmap           <span class="hljs-comment">// 指向溢出的bucket的地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">负载因子 </span>=<span class="hljs-string"> 键数量 / bucket数量， 当负载因子 &gt; 6.5会触发扩容。</span><br><span class="hljs-string"></span><br><span class="hljs-string">负载因子太低：空间利用率低</span><br><span class="hljs-string">负载因子太高：冲突严重，存取效率低</span><br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">触发扩容的条件：<br>    1、负载因子 &gt; 6<span class="hljs-selector-class">.5</span><br>    2、<span class="hljs-attribute">overflow</span>的数量 &gt; 2^15 (<span class="hljs-number">32768</span>)<br></code></pre></td></tr></table></figure><h4 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">新建一个bucket数组，长度是原先的两倍，然后旧的bucket数组中的数据逐步搬迁到新的bucket数组中，每次访问<span class="hljs-built_in">map</span>都会搬迁两个键值对。<br></code></pre></td></tr></table></figure><h4 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">bucket容量不变，重新做一遍搬迁工作，将松散的键值对重新排列一次，以使得bucket的使用率更高。这样是针对大量删除的极端场景。<br></code></pre></td></tr></table></figure><h3 id="增删改查步骤"><a href="#增删改查步骤" class="headerlink" title="增删改查步骤"></a>增删改查步骤</h3><h4 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1</span>、根据<span class="hljs-variable">key</span>的值计算<span class="hljs-built_in">Hash</span>值<br><span class="hljs-number">2</span>、取<span class="hljs-built_in">Hash</span>值的低位在<span class="hljs-variable">hmap</span><span class="hljs-operator">.</span><span class="hljs-variable">B</span>中取模确定<span class="hljs-variable">bucket</span>的位置<br><span class="hljs-number">3</span>、取<span class="hljs-built_in">Hash</span>值的高位，在<span class="hljs-variable">tophash</span>数组中查询<br><span class="hljs-number">4</span>、如果<span class="hljs-variable">tophash</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span>的值与当前<span class="hljs-variable">key</span>的<span class="hljs-built_in">Hash</span>值相等，则获取<span class="hljs-variable">tophash</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span>的<span class="hljs-variable">key</span>值进行比较<br><span class="hljs-number">5</span>、当前<span class="hljs-variable">bucket</span>中没有找到，依次从<span class="hljs-variable">overflow</span>的<span class="hljs-variable">bucket</span>中查找<br><br>如果正处于搬迁工作，则优先从<span class="hljs-variable">oldbuckets</span>开始查找。没找到返回值类型的零值<br></code></pre></td></tr></table></figure><h4 id="添加过程"><a href="#添加过程" class="headerlink" title="添加过程"></a>添加过程</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">1</span>、根据<span class="hljs-built_in">key</span>的值计算Hash值<br><span class="hljs-number">2</span>、取Hash值的低位在hmap.B中取模确定bucket的位置<br><span class="hljs-number">3</span>、查找该<span class="hljs-built_in">key</span>是否存在，如果存在则更新值<br><span class="hljs-number">4</span>、如果不存在则在当前bucket中寻找空位插入<br><br>如果<span class="hljs-built_in">map</span>处于搬迁过程中，新元素会添加到新的bucket数组中。<br></code></pre></td></tr></table></figure><h4 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>、查找该<span class="hljs-keyword">key</span>是否存在，存在则删除，不存在则什么也不做<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slice</title>
    <link href="/2021/04/15/Go%E8%AF%AD%E8%A8%80/slice/"/>
    <url>/2021/04/15/Go%E8%AF%AD%E8%A8%80/slice/</url>
    
    <content type="html"><![CDATA[<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 变量声明: 变量为零值nil</span><br><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// 字面量</span><br>s1 := []<span class="hljs-keyword">int</span>&#123;&#125;   <span class="hljs-comment">// 空切片，长度为空，值不为nil</span><br>s2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;   <span class="hljs-comment">// 长度为3，容量为3的切片</span><br><br><span class="hljs-comment">// make函数</span><br>s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">12</span>)       <span class="hljs-comment">// 指定长度</span><br>s4 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>)   <span class="hljs-comment">// 指定长度和容量， 指定长度的同时预估空间可有效较少扩容时内存分配和拷贝次数</span><br><br><span class="hljs-comment">// 切取</span><br>array := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>s5 := array[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]    <span class="hljs-comment">// 从数组中切取</span><br>s6 := s3[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]       <span class="hljs-comment">// 从切片中切取</span><br><br><span class="hljs-comment">// 适用于任何类型的new()</span><br>s := *<span class="hljs-built_in">new</span>([]<span class="hljs-keyword">int</span>)<br></code></pre></td></tr></table></figure><h3 id="append-操作"><a href="#append-操作" class="headerlink" title="append()操作"></a>append()操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>s = <span class="hljs-built_in">append</span>(s, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;...)<br><br><span class="hljs-comment">// 当切片空间不足时，append()会先创建新的大容量切片，添加元素后再返回新的切片</span><br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 切片依托于数组实现，维护了指向数组的指针，切片的长度，切片的容量</span><br><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer<br>    <span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用make()创建切片，创建时底层会分配一个数组，数组的长度即为容量</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 使用数组创建切片，切片与数组共用一部分内存</span><br>slice := array[<span class="hljs-number">5</span>:<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><h4 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h4><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dos">使用<span class="hljs-built_in">append</span>()向切片添加元素时，如果空间不足则会触发扩容操作。扩容的本质是分配一块更大的内存，将原切片的数据拷贝到新的切片，然后返回新的切片。<br><br>扩容的原则：<br>    <span class="hljs-number">1</span>、当原切片的容量小于<span class="hljs-number">1024</span>，则会翻倍。<br>    <span class="hljs-number">2</span>、大于等于<span class="hljs-number">1024</span>则扩大为原来的<span class="hljs-number">1</span>.<span class="hljs-number">25</span>倍<br></code></pre></td></tr></table></figure><h4 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">使用<span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">copy</span></span>()拷贝两个切片时，会逐个将源切片的数据拷贝到目的切片指向的数组中，数量取两个切片长度的最小值。</span><br><span class="hljs-function">因此<span class="hljs-title"><span class="hljs-built_in">copy</span></span>()不会发送扩容。</span><br></code></pre></td></tr></table></figure><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 简单表达式, 长度 high - low, 容量: cap(array) - high</span><br>slice := array[low : high]<br><br><span class="hljs-comment">// 扩展表达式, 长度 high - low, 容量: max - low, 好处是可以限制容量，放置对切片窗口外的底层数组元素进行修改</span><br>slice := array[low : high : max]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>slice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>channel</title>
    <link href="/2021/04/15/Go%E8%AF%AD%E8%A8%80/channel/"/>
    <url>/2021/04/15/Go%E8%AF%AD%E8%A8%80/channel/</url>
    
    <content type="html"><![CDATA[<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 变量声明, 值为nil。读写nil管道都会阻塞掉</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span> <br><br><span class="hljs-comment">// 使用make函数， 无缓冲管道 vs 有缓冲管道</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 只有一个缓冲区的管道，写入数据相当于加锁，读取数据相当于释放锁</span><br>mutex := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 关闭管道. 向关闭的管道写数据会触发panic，读数据则不会</span><br><span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure><h3 id="管道操作"><a href="#管道操作" class="headerlink" title="管道操作"></a>管道操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 读取数据</span><br>&lt;-ch<br><br><span class="hljs-comment">// 写入数据</span><br>ch &lt;- <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 管道默认是双向可读写，也可以声明操作限制管道</span><br>ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 只可读取的管道</span><br>ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 只可写入的管道</span><br><br><span class="hljs-comment">// 读取管道最多可以给两个变量复制</span><br>v1 := &lt;-ch<br>v1, ok := &lt;-ch  <span class="hljs-comment">// ok表示是否成功读取了数据</span><br><br><span class="hljs-comment">// 一个已关闭的管道有两种情况</span><br><span class="hljs-comment">// 情况1：缓冲区没有数据。  如果已经没有数据，则第一个变量为相应类型的零值，第二个变量为false</span><br><span class="hljs-comment">// 情况2：缓冲区还有数据。  如果有数据，则第一个变量为读取到的值，第二个变量为true</span><br></code></pre></td></tr></table></figure><h3 id="无缓冲区channel-和-有缓冲区channel"><a href="#无缓冲区channel-和-有缓冲区channel" class="headerlink" title="无缓冲区channel 和 有缓冲区channel"></a>无缓冲区channel 和 有缓冲区channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">无缓冲区channel，从管道读取数据会阻塞，直到有协程向管道写入数据；向管道写入数据会阻塞，直到有协程从管道读取数据。<br><br>有缓存区channel，从管道读取数据并且管道中没数据则会阻塞，直到有协程向管道写入数据；从管道写入数据并且管道缓冲区已满则会阻塞，直到有协程从管道读取数据。<br><br>对于<span class="hljs-literal">nil</span>值的管道，无论读还是取都会永久阻塞。<br><br><span class="hljs-built_in">close</span>()可以关闭管道，向关闭的管道写入数据会触发<span class="hljs-built_in">panic</span>，但关闭的管道仍然可读。<br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-keyword">uint</span>               <span class="hljs-comment">// 当前队列中剩余元素的个数</span><br>dataqsiz <span class="hljs-keyword">uint</span>               <span class="hljs-comment">// 环形队列长度，即可以存放元素的个数</span><br>buf      unsafe.Pointer     <span class="hljs-comment">// 环形队列指针</span><br>elemsize <span class="hljs-keyword">uint16</span>             <span class="hljs-comment">// 每个元素的大小</span><br>closed   <span class="hljs-keyword">uint32</span>             <span class="hljs-comment">// 管道关闭状态</span><br>elemtype *_type             <span class="hljs-comment">// 元素的类型</span><br>sendx    <span class="hljs-keyword">uint</span>               <span class="hljs-comment">// 队列下标，指示元素写入时存放到队列中的位置</span><br>recvx    <span class="hljs-keyword">uint</span>               <span class="hljs-comment">// 队列下标，指示下一个元素读取时的位置</span><br>sendq    waitq              <span class="hljs-comment">// 等待写消息的协程队列</span><br>recvx    waitq              <span class="hljs-comment">// 等待读消息的协程队列</span><br>lock     mutex              <span class="hljs-comment">// 互斥锁， chan不允许并发读写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(1) 环形链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">channel的缓存区是一个环形队列，有先入先出的性质。维护了队列容量，队列中元素的数量，下一次读取的位置，下一次写入的位置，buf指向该环形队列。<br></code></pre></td></tr></table></figure><p>(2) 等待队列</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">从管道读取元素时，如果管道缓冲区为空或者没有缓冲区，则当前协程会被阻塞，并被加入到<span class="hljs-keyword">recv</span>队列中。<br>向管道写入元素时，如果管道缓冲区满了或者没有缓冲区，则当前协程会被阻塞，并被加入到sendv队列中。<br><br>因读阻塞的协程会被向管道写入数据的协程所唤醒<br>因写阻塞的协程会被向管道读取数据的协程所唤醒<br><br>一般情况下，<span class="hljs-keyword">recv</span>和sendv至少有一个为空。特殊情况：同一个协程用<span class="hljs-keyword">select</span>语句向管道一边写入数据，一边读取数据，此时协程会分别位于两个等待队列中。<br></code></pre></td></tr></table></figure><h4 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">hchan</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c *hchan<br>    c = <span class="hljs-built_in">new</span>(hchan)<br>    c.buf = malloc(元素类型大小 * size)<br>    c.elemsize = 元素类型大小<br>    c.elemtype = 元素类型<br>    c.dataqsiz = size<br><br>    <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="向管道写入数据"><a href="#向管道写入数据" class="headerlink" title="向管道写入数据"></a>向管道写入数据</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">(<span class="hljs-number">1</span>) 如果缓冲区中有空余位置，则将数据写入到缓冲区，结束发送过程；<br>(<span class="hljs-number">2</span>) 如果缓冲区中没有位置，则将当前协程加入到sendq队列，进入睡眠并等待被读管道的协程唤醒。<br><br>在实现时有一个小技巧，当接收等待队列<span class="hljs-keyword">recv</span>不为空时，说明缓冲区没有数据但是有协程在等待数据，此时会把数据直接传递给<span class="hljs-keyword">recv</span>队列中的第一个协程，而不必再写入缓冲区。<br></code></pre></td></tr></table></figure><h4 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) 如果缓冲区有数据，则从缓冲区读取数据，结束读取过程。<br>(<span class="hljs-number">2</span>) 如果缓冲区没有数据，则将当前协程加入到recvq队列，进入睡眠并等待写管道的协程唤醒<br><br>如果等待发送队列sendq不为空且没有缓冲区，则直接向sendq队列的第一个协程获取数据。<br></code></pre></td></tr></table></figure><h4 id="关闭管道"><a href="#关闭管道" class="headerlink" title="关闭管道"></a>关闭管道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">关闭管道时会被recvq中的协程全部唤醒，这些协程获取的数据都为对应类型的零值。同时会把sendq中的协程全部唤醒，这些协程会触发<span class="hljs-built_in">panic</span>。<br><br>其他会触发<span class="hljs-built_in">panic</span>的操作有：<br>    <span class="hljs-number">1</span>、关闭值为<span class="hljs-literal">nil</span>的管道<br>    <span class="hljs-number">2</span>、关闭已经关闭的通道<br>    <span class="hljs-number">3</span>、向已经关闭的通道写数据<br></code></pre></td></tr></table></figure><h3 id="其他常见用法"><a href="#其他常见用法" class="headerlink" title="其他常见用法"></a>其他常见用法</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">(<span class="hljs-number">1</span>) 单向管道：单向管道只是对管道的一种限制，实际源码中并没有这种结构。<br>(<span class="hljs-number">2</span>) <span class="hljs-keyword">select</span>：监控多个管道，当其中一个管道可操作时就会触发相应的<span class="hljs-keyword">case</span>分支。<br>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span>-<span class="hljs-keyword">range</span>: 持续从管道中读取数据。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2021/04/15/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2021/04/15/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>生成树: 通过DFS和BFS都能得到一个生成树</p><p>最小生成树：联通所有顶点的边权总和最小的树</p><p>Kruskal算法: 每次选取最短的边 &amp;&amp; 该边与已有的边不形成环（用并查集动态维护） 时间复杂度: O(ElogE)</p><p>Prim算法: 选取顶点0并将与它相邻的边加入到优先队列， 不断从优先队列从选取最小边并判断合法性，如果不合法则continue，否则加入到结果集合并将新的横切边加入到优先队列。    时间复杂度:O(ElogE)</p></blockquote><h3 id="Kruskal算法-最小生成树"><a href="#Kruskal算法-最小生成树" class="headerlink" title="Kruskal算法: 最小生成树"></a>Kruskal算法: 最小生成树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存放所有的边</span><br>ArrayList&lt;Edge&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-comment">// 避免无向图的边重复获取，只保存 v &lt; w 的边</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[i]) &#123;<br>        <span class="hljs-keyword">if</span> (v &lt; w)<br>            edges.add(<span class="hljs-keyword">new</span> Edge(v, w, weight));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据边的权值排序</span><br>Collections.sort(edges);<br><br><span class="hljs-keyword">for</span> (Edge edge : edges) &#123;<br>    <span class="hljs-comment">// 如果两个顶点不在同一个集合中，则可以连接</span><br>    <span class="hljs-keyword">int</span> v = edge.v;<br>    <span class="hljs-keyword">int</span> w = edge.w;<br>    <span class="hljs-keyword">if</span> (!isConnected(v, w)) &#123;<br>        res.add(edge);<br>        union(v, w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Prim算法：最小生成树"><a href="#Prim算法：最小生成树" class="headerlink" title="Prim算法：最小生成树"></a>Prim算法：最小生成树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V - <span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 选取顶点0</span><br>visited[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">// 优先队列维护</span><br>PriorityQueue&lt;Edge&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>pq.offer(<span class="hljs-keyword">new</span> Edge(<span class="hljs-number">0</span>, adj[<span class="hljs-number">0</span>]))<br><br><span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>    <span class="hljs-comment">// 判断该边是否合法</span><br>    Edge minEdge = pq.poll();<br>    <span class="hljs-keyword">if</span> (visited[minEdge.v] &amp;&amp; visited[minEdge.w])<br>        <span class="hljs-keyword">continue</span>;<br>    <br>    res.add(minEdge);<br><br>    <span class="hljs-comment">// 添加新的横切边</span><br>    <span class="hljs-keyword">int</span> newNode = visited[minEdge.v] ? w : v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[newNode])<br>        pq.offer(<span class="hljs-keyword">new</span> Edge(newNode, w, weight));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈密尔顿问题</title>
    <link href="/2021/04/14/%E5%9B%BE%E8%AE%BA/%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/14/%E5%9B%BE%E8%AE%BA/%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>哈密尔顿回路：从一个点出发，沿着边行走，经过每个顶点恰好一次，最后回到起点。</p><p>递归结束条件： 回到起点 &amp;&amp; 所有点被访问过<br>时间复杂度：O(N!)</p></blockquote><h3 id="哈密尔顿回路"><a href="#哈密尔顿回路" class="headerlink" title="哈密尔顿回路"></a>哈密尔顿回路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br>pre[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>end = -<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> parent, <span class="hljs-keyword">int</span> left)</span> </span>&#123;<br>    visited[s] = <span class="hljs-keyword">true</span>;<br>    pre[v] = parent;<br>    left--<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[w]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            <span class="hljs-keyword">if</span> (dfs(w, v, left))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> &amp;&amp; left == <span class="hljs-number">0</span>) &#123;<br>            end = v;    <span class="hljs-comment">// 满足哈密尔顿回路，记录最后一个点 </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    left++; <span class="hljs-comment">// 可以无需++， 因为是值传递，不会影响上一层</span><br>    visited[s] = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>哈密尔顿路径：在一个无向图中，从一个点走到另外一个点，并且所有顶点都恰好访问过一次的路径。</p></blockquote><h3 id="哈密尔顿路径"><a href="#哈密尔顿路径" class="headerlink" title="哈密尔顿路径"></a>哈密尔顿路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span>, V-<span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">int</span> left = V;<br><span class="hljs-keyword">int</span> st, ed;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> left)</span> </span>&#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    left--;<br>    <span class="hljs-comment">// 找到了一条路径</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; v == ed) &#123;<br>        visited[v] = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w])<br>            res += dfs(w, left);<br>    &#125;<br><br>    left++;<br>    visited[v] = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈密尔顿问题</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桥和割点</title>
    <link href="/2021/04/13/%E5%9B%BE%E8%AE%BA/%E6%A1%A5%E5%92%8C%E5%89%B2%E7%82%B9/"/>
    <url>/2021/04/13/%E5%9B%BE%E8%AE%BA/%E6%A1%A5%E5%92%8C%E5%89%B2%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于无向图，如果删除了一条边导致整个图的连通分量数量发生了变化，则这条边称为桥</p><p>对于无向图，如果删除了一个顶点导致整个图的连通分量数量发生了变化，则这个点称为割点。（一条桥对应的两个顶点）</p></blockquote><h3 id="寻找桥"><a href="#寻找桥" class="headerlink" title="寻找桥"></a>寻找桥</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    如何判断 v-w 是不是桥?</span><br><span class="hljs-comment">    看通过w，能否从另外一条路回到v或者v之前的顶点。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    对于每一个顶点，记录DFS的访问顺序。</span><br><span class="hljs-comment">    ord[v]表示顶点v在DFS的访问顺序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    对于每一个顶点，记录能到达的最小ord</span><br><span class="hljs-comment">    low[v]表示DFS过程中，顶点v能到达的最小ord值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    low[w] &gt; ord[v], 则 v-w为桥</span><br><span class="hljs-comment">*/</span><br><br>visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>ord[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>low[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> parent)</span> </span>&#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    ord[v] = cnt;<br>    low[v] = ord[v];<br>    cnt++;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            dfs(w, v);<br>            low[v] = Math.min(low[v], low[w]);<br><br>            <span class="hljs-comment">// 该边为桥</span><br>            <span class="hljs-keyword">if</span> (low[w] &gt; ord[v]) &#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;v, w&#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (w != parent) &#123;<br>                low[v] = Math.min(low[v], low[w]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="寻找割点"><a href="#寻找割点" class="headerlink" title="寻找割点"></a>寻找割点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    low[w] &gt;= ord[v], 则v是割点。</span><br><span class="hljs-comment">    根节点(v == parent)另外判断，如果根节点有一个以上的孩子则根节点是割点。</span><br><span class="hljs-comment">*/</span><br><br>visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>ord[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br>low[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> parent)</span> </span>&#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    ord[v] = cnt;<br>    low[v] = ord[v];<br>    cnt++;<br><br>    <span class="hljs-keyword">int</span> child = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            dfs(w, v);<br>            low[v] = Math.min(low[v], low[w]);<br><br>            <span class="hljs-comment">// 如果v不是根节点 v为割点</span><br>            <span class="hljs-keyword">if</span> (v != parent &amp;&amp; low[w] &gt;= ord[v]) &#123;<br>                res.add(v);<br>            &#125;<br><br>            <span class="hljs-comment">// 根节点单独判断</span><br>            child++;<br>            <span class="hljs-keyword">if</span> (v == parent &amp;&amp; child &gt; <span class="hljs-number">1</span>) &#123;<br>                res.add(v);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (w != parent) &#123;<br>                low[v] = Math.min(low[v], low[w]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>桥和割点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的广度优先搜索</title>
    <link href="/2021/04/12/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <url>/2021/04/12/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>广度优先遍历使用<strong>队列</strong>， 将还未访问过的节点加入到队列中并标志已访问</p><p>时间复杂度:O(V + E)</p><p>广度优先搜索的应用：</p><ul><li>求一个点到另外一个点的最短路径（典型）</li></ul></blockquote><h3 id="BFS的伪代码"><a href="#BFS的伪代码" class="headerlink" title="BFS的伪代码"></a>BFS的伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    queue.add(v);   <span class="hljs-comment">// 初始顶点加入队列</span><br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> v = queue.poll();<br>        <span class="hljs-comment">// 将还没访问过的邻接顶点压入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                queue.add(w);<br>                visited[w] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用1：求点s到点t的任一路径"><a href="#应用1：求点s到点t的任一路径" class="headerlink" title="应用1：求点s到点t的任一路径"></a>应用1：求点s到点t的任一路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br>pre[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;<br><br>bfs(<span class="hljs-keyword">int</span> s) &#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    queue.add(v);   <span class="hljs-comment">// 初始顶点加入队列</span><br>    pre[s] = s;<br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> v = queue.poll();<br>        <span class="hljs-comment">// 将还没访问过的邻接顶点压入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                queue.add(w);<br>                visited[w] = <span class="hljs-keyword">true</span>;<br>                pre[w] = v  <span class="hljs-comment">// 记录上一个节点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用2：求无权图中点s到其他顶点的最短距离"><a href="#应用2：求无权图中点s到其他顶点的最短距离" class="headerlink" title="应用2：求无权图中点s到其他顶点的最短距离"></a>应用2：求无权图中点s到其他顶点的最短距离</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br>dist[<span class="hljs-number">0</span> ~ V-<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;<br><br>bfs(<span class="hljs-keyword">int</span> s) &#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br>    dist[s] = <span class="hljs-number">0</span>;<br>    queue.add(s);<br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> v = queue.poll();<br><br>        <span class="hljs-comment">// 将还没访问过的邻接顶点压入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                queue.add(w);<br>                visited[w] = <span class="hljs-keyword">true</span>;<br>                dist[w] = dist[v] + <span class="hljs-number">1</span>;    <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的深度优先搜索</title>
    <link href="/2021/04/11/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/11/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图的深度优先遍历需要维护：一个节点是否已经被访问过</p><p>时间复杂度：O(V + E)</p><p>深度优先遍历的应用：</p><ul><li>求连通分量</li><li>两个点是否可达</li><li>图中是否有环</li><li>…</li></ul></blockquote><h3 id="DFS的伪代码"><a href="#DFS的伪代码" class="headerlink" title="DFS的伪代码"></a>DFS的伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><br>visited[<span class="hljs-number">0</span> ~ V - <span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 这样的话可以遍历多个连通分量的情况</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>    <span class="hljs-keyword">if</span> (!visited[v])<br>        dfs(v);<br>&#125;<br><br>dfs(<span class="hljs-keyword">int</span> v) &#123;<br>    <span class="hljs-comment">// 将该节点加入访问节点</span><br>    list.add(v)<br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 遍历与它相邻的所有节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-comment">// 需要判断该节点是否以已经被访问过</span><br>        <span class="hljs-keyword">if</span> (!visited[w])<br>            dfs(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用1：无向图的联通分量个数"><a href="#应用1：无向图的联通分量个数" class="headerlink" title="应用1：无向图的联通分量个数"></a>应用1：无向图的联通分量个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V - <span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>    <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>        cnt++;      <span class="hljs-comment">// 每进入一次则连通分量+1</span><br>        dfs(v);<br>    &#125;<br>&#125;<br><br>dfs(<span class="hljs-keyword">int</span> v) &#123;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w])<br>            dfs(w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用2：每个连通分量的顶点个数"><a href="#应用2：每个连通分量的顶点个数" class="headerlink" title="应用2：每个连通分量的顶点个数"></a>应用2：每个连通分量的顶点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">visited[<span class="hljs-number">0</span> ~ V - <span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>; <br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;<br>    <span class="hljs-keyword">if</span> (visited[v] == -<span class="hljs-number">1</span>) &#123;<br>        dfs(v, cnt);<br>        cnt++;      <span class="hljs-comment">// 不仅维护有几个连通分量，而且可以赋给visited[]来记录顶点属于第几个连通分量</span><br>    &#125;<br>&#125;<br><br>dfs(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> cnt) &#123;<br>    visited[v] = cnt;       <span class="hljs-comment">// visited[]记录属于哪一个连通分量</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj(v)) &#123;<br>        <span class="hljs-keyword">if</span> (visited[w] == -<span class="hljs-number">1</span>)<br>            dfs(w, cnt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用3：判断两个顶点是否属于同一个联通分量"><a href="#应用3：判断两个顶点是否属于同一个联通分量" class="headerlink" title="应用3：判断两个顶点是否属于同一个联通分量"></a>应用3：判断两个顶点是否属于同一个联通分量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在应用2的基础上，通过判断visited[]是否为同一个值即可判断</span><br><br><span class="hljs-keyword">if</span> (visited[s] == visited[p])   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 返回每个连通分量的所有情况</span><br>Map&lt;Integer, List&lt;Integer&gt;&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;<br>    <span class="hljs-keyword">int</span> t = visited[i];<br>    <span class="hljs-keyword">if</span> (!m.containsKey(t))<br>        m.put(t, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>    m.get(t).add(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用4：如何求出两个顶点之间的任意一条路径"><a href="#应用4：如何求出两个顶点之间的任意一条路径" class="headerlink" title="应用4：如何求出两个顶点之间的任意一条路径"></a>应用4：如何求出两个顶点之间的任意一条路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 记录pre信息即可</span><br><span class="hljs-keyword">int</span>[] pre;<br><span class="hljs-keyword">boolean</span>[] visited;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> parent, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    pre[v] = parent;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// 提前返回</span><br>    <span class="hljs-keyword">if</span> (v == t) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adg[v]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            <span class="hljs-keyword">if</span> (dfs(w, v, t))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 倒序输出</span><br><span class="hljs-keyword">while</span> (p != s) &#123;<br>    list.add(p);<br>    p = parent[p];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用5：检测无向图中的环"><a href="#应用5：检测无向图中的环" class="headerlink" title="应用5：检测无向图中的环"></a>应用5：检测无向图中的环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 找到一个已经访问过的节点，并且该节点不是上一个节点</span><br><span class="hljs-keyword">boolean</span> visited[];<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> parent)</span> </span>&#123;<br><br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w])<br>            <span class="hljs-keyword">if</span> (dfs(w, v))  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <br>        <span class="hljs-keyword">if</span> (visited[w] &amp;&amp; parent != v)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用6：二分图检测"><a href="#应用6：二分图检测" class="headerlink" title="应用6：二分图检测"></a>应用6：二分图检测</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二分图：每一个顶点的相邻顶点与该顶点不属于同一类</span><br><br><span class="hljs-keyword">boolean</span>[] visited;<br><span class="hljs-keyword">int</span>[] colors;  <span class="hljs-comment">// -1: 未染色，0：蓝色，1：红色</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> color)</span> </span>&#123;<br>    colors[v] = color;<br>    visited[v] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">int</span> w : adj[v]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>            <span class="hljs-keyword">if</span> (!dfs(w, <span class="hljs-number">1</span> - color))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 判断颜色是否冲突</span><br>            <span class="hljs-keyword">if</span> (colors[w] == colors[v])<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>深度优先遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的基本表示</title>
    <link href="/2021/04/11/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA/"/>
    <url>/2021/04/11/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">利用二维数组来表示两个节点的关系<br><span class="hljs-variable">arr</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-operator">:</span> 表示<span class="hljs-variable">i</span><span class="hljs-operator">--&gt;</span><span class="hljs-variable">j</span><span class="hljs-operator">,</span> 权值为<span class="hljs-number">3</span><br>适合稠密图<span class="hljs-operator">:</span> 顶点少，边很多<br><br>空间复杂度<span class="hljs-operator">:</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">V</span> <span class="hljs-operator">^</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span><br>建图：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">)</span><br>查看两个点是否相邻：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><br>求一个点的相邻节点：<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">V</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 邻接矩阵的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdjMatrix</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V;  <span class="hljs-comment">// 顶点个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;  <span class="hljs-comment">// 边的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] adj;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdjMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-keyword">int</span> E)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.V = V;<br>        <span class="hljs-keyword">this</span>.E = E;<br>        adj = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V][V];<br>    &#125;<br><br>    <span class="hljs-comment">// 无向图要维护两条边，否则仅需要维护一条边</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st, <span class="hljs-keyword">int</span> ed)</span> </span>&#123;<br>        adj[st][ed] = <span class="hljs-number">1</span>;<br>        adj[ed][st] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回与顶点v的所有相邻节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getAdj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;<br>            <span class="hljs-keyword">if</span> (adj[x][i] == <span class="hljs-number">1</span>)<br>                res.add(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl">利用数组 + 链表(哈希表<span class="hljs-variable">HashSet</span>/红黑树<span class="hljs-variable">TreeSet</span>)的形式保存顶点以及它的临边关系。<br>适合稀疏图：顶点多，边很少<br><br>空间复杂度:<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">V</span> + <span class="hljs-variable">E</span>)</span><br>建图：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">E</span>)</span><br>查看两个点是否相邻：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">degree</span>(<span class="hljs-variable">V</span>))</span><br>求一个点的相邻节点：<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-title">degree</span>(<span class="hljs-variable">V</span>))</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 邻接表表示</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdjList</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;<br>    <span class="hljs-comment">//private LinkedList&lt;Integer&gt;[] adj;</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Integer&gt;[] adj;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdjList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-keyword">int</span> E)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.V = V;<br>        <span class="hljs-keyword">this</span>.E = E;<br><br>        adj = <span class="hljs-keyword">new</span> HashSet&lt;&gt;[V];<br>    &#125;<br><br>    <span class="hljs-comment">// 无向图要维护两条边，否则仅需要维护一条边</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st, <span class="hljs-keyword">int</span> ed)</span> </span>&#123;<br>        adj[st].add(ed);<br>        adj[ed].add(st);<br>    &#125;<br><br>    <span class="hljs-comment">// 返回与顶点v的所有相邻节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HashSet&lt;Integer&gt; <span class="hljs-title">getAdj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        HashSet&lt;Integer&gt; res = adj[x];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>图的存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0010_正则表达式匹配</title>
    <link href="/2021/04/10/%E7%AE%97%E6%B3%95/LC0010_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95/LC0010_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <span class="hljs-string">&#x27;.&#x27;</span> 和 <span class="hljs-string">&#x27;*&#x27;</span> 的正则表达式匹配。<br><br><span class="hljs-string">&#x27;.&#x27;</span> 匹配任意单个字符<br><span class="hljs-string">&#x27;*&#x27;</span> 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：s = <span class="hljs-comment">&quot;aa&quot;</span> p = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-keyword">false</span><br>解释：<span class="hljs-comment">&quot;a&quot;</span> 无法匹配 <span class="hljs-comment">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">dp[i][j]: s串的前i个字符与p串的前j个字符是否匹配<br><br>集合划分：(p[j] != <span class="hljs-string">&#x27;*&#x27;</span> || p[j] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>    (<span class="hljs-number">1</span>) 当p[j] != <span class="hljs-string">&#x27;*&#x27;</span> 的时候，需要比较 s[i] 与 p[j]. 如果s[i]能够与p[j]匹配，那么dp[i][j]根据 dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]转移过来。<br><br>    (<span class="hljs-number">2</span>) 当p[j] == <span class="hljs-string">&#x27;*&#x27;</span> 的时候，则可能匹配<span class="hljs-number">0</span>次、<span class="hljs-number">1</span>次、<span class="hljs-number">2</span>次...<br>    匹配<span class="hljs-number">0</span>次: dp[i][j] 根据 dp[i][j<span class="hljs-number">-1</span>]转移过来<br>    匹配<span class="hljs-number">1</span>次：s[i] == p[j<span class="hljs-number">-1</span>]<br>    匹配<span class="hljs-number">2</span>次：s[i] == p[j<span class="hljs-number">-1</span>] &amp;&amp; s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>]<br>    匹配<span class="hljs-number">3</span>次：s[i] == p[j<span class="hljs-number">-1</span>] &amp;&amp; s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &amp;&amp; s[i<span class="hljs-number">-2</span>] == p[j<span class="hljs-number">-1</span>]<br>    ...<br><br>    因此匹配多次的情况：<span class="hljs-number">1</span>次 || <span class="hljs-number">2</span>次 || <span class="hljs-number">3</span>次 || ...<br>    然而我们发现 dp[i<span class="hljs-number">-1</span>][j] 在匹配多次的情况时：<br>        <span class="hljs-number">1</span>次: s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>        <span class="hljs-number">2</span>次：s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] &amp;&amp; s[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-1</span>]<br>        ...<br>    <br>    因此 dp[i][j] 可以通过 dp[i<span class="hljs-number">-1</span>][j] &amp;&amp; s[i] == p[j<span class="hljs-number">-1</span>] 转移过来。<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br><br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    p = <span class="hljs-string">&quot; &quot;</span> + p;<br><br>    <span class="hljs-comment">// dp[i][j]: s前i个字符是否能够与p前j个字符相匹配 </span><br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] || dp[i][j];<br>            <br>            <span class="hljs-keyword">if</span> (p.charAt(j) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 匹配0次</span><br>                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span>)<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">2</span>] || dp[i][j];<br>                <br>                <span class="hljs-comment">// 匹配多次</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i) == p.charAt(j - <span class="hljs-number">1</span>) || p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] || dp[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC0004_寻找两个正序数组的中位数</title>
    <link href="/2021/04/10/%E7%AE%97%E6%B3%95/LC0004_%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95/LC0004_%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br><br>示例 1：<br><br>输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm">方法<span class="hljs-number">1</span>：O(N + M)<br>    将两个正序数组按序合并，返回对应的中位数即可<br><br>方法<span class="hljs-number">2</span>：O(log(N + M))<br>    先考虑朴素情况：每次我们取<span class="hljs-built_in">s1</span>[k/<span class="hljs-number">2</span>]和<span class="hljs-built_in">s2</span>[k/<span class="hljs-number">2</span>]的地方，如果<span class="hljs-built_in">s1</span>[k/<span class="hljs-number">2</span>] &gt; <span class="hljs-built_in">s2</span>[k/<span class="hljs-number">2</span>]，则说明第k小的数肯定不会存在于<span class="hljs-built_in">s2</span>[l, l + k/<span class="hljs-number">2</span>]中。因此可以排除掉 k / <span class="hljs-number">2</span> 个元素。<br><br>    再考虑边界情况，如果<span class="hljs-built_in">s1</span>中的个数不足 k / <span class="hljs-number">2</span> 怎么办？ <br>        那么就取最后一个位置的元素参与比较, int si = min(i + k / <span class="hljs-number">2</span>, len(<span class="hljs-built_in">s1</span>))<br>    <br>    如果<span class="hljs-built_in">s1</span>已经排除完了怎么办？i<br>        返回<span class="hljs-built_in">s2</span>[j + k - <span class="hljs-number">1</span>]的元素即可<br><br>    如果 k == <span class="hljs-number">1</span> 怎么办？<br>        返回 min(<span class="hljs-built_in">s1</span>[i], <span class="hljs-built_in">s2</span>[j])<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> total = nums1.length + nums2.length;<br><br>    <span class="hljs-keyword">if</span> (total % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// find (total / 2)th number</span><br>        <span class="hljs-keyword">int</span> left = findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// find (total / 2 + 1)th number</span><br>        <span class="hljs-keyword">int</span> right = findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2.0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, total / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">1.0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums1.length - i &gt; nums2.length - j)<br>        <span class="hljs-keyword">return</span> findKth(nums2, j, nums1, i, k);<br>    <br>    <span class="hljs-keyword">if</span> (i == nums1.length)  <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br><br>    <span class="hljs-keyword">int</span> si = Math.min(i + k / <span class="hljs-number">2</span>, nums1.length);<br>    <span class="hljs-keyword">int</span> sj = j + k / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (nums1[si - <span class="hljs-number">1</span>] &gt; nums2[sj - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> findKth(nums1, si, nums2, j, k - (si - i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>递归</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中位数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie字典树</title>
    <link href="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Trie%E6%A0%91/"/>
    <url>/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素版字典树：仅维护单词结尾信息"><a href="#朴素版字典树：仅维护单词结尾信息" class="headerlink" title="朴素版字典树：仅维护单词结尾信息"></a>朴素版字典树：仅维护单词结尾信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> isWord;<br>    Node[] next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isWord)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.isWord = isWord;<br>        next = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> Node();<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加一个单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        <span class="hljs-comment">// 从根节点开始查找</span><br>        Node cur = root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <span class="hljs-comment">// 如果该字符还没出现过，则生成节点</span><br>            <span class="hljs-keyword">if</span> (cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Node();<br><br>            <span class="hljs-comment">// cur指向新节点继续向下找</span><br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>]<br>        &#125;<br><br>        <span class="hljs-comment">// 走到最后一个字符，判断是否已经出现过</span><br>        <span class="hljs-keyword">if</span> (!cur.isWord) &#123;<br>            cur.isWord = <span class="hljs-keyword">true</span>;<br>            size++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询一个单词是否存在</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <span class="hljs-keyword">if</span> (cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cur.isWord == <span class="hljs-keyword">true</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂版字典树：维护结尾信息、前缀信息"><a href="#复杂版字典树：维护结尾信息、前缀信息" class="headerlink" title="复杂版字典树：维护结尾信息、前缀信息"></a>复杂版字典树：维护结尾信息、前缀信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> isWord; <span class="hljs-comment">// 维护结尾信息</span><br>    <span class="hljs-keyword">int</span> pre;    <span class="hljs-comment">// 维护前缀信息</span><br>    <br>    Node[] next;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>        isWord = <span class="hljs-keyword">false</span>;<br>        pre = <span class="hljs-number">0</span>;<br>        next = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> Node();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 添加单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <br>            <span class="hljs-comment">// 如果该后缀不存在，则创建</span><br>            <span class="hljs-keyword">if</span> (cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Node();<br>            <br>            <span class="hljs-comment">// 以该字符为前缀的单词数量+1</span><br>            cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>].pre += <span class="hljs-number">1</span>;<br>            <br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!cur.isWord) &#123;<br>            cur.isWord = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <br>            <span class="hljs-keyword">if</span> (cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> cur.isWord;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 删除单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <br>            <span class="hljs-comment">// 以该字符为前缀的单词数量-1</span><br>            cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>].pre -= <span class="hljs-number">1</span>;<br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <br>        cur.isWord = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询前缀</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numOfPre</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Node cur = root;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            cur = cur.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> cur.pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>字典树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>股票交易问题</title>
    <link href="/2021/04/08/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/08/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="LeetCode121-买卖股票的最佳时机1"><a href="#LeetCode121-买卖股票的最佳时机1" class="headerlink" title="LeetCode121:买卖股票的最佳时机1"></a>LeetCode121:买卖股票的最佳时机1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    特点：只能买卖一次</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    贪心：寻找最大的上升区间。xMin记录曾经出现过的最小值，xMax记录最大的上升区间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> xMin = prices[<span class="hljs-number">0</span>];   <span class="hljs-comment">// 记录当前出现的最小值</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        res = Math.max(res, prices[i] - xMin);<br>        xMin = Math.min(xMin, prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode122-买卖股票的最佳时机2"><a href="#LeetCode122-买卖股票的最佳时机2" class="headerlink" title="LeetCode122:买卖股票的最佳时机2"></a>LeetCode122:买卖股票的最佳时机2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    特点：可以买卖无数次</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    贪心: 累加每一个上升区间</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-comment">// 累加每一个上升区间</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; prices.length &amp;&amp; prices[j] &gt; prices[j - <span class="hljs-number">1</span>])<br>            j++;<br>        <br>        <span class="hljs-comment">// 上升区间[i, j - 1]</span><br>        sum += prices[j - <span class="hljs-number">1</span>] - prices[i];<br>        i = j - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode123-买卖股票的最佳时机3"><a href="#LeetCode123-买卖股票的最佳时机3" class="headerlink" title="LeetCode123:买卖股票的最佳时机3"></a>LeetCode123:买卖股票的最佳时机3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    特点：只能交易2次</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用前后缀分解的思想：</span><br><span class="hljs-comment">        1、从前往后枚举，记录前面买卖一次的最大收益f[i]。 第i天手上无股票的最大收益</span><br><span class="hljs-comment">        2、从后往前枚举，记录后面买卖一次的最大收益g[i]。 第i天买入股票的最大收益</span><br><span class="hljs-comment">        3、则总的最大收益：max(f[i] + g[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <br>    <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];   <span class="hljs-comment">// 前面买卖一次的最大收益</span><br>    <span class="hljs-keyword">int</span> xMin = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        f[i] = f[i - <span class="hljs-number">1</span>];    <span class="hljs-comment">// 不卖</span><br>        f[i] = Math.max(f[i], prices[i] - xMin); <span class="hljs-comment">// 卖</span><br>        xMin = Math.min(xMin, prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];   <span class="hljs-comment">// 后面买卖一次的最大收益</span><br>    <span class="hljs-keyword">int</span> xMax = prices[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        g[i] = g[i + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 不买</span><br>        g[i] = Math.max(g[i], xMax - prices[i]);    <span class="hljs-comment">// 买</span><br>        xMax = Math.max(xMax, prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        res = Math.max(res, f[i] + g[i]);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode188-买卖股票的最佳时机4"><a href="#LeetCode188-买卖股票的最佳时机4" class="headerlink" title="LeetCode188:买卖股票的最佳时机4"></a>LeetCode188:买卖股票的最佳时机4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    特点：只能买卖K次</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    状态机模型： </span><br><span class="hljs-comment">        状态1: 手上有现金</span><br><span class="hljs-comment">        状态2：手上有股票</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    转移方式： 1 -&gt; 1  不买</span><br><span class="hljs-comment">              1 -&gt; 2  买  -price[i]</span><br><span class="hljs-comment">              2 -&gt; 2  不卖</span><br><span class="hljs-comment">              2 -&gt; 1  卖  +price[i]</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    f[i][j] : 经过了i天，交易了j次且当天不持有股票的最大收益 f[0][0] = 0</span><br><span class="hljs-comment">    g[i][j] : 经过了i天，交易了j次且当天持有股票的最大收益   g[0][0] = -INF</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    f[i][j] 对应两种转移方式： max(f[i-1][j], g[i-1][j-1] + prices[i])</span><br><span class="hljs-comment">    g[i][j] 对应两种转移方式： max(g[i-1][j], f[i-1][j-1] - prices[i])</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    由于f[i][j] 和 g[i][j] 都至于上一层有关，因此采用滚动数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意: 当 k &gt;= n / 2 天时，相当于无限次交易</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">if</span> (k &gt;= n / <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 相当于无限次交易</span><br>        <span class="hljs-keyword">return</span> maxProfit(prices);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][k + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        Arrays.fill(f[i], -<span class="hljs-number">100000000</span>);<br>        Arrays.fill(g[i], -<span class="hljs-number">100000000</span>);<br>    &#125;<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= k; j++) &#123;<br>            f[i % <span class="hljs-number">2</span>][j] = f[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j];<br>            g[i % <span class="hljs-number">2</span>][j] = Math.max(g[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j], f[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j] - prices[i-<span class="hljs-number">1</span>]);<br><br>            <span class="hljs-comment">// 只有买过才算一次交易，才能从 2 -&gt; 1</span><br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>)<br>                f[i % <span class="hljs-number">2</span>][j] = Math.max(f[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j], g[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j-<span class="hljs-number">1</span>] + prices[i-<span class="hljs-number">1</span>]);<br>            <br>            xMax = Math.max(xMax, f[i % <span class="hljs-number">2</span>][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br><span class="hljs-comment">// 股票问题2</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-comment">// 累加每一个上升区间</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; prices.length &amp;&amp; prices[j] &gt; prices[j - <span class="hljs-number">1</span>])<br>            j++;<br>        <br>        <span class="hljs-comment">// 上升区间[i, j - 1]</span><br>        sum += prices[j - <span class="hljs-number">1</span>] - prices[i];<br>        i = j - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode309-最佳买卖股票时机含冷冻期"><a href="#LeetCode309-最佳买卖股票时机含冷冻期" class="headerlink" title="LeetCode309:最佳买卖股票时机含冷冻期"></a>LeetCode309:最佳买卖股票时机含冷冻期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    不再有次数的限制。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    三个状态：</span><br><span class="hljs-comment">        状态0：冷冻期</span><br><span class="hljs-comment">        状态1：持有股票</span><br><span class="hljs-comment">        状态2：持有现金</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    状态转移： 0 -&gt; 0  不买</span><br><span class="hljs-comment">              0 -&gt; 1  买入 -price[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">              1 -&gt; 1  不卖</span><br><span class="hljs-comment">              1 -&gt; 2  卖了 +price[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">              2 -&gt; 0  触发了1-2, 自然会进入0</span><br><span class="hljs-comment">              2 -&gt; 2  不买</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    f[i][0] = max(f[i-1][0], f[i-1][2])</span><br><span class="hljs-comment">    f[i][1] = max(f[i-1][1], f[i-1][0] - prices[i])</span><br><span class="hljs-comment">    f[i][2] = max(f[i-1][2], f[i-1][1] + prices[i])</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    状态入口：f[0][0] = 0, f[0][1] = 0, 其他皆为最小值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    取三者的最大值.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br><br>    <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        Arrays.fill(f[i], -<span class="hljs-number">100000000</span>);<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>        f[i][<span class="hljs-number">1</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        f[i][<span class="hljs-number">2</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Math.max(f[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], Math.max(f[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[n-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LeetCode714-最佳买卖股票时机含手续费"><a href="#LeetCode714-最佳买卖股票时机含手续费" class="headerlink" title="LeetCode714:最佳买卖股票时机含手续费"></a>LeetCode714:最佳买卖股票时机含手续费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    状态0: 持有现金</span><br><span class="hljs-comment">    状态1：持有股票</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    0 -&gt; 0  不买</span><br><span class="hljs-comment">    0 -&gt; 1  买入 -prices[i] - fee</span><br><span class="hljs-comment">    1 -&gt; 1  不卖</span><br><span class="hljs-comment">    1 -&gt; 0  卖了</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br><br>    <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>        Arrays.fill(f[i], -<span class="hljs-number">100000000</span>);<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i - <span class="hljs-number">1</span>]);<br>        f[i][<span class="hljs-number">1</span>] = Math.max(f[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i - <span class="hljs-number">1</span>] - fee);<br>        xMax = Math.max(xMax, f[i][<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之数据库</title>
    <link href="/2021/04/07/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/04/07/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="事务的概念和特性"><a href="#事务的概念和特性" class="headerlink" title="事务的概念和特性"></a>事务的概念和特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">事务就是一系列操作的集合，遵循原子性、一致性、隔离性、持久性。<br>原子性：事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）<br>一致性：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；<br>隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。<br>持久性：一旦事务提交成功，对数据的修改是永久性的<br></code></pre></td></tr></table></figure><h3 id="并发执行会出现那些问题"><a href="#并发执行会出现那些问题" class="headerlink" title="并发执行会出现那些问题?"></a>并发执行会出现那些问题?</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">脏读：一个事务读取了另外一个事务未提交的数据。<br>不可重复读：在同一个事务中，同一条数据的两次查询结果不一致。<span class="hljs-comment">(针对update操作)</span><br>幻读：同一查询多次执行时，由于其它事务在这个数据范围内执行了插入或删除操作，导致每次返回不同的结果集。<br></code></pre></td></tr></table></figure><h3 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">未提交读：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；<br>已提交读：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；<br>重复读：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；<br>串行化：所有事务串行执行，可解决幻读。<br></code></pre></td></tr></table></figure><h3 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景；<br><br>乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。乐观锁的实现方式有：<br>    1、加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；<br>    2、先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新<br></code></pre></td></tr></table></figure><h3 id="常见的锁类型"><a href="#常见的锁类型" class="headerlink" title="常见的锁类型"></a>常见的锁类型</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">排他锁(<span class="hljs-meta">X</span>锁)：事务对数据加上<span class="hljs-meta">X</span>锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；<br>共享锁(S锁)：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加<span class="hljs-meta">X</span>锁；<br><br>间隙锁：<br></code></pre></td></tr></table></figure><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">多版本并发控制，MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。<br><br>创建版本号：创建一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）；<br><br>删除版本号：删除操作时的事务版本号；<br><br>各种操作：<br>    插入操作时，记录创建版本号；<br>    删除操作时，记录删除版本号；<br>    更新操作时，先对命中行做复制，将当前事务版本号写入旧的数据行中的删除版本号中。将当前事务版本号写入新的数据行中的创建版本号中。<br>    查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）<br><br>通过版本号减少了锁的争用，提高了系统性能；<br><br>MVCC只在<span class="hljs-keyword">Repeatable</span> <span class="hljs-keyword">Read</span>和<span class="hljs-keyword">Read</span> Commited两个隔离级别下工作,其他情况下都不兼容.因为<span class="hljs-keyword">Read</span> UnCommited总是读取最新的行,而<span class="hljs-keyword">Serializable</span>总是会对所有读取的行都加锁.<br></code></pre></td></tr></table></figure><h3 id="什么是快照读？什么是当前读？"><a href="#什么是快照读？什么是当前读？" class="headerlink" title="什么是快照读？什么是当前读？"></a>什么是快照读？什么是当前读？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">快照读：通过 undo <span class="hljs-keyword">log</span> + MVCC 来实现的。<br><br>当前读：当前读，读取的是最新版本，并且需要先获取对应记录的锁（行记录锁 + 间隙锁）。<br><br>三种锁：<br>行锁（<span class="hljs-type">Record</span> <span class="hljs-keyword">Lock</span>）：锁直接加在索引记录上面。<br>间隙锁（Gap <span class="hljs-keyword">Lock</span>）：是 Innodb 为了解决幻读问题时引入的锁机制，所以只有在 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">Repeatable</span> 、<span class="hljs-keyword">Serializable</span> 隔离级别才有。<br>Next-Key <span class="hljs-keyword">Lock</span> ：<span class="hljs-type">Record</span> <span class="hljs-keyword">Lock</span> + Gap <span class="hljs-keyword">Lock</span>，锁定一个范围并且锁定记录本身 。<br></code></pre></td></tr></table></figure><h3 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">第一范式：属性不可再分<br>第二范式：每个非主属性完全依赖主属性<br>第三范式：非主属性不传递依赖于主属性<br></code></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h3><h4 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">索引是一个特殊的文件，它包含了数据表中所有记录的引用指针。<br>索引是一种数据结构，比如在MySQL的InnoDB引擎中，索引就是一颗<span class="hljs-selector-tag">B</span>+树，通过这颗<span class="hljs-selector-tag">B</span>+树，能够快速检索到要查询的内容<br></code></pre></td></tr></table></figure><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点?"></a>索引的优缺点?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">优点：大大的提升检索速度<br>缺点：维护索引需要耗费时间，对数据进行增、删、改的时候也要动态的维护索引；索引占据物理空间。<br></code></pre></td></tr></table></figure><h4 id="MySQL有哪几种索引？"><a href="#MySQL有哪几种索引？" class="headerlink" title="MySQL有哪几种索引？"></a>MySQL有哪几种索引？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">从结构上来看：<span class="hljs-selector-tag">B</span>+树、Hash索引<br>从应用层次来看：聚簇索引、非聚簇索引、联合索引、覆盖索引<br></code></pre></td></tr></table></figure><h4 id="说一说Hash索引和B-树索引的底层实现"><a href="#说一说Hash索引和B-树索引的底层实现" class="headerlink" title="说一说Hash索引和B+树索引的底层实现"></a>说一说Hash索引和B+树索引的底层实现</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Hash索引的底层是哈希表，记录了索引列和数据行位置的映射关系。Hash索引的优点是：对于精准查询非常快。缺点是：不支持范围查询。<br><br><span class="hljs-selector-tag">B</span>+索引的底层是<span class="hljs-selector-tag">B</span>+树，它的叶子节点存放了所有的数据，并且叶子节点通过双向链表进行连接，在进行范围查询，增删数据都非常的快。它的非叶子节点存放的是所有索引，而且索引是按序存放的，通过二叉查找能很快定位到索引列对应的数据。<br></code></pre></td></tr></table></figure><h4 id="为什么使用B-树，而不是用B树或者红黑树或者Hash表"><a href="#为什么使用B-树，而不是用B树或者红黑树或者Hash表" class="headerlink" title="为什么使用B+树，而不是用B树或者红黑树或者Hash表"></a>为什么使用B+树，而不是用B树或者红黑树或者Hash表</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">一方面：<span class="hljs-selector-tag">B</span>+树的磁盘读写代价更低，因为<span class="hljs-selector-tag">B</span>+树的非叶子节点只存放索引，如果把非叶子节点放入同一块磁盘上，覆盖到的关键字也就更多，相对来说磁盘读写代价更低。<br>其次：<span class="hljs-selector-tag">B</span>+树的叶子节点存放的都是数据，并且通过双向链表进行连接，更方便进行区间查询。只需要找到区间索引对应的左端点和右端点，然后直接扫描该链表就可以了，而对于<span class="hljs-selector-tag">B</span>树来说，需要一遍遍进行中序遍历。<br><br><span class="hljs-selector-tag">B</span>树:不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；<br>Hash表只适合精准查询，也就是等值查询。不适合范围查询。<br>红黑树：二叉树，当数据量大的时候高度很高，磁盘读写代价高。<br></code></pre></td></tr></table></figure><h4 id="聚簇索引和非聚簇索引的区别？"><a href="#聚簇索引和非聚簇索引的区别？" class="headerlink" title="聚簇索引和非聚簇索引的区别？"></a>聚簇索引和非聚簇索引的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">聚簇索引：非叶子节点存放索引字段信息，叶子节点存放的所有数据。<br>非聚簇索引：非叶子节点存放索引字段信息，叶子节点存放的对应的主键，因此大部分情况下，需要进行回表操作。<br></code></pre></td></tr></table></figure><h4 id="非聚簇索引一定会进行回表吗？"><a href="#非聚簇索引一定会进行回表吗？" class="headerlink" title="非聚簇索引一定会进行回表吗？"></a>非聚簇索引一定会进行回表吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">不一定，比如覆盖索引：查询列被索引列覆盖了，则不需要进行回表操作。<br></code></pre></td></tr></table></figure><h4 id="联合索引是什么？为什么需要注意联合索引的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引的顺序？"></a>联合索引是什么？为什么需要注意联合索引的顺序？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">联合索引：通过多个字段建立的索引列。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。<br><br>联合索引的建立本质上是多字段的排序。在多字段的排序原则中，需要先确定字段的优先级，对应到联合索引中就是最左前缀原则，越靠左边的字段优先级越高。 比如现在有两条记录，当优先级高的字段不相同时，按照字段值进行排序即可。如果优先级高的字段相同，那么按照次优先级字段进行排序。<br><br>一般情况下，将查询需求频繁或者字段选择性高的列放在前面。<br></code></pre></td></tr></table></figure><h4 id="说一说MySQL的最左前缀匹配？"><a href="#说一说MySQL的最左前缀匹配？" class="headerlink" title="说一说MySQL的最左前缀匹配？"></a>说一说MySQL的最左前缀匹配？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">最左前缀匹配原则就是最左边的字段优先匹配，因此，在创建多字段索引时，将<span class="hljs-keyword">where</span>子句中使用最频繁的一列放到最左边。<br><br>MySQL会一直向右匹配索引列，直到遇到范围查询(&gt;、&lt;、<span class="hljs-keyword">between</span>、<span class="hljs-keyword">like</span>)就停止。<br></code></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">前缀索引是针对这样一种情况：索引列的长度很长，不便于维护而且占内存空间，比如一些TEXT、BLOB字段。<br>这个时候我们可以选择索引列的前缀来建立索引，当然我们需要让这个前缀的选择性尽可能的低，因为选择性越低，过滤掉的数据行就越多。对于<span class="hljs-keyword">ORDER</span> <span class="hljs-title">BY</span>，前缀索引不适用。<br><br>建立流程：<br>    <span class="hljs-number">1</span>、计算完整列的选择性<br>    <span class="hljs-number">2</span>、计算不同长度前缀的选择性<br>    <span class="hljs-number">3</span>、选择选择性最小的前缀来建立前缀索引<br></code></pre></td></tr></table></figure><h4 id="说一说索引下推"><a href="#说一说索引下推" class="headerlink" title="说一说索引下推"></a>说一说索引下推</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">索引下推是针对二级索引的一个优化，它能够减少回表的次数。<br><br>比如说现在有个联合索引(<span class="hljs-type">name</span>, age)<br><span class="hljs-type">name</span>使用模糊查询，age使用等值查询。 <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> &quot;张%&quot; <span class="hljs-keyword">and</span> age = <span class="hljs-number">20</span><br>按照最左前缀匹配，age没法使用索引了。<br>如果没有索引下推，那么MySQL引擎会将<span class="hljs-type">name</span> <span class="hljs-keyword">like</span> &quot;张%&quot; 查询到所有的数据返回给服务端，再去针对age进行匹配。<br>如果有了索引下推，那么MySQL引擎会先将age不匹配的数据过滤掉再返回给服务端，减少了回表的数据行大小。<br></code></pre></td></tr></table></figure><h4 id="怎么查看MySQL语句是否用到了索引"><a href="#怎么查看MySQL语句是否用到了索引" class="headerlink" title="怎么查看MySQL语句是否用到了索引"></a>怎么查看MySQL语句是否用到了索引</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">利用<span class="hljs-keyword">EXPLAIN</span>查看查询语句的相关信息。<br>比如：<br>    key：查询时真正用到的索引<br>    possible_key:可能用到的索引<br>    <span class="hljs-keyword">type</span>:判断查询是否高效的重要依据，记录了此次查询是方式：<span class="hljs-keyword">All</span>全表查询；<span class="hljs-keyword">ref</span>二级索引；const主键索引；<span class="hljs-keyword">index</span>覆盖索引等。<br>    <span class="hljs-keyword">rows</span>:扫面读取的数据行数<br></code></pre></td></tr></table></figure><h4 id="为什么官方建议使用自增长主键作为索引？"><a href="#为什么官方建议使用自增长主键作为索引？" class="headerlink" title="为什么官方建议使用自增长主键作为索引？"></a>为什么官方建议使用自增长主键作为索引？</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript">这跟B+树的特点有关，B+树的叶子节点存放的是所有数据，这些数据根据索引列的比较关系，从左往右是依次递增有序的。mysql 在底层又是以数据页为单位来存储数据的，一个数据页大小默认为 <span class="hljs-number">16</span>KB，如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据。<br><br>    如果主键为自增 <span class="hljs-built_in">id</span> 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。<br><br>    如果主键是非自增 <span class="hljs-built_in">id</span>，为了确保数据有序，mysql 就需要将每次插入的数据都放到合适的位置上，此时MySQL不得不为了将新记录插到合适位置而移动数据，造成大量的页分裂，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销。<br><br>自增索引的坏处是什么呢？<br>    对于高并发的负载，innodb在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争。<br></code></pre></td></tr></table></figure><h4 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span> (column_list);<br></code></pre></td></tr></table></figure><h4 id="创建索引时要注意什么？"><a href="#创建索引时要注意什么？" class="headerlink" title="创建索引时要注意什么？"></a>创建索引时要注意什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、索引字段越小越好<br>2、优先针对频繁访问的字段创建索引<br></code></pre></td></tr></table></figure><h4 id="建立索引的原则"><a href="#建立索引的原则" class="headerlink" title="建立索引的原则?"></a>建立索引的原则?</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>、最左前缀匹配原则<br><span class="hljs-number">2</span>、索引列不能参与计算<br><span class="hljs-number">3</span>、尽量选择区分度高的列作为索引列。<span class="hljs-built_in">count</span>(distince col) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>), 表明字段不重复的比例，比例越大，扫描的记录数量就越少。<br></code></pre></td></tr></table></figure><h4 id="什么情况下索引会失效？"><a href="#什么情况下索引会失效？" class="headerlink" title="什么情况下索引会失效？"></a>什么情况下索引会失效？</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-number">1</span>、使用 != 或者 &lt;&gt;<br><span class="hljs-number">2</span>、使用函数<br><span class="hljs-number">3</span>、运算符<br><span class="hljs-number">4</span><span class="hljs-built_in">、not</span> <span class="hljs-keyword">in</span> 和<span class="hljs-built_in"> not</span><span class="hljs-built_in"> exists</span><br><span class="hljs-number">5</span>、模糊匹配符%放到前面<br><span class="hljs-number">6</span>、OR可能导致失效(连接不同的字段)。可以将OR改为<span class="hljs-keyword">in</span>或者利用UNION<br></code></pre></td></tr></table></figure><h3 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h3><h4 id="什么是事务？有什么特性？"><a href="#什么是事务？有什么特性？" class="headerlink" title="什么是事务？有什么特性？"></a>什么是事务？有什么特性？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">事务是数据库中一系列操作的集合。<br>事务具有四个特性：<br>    1、原子性：事务中的所有操作，要么都执行，要么都不执行<br>    2、一致性：事务的执行前后，数据库的状态应该是保存一致的。<br>    3、隔离性：并发访问数据库的时候，一个事务不会影响另外一个事务，彼此是独立的。<br>    4、持久性：事务一旦提交，就永久的记录下来了。<br></code></pre></td></tr></table></figure><h4 id="并发执行的事务，可能出现哪些问题？"><a href="#并发执行的事务，可能出现哪些问题？" class="headerlink" title="并发执行的事务，可能出现哪些问题？"></a>并发执行的事务，可能出现哪些问题？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">脏读：一个事务读取了另外一个事务未提交的数据。<br>不可重复读：同一个事务，多次读取同一条记录，得到的结果不一样。<br>幻读：同一个事务，多次读取，得到的结果集不一样。<br></code></pre></td></tr></table></figure><h4 id="事务的隔离级别有哪些"><a href="#事务的隔离级别有哪些" class="headerlink" title="事务的隔离级别有哪些?"></a>事务的隔离级别有哪些?</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">读未提交：一个事务可以读取到另外一个事务未提交的数据。会导致脏读。<br>读已提交：一个事务只能读取到另外一个事务提交过的数据。解决了脏读，会出现不可重复读。<br>可重复读：同一个事务多次读取的结果是一样的，解决了不可重复读问题。<span class="hljs-comment">(MySQL的默认隔离级别)</span><br>串行化：所有事物串行执行，不会出现幻读。<br></code></pre></td></tr></table></figure><h4 id="可重复读隔离级别下是如何解决幻读问题的？"><a href="#可重复读隔离级别下是如何解决幻读问题的？" class="headerlink" title="可重复读隔离级别下是如何解决幻读问题的？"></a>可重复读隔离级别下是如何解决幻读问题的？</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">快照读：利用MVCC解决了幻读问题。<br>当前读：通过临间锁(<span class="hljs-built_in">next</span>-<span class="hljs-built_in">key</span> lock)解决了幻读问题。<br></code></pre></td></tr></table></figure><h4 id="MVCC是什么？"><a href="#MVCC是什么？" class="headerlink" title="MVCC是什么？"></a>MVCC是什么？</h4><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bnf">MVCC：多版本并发控制，可以实现读不加锁，因此写不阻塞，大大提升了系统的性能。<br><br>MVCC在每行记录的后面维护了两个隐藏列，创建版本号和删除版本号。<br>版本号就是事务的版本号，每开启一个事务都会给事务分配一个系统版本号，分配完之后系统版本号递增，这样一来，先开启的事务版本号低，后开启的事务版本号高。<br><br>插入操作：创建版本号填入当前事务的版本号<br><br>删除操作：删除版本号填入当前事务的版本号<br><br>更新操作：先对命中行做复制，将当前事务版本号写入旧的数据行中的删除版本号中。将当前事务版本号写入新的数据行中的创建版本号中。<br><br>查询操作：1、创建版本号 <span class="hljs-attribute">&lt;= 当前事务版本号   2、删除版本号为空，或者 &gt;</span>= 当前事务版本号<br></code></pre></td></tr></table></figure><h4 id="InnoDb引擎是如何实现事务的？"><a href="#InnoDb引擎是如何实现事务的？" class="headerlink" title="InnoDb引擎是如何实现事务的？"></a>InnoDb引擎是如何实现事务的？</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mel">原子性：事务包含的操作要么全部执行，要么全部不执行。<br>    原子性的实现是通过<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>。<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>主要记录了事务的行为，在事务执行过程中如果发生了错误终止了事务的执行，可以通过<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>对数据进行回滚。<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>日志通过存储数据库修改的逻辑日志来达到回滚的目的，比如,在进行回滚的时候,对于insert,InnoDB会完成一个<span class="hljs-keyword">delete</span>操作;对于<span class="hljs-keyword">delete</span>,InnoDB执行一个insert;对于update,InnoDB执行一个相反的update,来将修改前的行放回去。<br><br>    <span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>还有一个作用，就是实现MVCC，当用户读取一条记录的时候,若该记录已经被其他事务占用,当前事务可以通过<span class="hljs-keyword">undo</span>读取之前的行版本信息,通过此来实现非锁定读取。<br><br>隔离性：多个并发执行的事务应该相互隔离，不会互相干扰。<br>    隔离性的实现主要是通过锁，当某个事务需要访问某行数据，首先需要获得它的锁，之后才能继续访问。通过锁就可以很好的解决隔离性的问题，MySQL的默认隔离级别是可重复读，可以解决脏读、不可重复读问题。并且在行锁的基础上添加了间隙锁，还可以解决幻读的问题。<br><br>    虽然加锁可以解决隔离性，但是会造成读写冲突，影响系统的性能。因此，MySQL还提供MVCC，在不加锁的情况下实现对数据的读取，提高了系统性能。<br><br>持久性：事务一旦提交，那么它的修改就永远地保存在数据库之中。<br>    数据库中的数据都是存放在磁盘上的，但是由于磁盘太慢了，所以InnoDB提供了缓存(buffer pool)实现。Buffer pool中包含了对部分页的映射，在访问数据的时候会先从buffer pool里面查，没有的话再访问磁盘并将数据放入buffer pool。这样做虽然效率变高了，但是如果数据库突然宕机，buffer pool里面的页没来得及刷回到磁盘上，就会出现数据的丢失。<br><br>    InnoDB引擎利用<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>实现数据库的持久性，即使数据库突然宕机了，也能通过<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>进行数据恢复操作。<span class="hljs-keyword">redo</span>日志保存了对数据库的修改.并且,<span class="hljs-keyword">redo</span>日志是物理格式的,即记录的是对于每个页的修改,而不是具体的sql语句.并且<span class="hljs-keyword">redo</span>日志是预写式日志,也就是说,所有的修改会先写入<span class="hljs-keyword">redo</span>日志中,再更新到Buffer Pool。<br>    与此同时，InnoDB还提供<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> buffer，<span class="hljs-keyword">redo</span>日志会先写入到<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> buffer当中，再在一定的条件下刷回磁盘中。具体的刷盘策略有：<br>        <span class="hljs-number">1</span>、每秒刷一次<br>        <span class="hljs-number">2</span>、每次事务提交刷一次<br>        <span class="hljs-number">3</span>、buffer容量不足一半刷一次<br>    <br>    那么为什么把<span class="hljs-keyword">redo</span>日志写入磁盘比真正的数据写入磁盘快呢？<br>        <span class="hljs-number">1</span>、<span class="hljs-keyword">redo</span>日志是顺序IO，而数据的修改是随机的，也就是随机IO<br>        <span class="hljs-number">2</span>、<span class="hljs-keyword">redo</span>日志只写入真正修改的数据，而刷新脏页是以页为单位进行写入的，一页<span class="hljs-number">16</span>KB，即使只做了一点修改也要刷新整个页，造成无效IO太多。<br><br><br>一致性：原子性、隔离性、持久性是手段，那么一致性的目的就达到了。<br></code></pre></td></tr></table></figure><h4 id="redo-log、undo-log、bin-log"><a href="#redo-log、undo-log、bin-log" class="headerlink" title="redo log、undo log、bin log"></a>redo log、undo log、bin log</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>：记录事务执行的所有操作。主要是为了实现事务的持久性。<br><br><br><span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>：指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>。主要是为了实现事务的原子性，并且可以实现MVCC，<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供其他并发事务进行快照读。<br><br>bin <span class="hljs-keyword">log</span>：记录了数据库所有表的变更和表数据的变更。<br>    使用场景<span class="hljs-number">1</span>：主从复制<br>    流程：<span class="hljs-number">1</span>、从服务器启动一个IO线程读取主服务器的bin <span class="hljs-keyword">log</span>, 并写入到从服务器的临时<span class="hljs-keyword">log</span>中。<br>          <span class="hljs-number">2</span>、从服务器启动一个SQL线程，读取临时<span class="hljs-keyword">log</span>，执行一条条SQL语句。<br><br><span class="hljs-keyword">redo</span> + bin：防崩溃<br><span class="hljs-keyword">undo</span>: 回滚控制视图<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NC0092_最长公共子序列</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/NC0092_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/NC0092_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-<span class="hljs-number">1</span>。<br><br>示例<span class="hljs-number">1</span><br>输入:<span class="hljs-string">&quot;1A2C3D4B56&quot;</span>,<span class="hljs-string">&quot;B1D23CA45B6A&quot;</span><br>返回值:<span class="hljs-string">&quot;123456&quot;</span><br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j]: s1前i个字符和s2前j个字符的公共子序列的最长值<br><br>集合划分：(包含s1[i]且包含s2[j] || 包含s1[i]不包含s2[j] || 不包含s1[i]包含s2[j] || 都不包含)<br>         (dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> || dp[i][j-<span class="hljs-number">1</span>] || dp[i-<span class="hljs-number">1</span>][j] || dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])<br>         然而实则 dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]已经出现在了 dp[i][j-<span class="hljs-number">1</span>]和dp[i-<span class="hljs-number">1</span>][j]之中。<br><br>因此如果s1[i] == s2[j]: dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>否则：max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])<br><br>如何获取具体的序列？    <br>    保存转移状态：s1[i] == s2[j]  from[i][j] = <span class="hljs-number">0</span><br>                 dp[i-<span class="hljs-number">1</span>][j] &gt;= dp[i][j-<span class="hljs-number">1</span>] : 从i-<span class="hljs-number">1</span>转移过来，from[i][j] = <span class="hljs-number">1</span><br>                 dp[i][j-<span class="hljs-number">1</span>] &gt; dp[i-<span class="hljs-number">1</span>][j] : 从j-<span class="hljs-number">1</span>转移过来，from[i][j] = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">LCS</span> <span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">int</span> N = text1.length();<br>    <span class="hljs-keyword">int</span> M = text2.length();<br><br>    text1 = <span class="hljs-string">&quot; &quot;</span> + text1;<br>    text2 = <span class="hljs-string">&quot; &quot;</span> + text2;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][M + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[][] from = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][M + <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= M; j++) &#123;<br>            <span class="hljs-keyword">if</span> (text1.charAt(i) == text2.charAt(j)) &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                from[i][j] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j] &gt;= dp[i][j-<span class="hljs-number">1</span>])<br>                    from[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    from[i][j] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dp[N][M] == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">int</span> i = N, j = M;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (text1.charAt(i) == text2.charAt(j))<br>            sb.append(text1.charAt(i));<br>        <br>        <span class="hljs-comment">// 通过转移状态来移动i或者j，从而获取到s1[i] == s2[j]的状态</span><br>        <span class="hljs-keyword">if</span> (from[i][j] == <span class="hljs-number">0</span>) &#123;<br>            i--;<br>            j--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (from[i][j] == <span class="hljs-number">1</span>)<br>            i--;<br>        <span class="hljs-keyword">else</span> <br>            j--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>牛客网</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>公共子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NC0127_最长公共子串</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/NC0127_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/NC0127_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">给定两个字符串str1和str2,输出两个字符串的最长公共子串<br>题目保证str1和str2的最长公共子串存在且唯一。<br><br>示例<span class="hljs-number">1</span><br>输入: <span class="hljs-string">&quot;1AB2345CD&quot;</span>,<span class="hljs-string">&quot;12345EF&quot;</span><br>返回值 : <span class="hljs-string">&quot;2345&quot;</span><br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">dp[i][<span class="hljs-keyword">j]: </span><span class="hljs-built_in">s1</span>以下标i结尾和<span class="hljs-built_in">s2</span>以下标<span class="hljs-keyword">j结尾的最长公共子串的最大值</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">集合划分：(s1[i] </span>== <span class="hljs-built_in">s2</span>[<span class="hljs-keyword">j] </span><span class="hljs-title">||</span> <span class="hljs-built_in">s1</span>[i]  != <span class="hljs-built_in">s2</span>[<span class="hljs-keyword">j])</span><br><span class="hljs-keyword"> </span>        (dp[i][<span class="hljs-keyword">j] </span>= dp[i<span class="hljs-number">-1</span>][<span class="hljs-keyword">j-1] </span>+ <span class="hljs-number">1</span> <span class="hljs-title">||</span> <span class="hljs-number">0</span>)<br>         当i或者<span class="hljs-keyword">j为0时，i-1和j-1会溢出，因此当 </span>i == <span class="hljs-number">0</span> <span class="hljs-title">||</span> <span class="hljs-keyword">j </span>== <span class="hljs-number">0</span> 且 <span class="hljs-built_in">s1</span>[i] == <span class="hljs-built_in">s2</span>[<span class="hljs-keyword">j], </span>dp[i][<span class="hljs-keyword">j] </span>= <span class="hljs-number">1</span><br><br>出现更大的长度时，记录下标xIndex以及最大长度，则结果为<span class="hljs-built_in">s1</span>(xIndex - xMax + <span class="hljs-number">1</span>, xIndex + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">LCS</span> <span class="hljs-params">(String str1, String str2)</span> </span>&#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">int</span> n = str1.length();<br>    <span class="hljs-keyword">int</span> m = str2.length();<br>    <br>    <span class="hljs-comment">// str1以下标i结尾的和str2以下标j结尾的公共子串的长度最大值</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>    <br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录最大值</span><br>    <span class="hljs-keyword">int</span> xIndex = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录出现最大值的下标</span><br>            <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 如果s1[i] == s2[j]， dp[i][j] = dp[i-1][j-1] + 1</span><br>            <span class="hljs-comment">// 如果s1[i] != s2[j], dp[i][j] = 0</span><br>            <span class="hljs-keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <br>            &#125;<br>                <br>            <span class="hljs-keyword">if</span> (xMax &lt; dp[i][j]) &#123;<br>                xMax = dp[i][j];<br>                xIndex = i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (xMax == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">return</span> str1.substring(xIndex - xMax + <span class="hljs-number">1</span>, xIndex + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>牛客网</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>公共子串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的前中后序遍历</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">实现二叉树的前、中、后序的递归遍历和非递归遍历<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归实现</span><br>ArrayList&lt;Integer&gt; arr1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    arr1.add(root.val);<br>    preOrder(root.left);<br>    preOrder(root.right);<br>&#125;<br><br>ArrayList&lt;Integer&gt; arr2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    inOrder(root.left);<br>    arr2.add(root.val);<br>    inOrder(root.right);<br>&#125;<br><br>ArrayList&lt;Integer&gt; arr3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    postOrder(root.left);<br>    postOrder(root.right);<br>    arr3.add(root.val);<br>&#125;<br><br><span class="hljs-comment">// 非递归实现</span><br>ArrayList&lt;Integer&gt; arr1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span>;<br>    <br>    Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    st.push(root);<br>    <br>    TreeNode temp;<br>    <span class="hljs-keyword">while</span> (!st.isEmpty()) &#123;<br>        temp = st.pop();<br>        <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 按照相反的方向push进去</span><br>            <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-keyword">null</span>) st.push(temp.right);<br>            <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-keyword">null</span>) st.push(temp.left);<br>            st.push(temp);<br>            st.push(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果是null，则下一个是访问的节点</span><br>            arr1.add(st.pop().val);<br>        &#125;<br>    &#125;<br>&#125;<br><br>ArrayList&lt;Integer&gt; arr2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span>;<br>    <br>    Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    st.push(root);<br>    <br>    TreeNode temp;<br>    <span class="hljs-keyword">while</span> (!st.isEmpty()) &#123;<br>        temp = st.pop();<br>        <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 按照相反的方向push进去</span><br>            <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-keyword">null</span>) st.push(temp.right);<br>            st.push(temp);<br>            st.push(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-keyword">null</span>) st.push(temp.left);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果是null，则下一个是访问的节点</span><br>            arr2.add(st.pop().val);<br>        &#125;<br>    &#125;<br>&#125;<br><br>ArrayList&lt;Integer&gt; arr3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span>;<br>    <br>    Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    st.push(root);<br>    <br>    TreeNode temp;<br>    <span class="hljs-keyword">while</span> (!st.isEmpty()) &#123;<br>        temp = st.pop();<br>        <span class="hljs-keyword">if</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 按照相反的方向push进去</span><br>            st.push(temp);<br>            st.push(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-keyword">null</span>) st.push(temp.right);<br>            <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-keyword">null</span>) st.push(temp.left);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果是null，则下一个是访问的节点</span><br>            arr3.add(st.pop().val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC146_LRU缓存机制</title>
    <link href="/2021/04/06/%E7%AE%97%E6%B3%95/LC0146_%E8%AE%BE%E8%AE%A1LRU%E7%BC%93%E5%AD%98/"/>
    <url>/2021/04/06/%E7%AE%97%E6%B3%95/LC0146_%E8%AE%BE%E8%AE%A1LRU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">LRU缓存底层使用 哈希表 + 双向链表。双向链表中存放缓存节点<span class="hljs-keyword">Node</span><span class="hljs-title">, 哈希表记录&lt;key</span>, <span class="hljs-keyword">Node</span><span class="hljs-title">&gt;之间的映射。</span><br><span class="hljs-title"></span><br><span class="hljs-title">put</span>(int key, int value)的逻辑：<br>    <span class="hljs-number">1</span>、生成新节点<span class="hljs-keyword">Node</span><span class="hljs-title">(key</span>, value)<br>    <span class="hljs-number">2</span>、放入之前先判断该key的节点是否存在，如果存在则直接访问并且将该节点放到链表头并更新哈希表key对应的<span class="hljs-keyword">Node</span><span class="hljs-title">。</span><br><span class="hljs-title">    3</span>、如果不存在，先判断缓存是否满了，如果满了则先删除链表尾节点(同时更新哈希表)，然后将新节点插入到链表头(同时更新哈希表)<br>    <span class="hljs-number">4</span>、如果没满，则直接插入到链表头并更新哈希表即可<br><br>get(int key)的逻辑：<br>    <span class="hljs-number">1</span>、直接返回哈希表key对应的节点<span class="hljs-keyword">Node</span><span class="hljs-title"></span><br><span class="hljs-title">    2</span>、将该节点从原链表删除并插入到头节点处。<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 缓存节点定义</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 哈希表 + 双向链表</span><br><span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-keyword">private</span> LinkedList&lt;Node&gt; cache = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;<br><br><span class="hljs-comment">// 放入新节点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(key, value);<br>    <br>    <span class="hljs-keyword">if</span> (m.containsKey(key)) &#123;<br>        cache.remove(m.get(key));<br>        cache.addFirst(node);<br>        m.put(key, node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 判断容量是否满了</span><br>        <span class="hljs-keyword">if</span> (cache.size() == cap) &#123;<br>            Node last = cache.removeLast();<br>            m.remove(last.key);<br>        &#125;<br>        <br>        cache.addFirst(node);<br>        m.put(key, node);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 访问key</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!m.containsKey(key))<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <br>    Node res = m.get(key);<br>    cache.remove(res);<br>    put(key, res.value);<br>    <span class="hljs-keyword">return</span> res.value;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU缓存</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态压缩DP</title>
    <link href="/2021/03/31/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    <url>/2021/03/31/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
    
    <content type="html"><![CDATA[<h3 id="题目特点"><a href="#题目特点" class="headerlink" title="题目特点"></a>题目特点</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、数据范围不会超过<span class="hljs-number">24</span><br><span class="hljs-attribute">2</span>、dp值虽然是一个整数，但是需要看成二进制，每一位的<span class="hljs-number">01</span>表示不同的状态<br></code></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 状态压缩DP中常用的位运算</span><br><br><span class="hljs-keyword">int</span> A, B;   <span class="hljs-comment">// 集合A、B</span><br><span class="hljs-keyword">long</span> C;     <span class="hljs-comment">// 集合C</span><br><br>A |= <span class="hljs-number">1</span> &gt;&gt; x;    <span class="hljs-comment">// 将x(x = 0 ~ 31)加入到集合A</span><br>A &amp;= ~(<span class="hljs-number">1</span> &gt;&gt; x); <span class="hljs-comment">// 将x(x = 0 ~ 31)从集合A删除</span><br>A ^= <span class="hljs-number">1</span> &gt;&gt; x;    <span class="hljs-comment">// 将x(x = 0 ~ 31)从集合A删除</span><br><br>x &amp; (-x);       <span class="hljs-comment">// 获取x最后一位1</span><br>A = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 清空集合A</span><br>A | B;          <span class="hljs-comment">// 取集合A和B的并集</span><br>A &amp; B;          <span class="hljs-comment">// 取集合A和B的交集</span><br><br><span class="hljs-keyword">int</span> si = <span class="hljs-number">15</span>;<br><span class="hljs-keyword">int</span> All = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>) - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 建立大小为15的全集</span><br><br>All ^ A;        <span class="hljs-comment">// 求全集中A的补集</span><br><br>(A &amp; B) == B;   <span class="hljs-comment">// 判断B是否为A的子集</span><br><br><span class="hljs-comment">// 枚举全集All的所有子集</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= ALL; i++) &#123;    &#125;<br><br><span class="hljs-comment">// 枚举集合A的所有子集</span><br><span class="hljs-keyword">int</span> subset = A;<br><span class="hljs-keyword">do</span> &#123;<br>    subset = (subset - <span class="hljs-number">1</span>) &amp; A;<br>&#125; <span class="hljs-keyword">while</span> (subset != A)<br><br><span class="hljs-comment">// 计算集合A的元素的个数</span><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A; A &gt; <span class="hljs-number">0</span>; A &gt;&gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>    cnt += i &amp; <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 预处理每个子集的元素个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; pow(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>); i++)<br>    cnt[i] = cnt[i &gt;&gt; <span class="hljs-number">1</span>] + (i &amp; <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 判断x是否为2的幂次方</span><br>x != <span class="hljs-number">0</span> &amp;&amp; x &amp; (x - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ---&gt; x &amp;&amp; !(x &amp; (x - <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h3 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">求把 N×M 的棋盘分割成若干个 1×2 的的长方形，有多少种方案。<br><br>例如当 <span class="hljs-attribute">N</span>=2，M=4 时，共有 5 种方案。当 <span class="hljs-attribute">N</span>=2，M=3 时，共有 3 种方案。<br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    n x m 的矩阵：</span><br><span class="hljs-comment">        - - - - -</span><br><span class="hljs-comment">        - - - - -</span><br><span class="hljs-comment">        - - - - -</span><br><span class="hljs-comment">        - - - - -</span><br><span class="hljs-comment">    1代表该位置放了东西，0代表该位置没放东西。</span><br><span class="hljs-comment">    由于长方形是 1 x 2 的, 横着放是： 1 1 0 0 0  竖着放是： 1 0 0 0 0</span><br><span class="hljs-comment">                                                         1 0 0 0 0</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    核心: 先放横着的，再放竖着的(竖着的只有唯一1种方案，塞进去就可以)。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    因此总方案数 = 只放横着的所有合法方案数</span><br><span class="hljs-comment">    如何判断当前方案是否合法？  所有剩余位置能否通过竖着的填充满。可以按列来看，每一列内部所有连续的1没有奇数个(所有连续空着的0是2的倍数)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 表示已经将前i-1列摆好，且从第i-1列，伸到第i列的状态是j的所有方案数。  因为横着放：放到第i-1列的可能伸到第i列。  1表示伸到了，0表示没伸到。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]肯定是由dp[i-1][k]转移过来。由于由n行，所有k有2 ^ n个可能。</span><br><span class="hljs-comment">    但是需要保证以下条件才可以转移:</span><br><span class="hljs-comment">        (1) j &amp; k == 0: 不能在同一行。上一行都伸出来了1, 那该列该位置肯定不能横着放了</span><br><span class="hljs-comment">        (2) k的二进制所有连续空着的0必须是2的倍数。这样才能插入竖着的</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    最后返回的结果是 dp[m][0]: 最后一列所有方块不能再伸出来了。</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位统计DP</title>
    <link href="/2021/03/31/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/"/>
    <url>/2021/03/31/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/</url>
    
    <content type="html"><![CDATA[<h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9 的出现次数。<br><br>例如，a=1024，b=1032，则 a 和 b 之间共有<span class="hljs-number"> 9 </span>个数如下：<br><br>1024<span class="hljs-number"> 1025 </span>1026<span class="hljs-number"> 1027 </span>1028<span class="hljs-number"> 1029 </span>1030<span class="hljs-number"> 1031 </span>1032<br><br>其中<span class="hljs-number"> 0 </span>出现<span class="hljs-number"> 10 </span>次，1 出现<span class="hljs-number"> 10 </span>次，2 出现<span class="hljs-number"> 7 </span>次，3 出现<span class="hljs-number"> 3 </span>次等等…<br></code></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">数位DP最重要的一点：分情况讨论<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP</title>
    <link href="/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP(%E9%87%8D%E8%A6%81)/"/>
    <url>/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP(%E9%87%8D%E8%A6%81)/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li></li></ul></blockquote><h3 id="什么叫可靠传输？"><a href="#什么叫可靠传输？" class="headerlink" title="什么叫可靠传输？"></a>什么叫可靠传输？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">简单来说，一方给另外一方发送消息，只需要保证按序到达、无错误、不丢失、不重复即可认为是可靠传输。<br></code></pre></td></tr></table></figure><h3 id="如何做到可靠传输"><a href="#如何做到可靠传输" class="headerlink" title="如何做到可靠传输?"></a>如何做到可靠传输?</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">先考虑最简单的情况：<br><span class="hljs-code">    为了保证按序到达：发送方发送一个消息就等待对方发送确认信息，确认收到后才发送下一个。因此TCP提供消息确认机制ACK。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了保证无错误：提供检测错误的能力。比如TCP报文段有一个检验和机制，用来确认是否发生错误。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了保证不丢失：发生丢失则重传该消息。TCP提供超时重传机制(每发送一个分组就启动计时器)。若发送方在一个往返时延RTT没有收到确认信息则认为发生了丢失情况，因此重新发送。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了避免重复：给每个消息一个序号。TCP提供序号机制。如果发送方发送一个分组经历了很大的时延才到达接收方，可能中途已经触发了超时重传，因此会再次发送该分组，结果第一个分组已经到了，第二个相同的分组就成为了冗余分组，通过添加序号机制能够很方便的分辨冗余分组。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h3 id="停等协议效率太低，如何解决？"><a href="#停等协议效率太低，如何解决？" class="headerlink" title="停等协议效率太低，如何解决？"></a>停等协议效率太低，如何解决？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">发送方一个一个发送消息，效率太慢。因此TCP提供了滑动窗口协议，以流水线的形式将窗口内的消息一一发送出去，而不用等待第一个确认正确到达才发送第二个。<br><br>根据接收方的行为不同，提供一下两种协议：<br><br><span class="hljs-code">    回退N帧协议：接收方的接收窗口设置为1，即使发送方以流水线的形式发送多个消息，接收方也是按序接收，出现失序分组则会丢弃，同时返回最后一个正确分组的编号。当接收方收到确认消息，它会将从确认序号继续发送。其缺点是：当窗口很大的时候可能需要重传大量分组。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">    选择重传协议：接收方的接收窗口不再是1，一般设置为发送窗口大小的一半。接收方接受分组的时候，出现在接收窗口内的分组，即使没有按序到达也会先缓存起来，并返回确认信息。直到序号更小的分组到达才一起交付给上层。因此，发送方只需要重新发送未正确接收的分组即可。</span><br></code></pre></td></tr></table></figure><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">作用：抑制发送方的发送速率，避免发送速率比接收方应用程序的读取速率大，导致接收缓冲区的溢出。<br><br>接收方控制发送窗口的大小，当服务端过于繁忙时，发送窗口可能会变为0。这个时候，发送方会启动一个计时器，超时就会发送一个探测报文，如果发送窗口不为0，则发送报文，如果仍然为0，则重启计时器。<br></code></pre></td></tr></table></figure><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nix">为什么需要拥塞控制：<br>    计算机网络是一个共享的环境，在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，就会进入恶性循环。<br><br>作用：发送方维护一个拥塞窗口，它能根据网络环境动态地变换，当发生了超时重传就认为出现了拥塞，从而降低发送量，避免数据填满整个网络。<br><br><br>慢启动：当TCP建立连接后，一点点提升发送量。当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会翻倍，呈指数级增长。<br><br><br>拥塞避免：当 cwnd &gt;= ssthresh(<span class="hljs-number">65535</span>)后，它收到<span class="hljs-number">1</span>个ACK，则cwnd加<span class="hljs-number">1</span>，呈线性增长。<br><br><br>拥塞发生：当发生了重传情况，如果是超时导致的重传，则<span class="hljs-attr">ssthresh</span> = cwnd / <span class="hljs-number">2</span>, <span class="hljs-attr">cwnd</span> = <span class="hljs-number">1</span>, 然后进入慢启动。如果是快速重传，则<span class="hljs-attr">sshtresh</span> = cwnd, <span class="hljs-attr">cwnd</span> = cwnd / <span class="hljs-number">2</span>，然后进入快恢复。<br><br><br>快恢复：<br>    <span class="hljs-number">1</span>、拥塞窗口 <span class="hljs-attr">cwnd</span> = ssthresh + <span class="hljs-number">3</span><br>    <span class="hljs-number">2</span>、重传丢失的数据包<br>    <span class="hljs-number">3</span>、如果再收到重复的 ACK，那么 cwnd 增加 <span class="hljs-number">1</span><br>    <span class="hljs-number">4</span>、如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法<br></code></pre></td></tr></table></figure><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><h4 id="建立连接的过程"><a href="#建立连接的过程" class="headerlink" title="建立连接的过程"></a>建立连接的过程</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">1、客户端随机生成初始化序列号(client_isn)并填充到TCP首部的序号字段中，然后将SYN置为1。然后发送给服务端。该报文不包括应用层数据，之后客户端进入SYN-SEND状态。<br><br>2、服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn）并填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。<br><br>3、客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为<span class="hljs-number"> 1 </span>，其次「确认应答号」字段填入 server_isn +<span class="hljs-number"> 1 </span>，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。<br><br>一旦完成三次握手，双方都处于 ESTABLISHED 状态，此致连接就已建立完成，客户端和服务端就可以相互发送数据了。<br></code></pre></td></tr></table></figure><h4 id="为什么需要三次握手，而不是两次或四次"><a href="#为什么需要三次握手，而不是两次或四次" class="headerlink" title="为什么需要三次握手，而不是两次或四次?"></a>为什么需要三次握手，而不是两次或四次?</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown">一、三次握手才可以阻止历史重复连接的初始化<br><span class="hljs-code">    客户端连续发送多个SYN请求连接报文，在网络拥堵的情况下：</span><br><span class="hljs-code">        1、一个[旧的请求报文]在[新的请求报文]之前到达。</span><br><span class="hljs-code">        2、服务端返回SYN+ACK的确认报文给客户端。</span><br><span class="hljs-code">        3、客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端有足够的上下文来判断当前连接是否是历史连接，从而在第三次发送不同的报文：</span><br><span class="hljs-code">        1、如果是历史连接，则发送RST报文终止此次连接。</span><br><span class="hljs-code">        2、如果是新连接，则发送ACK报文来建立连接。</span><br><span class="hljs-code"></span><br><span class="hljs-code">二、三次握手才可以同步双方的初始序列号</span><br><span class="hljs-code">    序列号在可靠传输中非常的重要。通过序列号：</span><br><span class="hljs-code">        1、接收方能够确定冗余分组</span><br><span class="hljs-code">        2、接收方能够根据序列号按序接收</span><br><span class="hljs-code">        3、可以标识发送出去的数据包中， 哪些是已经被对方收到的</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    因此通信双方都必须确定对方可以正确接收自己的序列号。</span><br><span class="hljs-code">    而两次握手只有客户端确定自己的初始序列号被对方接收，而服务端不确定自己的初始序列号能被对方接收。</span><br><span class="hljs-code"></span><br><span class="hljs-code">三、三次握手才可以避免资源浪费</span><br><span class="hljs-code">    如果只有「两次握手」，当服务端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，从而建立多个冗余的无效链接，造成不必要的资源浪费。</span><br></code></pre></td></tr></table></figure><h4 id="初始序列号是如何生成的？"><a href="#初始序列号是如何生成的？" class="headerlink" title="初始序列号是如何生成的？"></a>初始序列号是如何生成的？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ISN</span> = M + F<br>M是一个计时器。每隔四毫米加<span class="hljs-number">1</span><br>F是一个哈希算法。根据源 <span class="hljs-built_in">IP</span>、目的 <span class="hljs-built_in">IP</span>、源端口、目的端口生成一个随机数值。<br></code></pre></td></tr></table></figure><h4 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">如果只有<span class="hljs-built_in">IP</span>层分片，那么当如果一个 <span class="hljs-built_in">IP</span> 分片丢失，整个 <span class="hljs-built_in">IP</span> 报文的所有分片都得重传。因为<span class="hljs-built_in">IP</span>层没有重传机制，最后还得传输层来进行重传。如果传输层不分片，那么需要传输整个TCP报文段。<br><br>经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。<br></code></pre></td></tr></table></figure><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><h4 id="断开连接的过程"><a href="#断开连接的过程" class="headerlink" title="断开连接的过程"></a>断开连接的过程</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、客户端发送FIN报文，请求关闭连接。客户端之后进入FIN_WAIT_<span class="hljs-number">1</span>状态。<br><span class="hljs-attribute">2</span>、服务端收到后，回复ACK应答报文。服务端之后进入CLOSE_WAIT状态。客户端收到ACK后进入FIN_WAIT_<span class="hljs-number">2</span>状态。<br><span class="hljs-attribute">3</span>、服务端处理完数据后，向客户端发送FIN报文。服务端进入LAST_ACK状态。<br><span class="hljs-attribute">4</span>、客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文。客户端之后进入 TIME_WAIT 状态（主动关闭连接的才有TIME_WAIT状态）。服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。客户端在经过 <span class="hljs-number">2</span>MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。<br></code></pre></td></tr></table></figure><h4 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">关闭连接时，客户端向服务端发送FIN报文，仅仅表示客户端不再向服务端主动发送数据，但是还可以接收数据。<br><br>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。<br><br>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。<br></code></pre></td></tr></table></figure><h4 id="为什么TIME-WAIT状态的等待时间是2MSL？"><a href="#为什么TIME-WAIT状态的等待时间是2MSL？" class="headerlink" title="为什么TIME_WAIT状态的等待时间是2MSL？"></a>为什么TIME_WAIT状态的等待时间是2MSL？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">MSL:</span> 报文最大生存时间。它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<br><br><span class="hljs-symbol">MSL</span> 与 <span class="hljs-meta">TTL</span> 的关系：TCP 报文基于是 <span class="hljs-built_in">IP</span> 协议的，而 <span class="hljs-built_in">IP</span> 头中有一个 <span class="hljs-meta">TTL</span> 字段，是 <span class="hljs-built_in">IP</span> 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 <span class="hljs-number">1</span>，当此值为 <span class="hljs-number">0</span> 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。MSL 的单位是时间，而 <span class="hljs-meta">TTL</span> 是经过路由跳数。所以 MSL 应该要大于等于 <span class="hljs-meta">TTL</span> 消耗为 <span class="hljs-number">0</span> 的时间，以确保报文已被自然消亡。<br><br><span class="hljs-number">2</span>倍的MSL：客户端发送数据给服务端，服务端需要处理之后再返回消息。一来一回就是<span class="hljs-number">2</span>倍的MSL。<br><br><span class="hljs-number">2</span>MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <span class="hljs-number">2</span>MSL 时间将重新计时。<br></code></pre></td></tr></table></figure><h4 id="为什么需要-TIME-WAIT-状态"><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态?"></a>为什么需要 TIME_WAIT 状态?</h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-number">1</span>、防止收到旧连接的数据包而产生数据错乱等严重的问题。<br>    比如：服务端在断开连接之前发送了一个报文被延迟了，这时有相同端口的 TCP 连接被复用后，被延迟的报文抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。<br>    经过 <span class="hljs-number">2</span>MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。<br><br><span class="hljs-number">2</span>、确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。<br>    假如TIME_WAIT时间过短，那么第四步挥手主动关闭方发送完ACK就会马上进入<span class="hljs-keyword">CLOSE</span>状态，但是这个ACK可能会丢失从而导致被动关闭方一直处于LAST_ACK状态。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>传输层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/SMTP/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FTP</title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/FTP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/FTP/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>FTP是文件传输协议，使用TCP提供可靠传输，一个FTP服务器可以为多个客户进程提供服务。</li><li>FTP使用两个并行的TCP连接，一个是控制连接(21端口), 一个数据连接(20端口)。</li></ul></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 服务端监听<span class="hljs-number">21</span>号端口，等待客户端的连接<br><span class="hljs-comment">(2)</span> 客户端发起连接请求后，启动数据连接处理客户端请求，处理完毕后，数据连接关闭。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DHCP</title>
    <link href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP/"/>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>DHCP协议是：动态主机配置协议，用来动态的给加入网络的主机分配IP地址。</li><li>DHCP客户端使用UDP协议，端口号68</li><li>DHCP服务端使用TCP协议，端口号67</li></ul></blockquote><h3 id="DHCP的工作流程"><a href="#DHCP的工作流程" class="headerlink" title="DHCP的工作流程"></a>DHCP的工作流程</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-number">1</span>) 一个新加入的主机，需要向DHCP服务器申请<span class="hljs-built_in">IP</span>地址。由于刚开始它没有<span class="hljs-built_in">IP</span>地址，因此它源<span class="hljs-built_in">IP</span>地址全部设为<span class="hljs-number">0</span>，目的<span class="hljs-built_in">IP</span>地址全部设为<span class="hljs-number">1</span>. 以广播的方式发送DHCPDISCOVER报文。<br><br>(<span class="hljs-number">2</span>) 凡是收到DHCPDISCOVER报文的DHCP服务器都发出DHCP提供报文，DHCP客户端从中选择一个，并向所选择的DHCP服务器发送DHCP请求报文。<br><br>(<span class="hljs-number">3</span>) 被选择的DHCP服务器发送DHCPACK的确认报文并提供<span class="hljs-built_in">IP</span>地址给DHCP客户端使用。DHCP客户端设置使用时限。<br><br>(<span class="hljs-number">4</span>) 当使用时限过半时，DHCP客户端申请重新设置计时器。如果服务器同意则发回确认报文DHCPACK，客户端继续使用<span class="hljs-built_in">IP</span>；否则发送否认报文DHCPNACK，客户端需要重新申请<span class="hljs-built_in">IP</span>。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DHCP</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS</title>
    <link href="/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/"/>
    <url>/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>DNS提供的服务：提供主机名到IP地址的解析功能。</li><li>DNS协议运行于UDP协议之上，使用53号端口。</li></ul></blockquote><h3 id="DNS工作步骤"><a href="#DNS工作步骤" class="headerlink" title="DNS工作步骤"></a>DNS工作步骤</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) 用户输入网址，浏览器首先检查是否有主机名到IP地址的映射缓存<br>(<span class="hljs-number">2</span>) 没有就检查本地host文件看是否有<br>(<span class="hljs-number">3</span>) 没有就询问本地DNS服务器<br>(<span class="hljs-number">4</span>) 本地DNS服务器没有的话，就会询问根DNS服务器<br>(<span class="hljs-number">5</span>) 根DNS服务器返回顶级域服务器地址，本地DNS服务器接着询问顶级域服务器<br>(<span class="hljs-number">6</span>) 顶级域服务器返回权威DNS服务器地址，本地DNS服务器接着询问权威DNS服务器地址。<br>(<span class="hljs-number">7</span>) 权威DNS服务器返回IP地址返回给本地DNS服务器。<br>(<span class="hljs-number">8</span>) 本地DNS服务器将结果返回给主机。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP(%E9%87%8D%E8%A6%81)/"/>
    <url>/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/HTTP(%E9%87%8D%E8%A6%81)/</url>
    
    <content type="html"><![CDATA[<h3 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h3><blockquote><ul><li>HTTP(超文本传输协议)是web应用所使用的协议</li><li>HTTP使用TCP作为它的支撑运输的协议</li><li>HTTP是无状态的协议</li></ul></blockquote><h3 id="非持续连接-vs-持续连接"><a href="#非持续连接-vs-持续连接" class="headerlink" title="非持续连接 vs 持续连接"></a>非持续连接 vs 持续连接</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">非持续连接：每一个请求/响应对都是经过单独的TCP连接。<br>持续连接：所有的请求/响应对都是经过同一个TCP连接。<br><br>比如：客户端向服务端发送一个HTTP请求，假设该请求页面包含<span class="hljs-number">1</span>个<span class="hljs-selector-tag">HTML</span>页面和<span class="hljs-number">10</span>个JPEG图片，那么采用非持续连接就需要建立<span class="hljs-number">11</span>次TCP连接，而采用持续连接仅需要一个TCP连接。<br></code></pre></td></tr></table></figure><h3 id="HTTP请求格式和响应格式"><a href="#HTTP请求格式和响应格式" class="headerlink" title="HTTP请求格式和响应格式"></a>HTTP请求格式和响应格式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">请求报文:<br><span class="hljs-code">    请求行：</span><br><span class="hljs-code">        方法 URL 版本</span><br><span class="hljs-code"></span><br><span class="hljs-code">    首部行: </span><br><span class="hljs-code">        host</span><br><span class="hljs-code">        Connection</span><br><span class="hljs-code">        ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    实体：</span><br><span class="hljs-code"></span><br><span class="hljs-code">响应报文：</span><br><span class="hljs-code">    状态行:</span><br><span class="hljs-code">        版本 状态码 短语</span><br><span class="hljs-code"></span><br><span class="hljs-code">    首部行：</span><br><span class="hljs-code">        Connection</span><br><span class="hljs-code">        Date</span><br><span class="hljs-code">        Last-Modified</span><br><span class="hljs-code">        Content-Length</span><br><span class="hljs-code">        Content-Type</span><br><span class="hljs-code">        ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    实体：</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h3 id="HTTP常见的状态码和含义"><a href="#HTTP常见的状态码和含义" class="headerlink" title="HTTP常见的状态码和含义"></a>HTTP常见的状态码和含义</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">200</span>: 成功<br><span class="hljs-number">204</span>：与<span class="hljs-number">200</span>相同，响应头没有body数据<br><span class="hljs-number">206</span>：是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。<br><br><span class="hljs-number">301</span>:表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。<br><span class="hljs-number">302</span>：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br><span class="hljs-symbol">301 </span>和 <span class="hljs-number">302</span> 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。<br><br><span class="hljs-number">400</span>:表示客户端请求的报文有错误<br><span class="hljs-number">403</span>:表示服务器禁止访问资源<br><span class="hljs-number">404</span>:资源未找到<br><br><span class="hljs-number">500</span>:与 <span class="hljs-number">400</span> 类型，是个笼统通用的错误码<br><span class="hljs-number">503</span>:表示服务器当前很忙，暂时无法响应服务器<br></code></pre></td></tr></table></figure><h3 id="Get-和-Post-的区别"><a href="#Get-和-Post-的区别" class="headerlink" title="Get 和 Post 的区别"></a>Get 和 Post 的区别</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Get:向服务器获取资源; Post向指定的URI提交数据，数据保存在<span class="hljs-selector-tag">body</span>中。<br>Get:是安全且幂等的; Post不是安全也不是幂等的。<br><br>安全性：请求方法不会「破坏」服务器上的资源。<br>幂等性: 多次执行相同的操作，结果都是「相同」的。<br></code></pre></td></tr></table></figure><h3 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">由于HTTP是无状态协议，如果想要保存用户的状态信息，则出现了Cookie机制和<span class="hljs-keyword">Session</span>机制。<br><br>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，获取状态信息。<br><br>然后Cookie需要保存的信息比较多，比如<span class="hljs-type">name</span>，<span class="hljs-keyword">value</span>，maxAge等。如果HTTP请求每次都需要携带Cookie完整信息，那么增加了客户端与服务端的数据传输量。因此就出现了<span class="hljs-keyword">Session</span>机制，同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 SessionID。<br><br><span class="hljs-keyword">Session</span>是一种服务端的机制，用户信息保存在服务器端，服务端为每一个客户创建<span class="hljs-keyword">Session</span>并利用SessionID进行关联。<br></code></pre></td></tr></table></figure><h3 id="HTTP-和-HTTPS-有哪些区别？"><a href="#HTTP-和-HTTPS-有哪些区别？" class="headerlink" title="HTTP 和 HTTPS 有哪些区别？"></a>HTTP 和 HTTPS 有哪些区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之计算机网络</title>
    <link href="/2021/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="从一个URL到获取页面的过程？"><a href="#从一个URL到获取页面的过程？" class="headerlink" title="从一个URL到获取页面的过程？"></a>从一个URL到获取页面的过程？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(<span class="hljs-number">1</span>) 浏览器查询DNS，获取域名对应的<span class="hljs-built_in">IP</span>地址。具体过程包括: 浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的host文件、像本地DNS服务器进行查询。<br><br>(<span class="hljs-number">2</span>) 获取对应的<span class="hljs-built_in">IP</span>地址以后，向服务器请求建立连接，发起TCP三次握手。<br><br>(<span class="hljs-number">3</span>) 连接建立以后，浏览器发起HTTP请求<br><br>(<span class="hljs-number">4</span>) 服务器收到请求以后，处理请求并返回相应的视图。<br><br>(<span class="hljs-number">5</span>) 浏览器解析并渲染视图。如果有对<span class="hljs-keyword">js</span>、css及图片等静态资源的引用，则重复HTTP请求获取相应的资源。<br><br>(<span class="hljs-number">6</span>) 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。<br></code></pre></td></tr></table></figure><h3 id="DNS工作步骤"><a href="#DNS工作步骤" class="headerlink" title="DNS工作步骤"></a>DNS工作步骤</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">1</span>) 用户输入网址，浏览器首先检查是否有主机名到IP地址的映射缓存，没有就查找操作系统的DNS缓存<br>(<span class="hljs-number">2</span>) 没有就检查本地host文件看是否有<br>(<span class="hljs-number">3</span>) 没有就询问本地DNS服务器<br>(<span class="hljs-number">4</span>) 本地DNS服务器没有的话，就会询问根DNS服务器<br>(<span class="hljs-number">5</span>) 根DNS服务器返回顶级域服务器地址，本地DNS服务器接着询问顶级域服务器<br>(<span class="hljs-number">6</span>) 顶级域服务器返回权威DNS服务器地址，本地DNS服务器接着询问权威DNS服务器地址。<br>(<span class="hljs-number">7</span>) 权威DNS服务器返回IP地址返回给本地DNS服务器。<br>(<span class="hljs-number">8</span>) 本地DNS服务器将结果返回给主机。<br></code></pre></td></tr></table></figure><h3 id="SYN泛洪攻击？"><a href="#SYN泛洪攻击？" class="headerlink" title="SYN泛洪攻击？"></a>SYN泛洪攻击？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">SYN</span>攻击的原理是攻击端利用伪造的<span class="hljs-built_in">IP</span>地址向被攻击端发出请求，而被攻击端发出的响应报文将永远发送不到目的地，那么被攻击端在等待关闭这个连接的过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。<br><br><span class="hljs-symbol">SYN</span>攻击是利用了三次握手机制。在三次握手期间，服务端会维护两个队列，一个是半连接队列，一个是全连接队列。当完成第二次握手，也就是服务端返回SYN+ACK的确认报文，服务端就会将这次连接信息放入半连接队列中维护，正常情况下，完成三次握手就会将半连接队列中的连接放入全连接队列，而如果发起大量的恶意请求，就会导致半连接队列满掉，这样一来正常的连接就没法的得到服务端的响应。<br><br>防御手段：<br>    <span class="hljs-number">1</span>、防止一个<span class="hljs-built_in">IP</span>多次访问<br>    <span class="hljs-number">2</span>、降低SYN的timeout时间<br></code></pre></td></tr></table></figure><h3 id="Session的实现原理-和-Cookie的实现原理？"><a href="#Session的实现原理-和-Cookie的实现原理？" class="headerlink" title="Session的实现原理 和 Cookie的实现原理？"></a>Session的实现原理 和 Cookie的实现原理？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。<br><br><span class="hljs-keyword">Session</span> 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。使用上比 Cookie 简单一些，相应的也增加了服务器的存储压力。<br><br>总体来说：Cookie 通过在客户端记录信息确定用户身份，<span class="hljs-keyword">Session</span> 通过在服务器端记录信息确定用户身份。<br></code></pre></td></tr></table></figure><h3 id="Session和Cooike的关系？禁用Cookie对Session的影响？"><a href="#Session和Cooike的关系？禁用Cookie对Session的影响？" class="headerlink" title="Session和Cooike的关系？禁用Cookie对Session的影响？"></a>Session和Cooike的关系？禁用Cookie对Session的影响？</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Session</span> 的实现常常依赖于 Cookie 机制。一般默认情况下，服务器存储 <span class="hljs-keyword">session</span> 的 sessionid 是通过 cookie 存到浏览器里。如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，<span class="hljs-keyword">session</span> 失效。但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用 <span class="hljs-keyword">session</span>。<br><br><span class="hljs-number">1</span>、通过 url 重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中 携带 sessionid 参数。<br><span class="hljs-number">2</span>、服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。<br><span class="hljs-number">3</span>、通过 Http 协议其他 <span class="hljs-keyword">header</span> 字段，服务器每次返回时设置该 <span class="hljs-keyword">header</span> 字段信息，浏览器中 js 读取该 <span class="hljs-keyword">header</span> 字段，请求服务器时，js 设置携带该 <span class="hljs-keyword">header</span> 字段。<br></code></pre></td></tr></table></figure><h3 id="Get-和-Post-的区别"><a href="#Get-和-Post-的区别" class="headerlink" title="Get 和 Post 的区别"></a>Get 和 Post 的区别</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Get:向服务器获取资源; Post向指定的URI提交数据，数据保存在<span class="hljs-selector-tag">body</span>中。<br>Get:是安全且幂等的; Post不是安全也不是幂等的。<br><br>安全性：请求方法不会「破坏」服务器上的资源。<br>幂等性: 多次执行相同的操作，结果都是「相同」的。<br></code></pre></td></tr></table></figure><h3 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">forward 是服务器请求资源，服务器直接访问目标地址的 <span class="hljs-built_in">URL</span>, 把那个 <span class="hljs-built_in">URL</span> 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址.<br><br>redirect 是服务端根据逻辑，发送一个状态码 , 告诉浏览器重新去请求那个地址。所以地址栏显示的是新的<span class="hljs-built_in">URL</span>.<br></code></pre></td></tr></table></figure><h3 id="什么是DNS服务器？"><a href="#什么是DNS服务器？" class="headerlink" title="什么是DNS服务器？"></a>什么是DNS服务器？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DNS</span> 是指：域名服务器 (Domain Name Server)。在 Internet 上域名与 <span class="hljs-built_in">IP</span> 地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识 <span class="hljs-built_in">IP</span> 地址，它们之间的转 换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 就是进行域名解析的服务器 。一个<span class="hljs-built_in">ip</span>是可以供多个域名解析的,但是域名解析到的一个地址是一对一的。底层使用UDP协议。<br></code></pre></td></tr></table></figure><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">200</span>: 成功<br><span class="hljs-number">204</span>：与<span class="hljs-number">200</span>相同，响应头没有body数据<br><span class="hljs-number">206</span>：是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。<br><br><span class="hljs-number">301</span>:表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。<br><span class="hljs-number">302</span>：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br><span class="hljs-symbol">301 </span>和 <span class="hljs-number">302</span> 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。<br><br><span class="hljs-number">400</span>:表示客户端请求的报文有错误<br><span class="hljs-number">403</span>:表示服务器禁止访问资源<br><span class="hljs-number">404</span>:资源未找到<br><br><span class="hljs-number">500</span>:与 <span class="hljs-number">400</span> 类型，是个笼统通用的错误码<br><span class="hljs-number">502</span>:网关错误，通常是服务器作为网关或代理时返回的错误码。<br><span class="hljs-number">503</span>:表示服务器当前很忙，暂时无法响应服务器<br></code></pre></td></tr></table></figure><h4 id="请求报文和响应报文"><a href="#请求报文和响应报文" class="headerlink" title="请求报文和响应报文"></a>请求报文和响应报文</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts">请求报文：<br>    请求行：方法 URL 版本<br>    首部行：<span class="hljs-params">&lt;key, value&gt;</span><br><span class="hljs-symbol">            host:</span><br><span class="hljs-symbol">            Connection:</span><br>            Content-Length:<br>            Content-Type:<br>            ...<br>    实体：<br><br>响应报文：<br>    响应行：版本 状态码 状态描述<br>    首部行：<span class="hljs-params">&lt;key, value&gt;</span><br>            ...<br>    实体：<br></code></pre></td></tr></table></figure><h4 id="非持续连接-vs-持续连接"><a href="#非持续连接-vs-持续连接" class="headerlink" title="非持续连接 vs 持续连接"></a>非持续连接 vs 持续连接</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">非持续连接：每一个请求/响应对都是经过单独的TCP连接。<br>持续连接：所有的请求/响应对都是经过同一个TCP连接。 (http1.<span class="hljs-number">1</span>版本才有)<br><br>比如：客户端向服务端发送一个HTTP请求，假设该请求页面包含<span class="hljs-number">1</span>个<span class="hljs-selector-tag">HTML</span>页面和<span class="hljs-number">10</span>个JPEG图片，那么采用非持续连接就需要建立<span class="hljs-number">11</span>次TCP连接，而采用持续连接仅需要一个TCP连接。<br></code></pre></td></tr></table></figure><h4 id="HTTP有哪些优缺点"><a href="#HTTP有哪些优缺点" class="headerlink" title="HTTP有哪些优缺点?"></a>HTTP有哪些优缺点?</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-code">    1、协议简单</span><br><span class="hljs-code">    2、灵活易扩展</span><br><span class="hljs-code">    3、应用广泛跨平台</span><br><span class="hljs-code"></span><br><span class="hljs-code">缺点：</span><br><span class="hljs-code">    1、明文传输不安全</span><br><span class="hljs-code">    2、无状态</span><br><span class="hljs-code">    3、顺序发送的请求可能由于中间某个请求发送阻塞而导致后面的请求也处于等待状态，影响性能。(队头阻塞问题)</span><br></code></pre></td></tr></table></figure><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。<br><br><span class="hljs-attribute">2</span>、HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。<br><br><span class="hljs-attribute">3</span>、HTTP 的端口号是 <span class="hljs-number">80</span>，HTTPS 的端口号是 <span class="hljs-number">443</span>。<br><br><span class="hljs-attribute">4</span>、HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。<br></code></pre></td></tr></table></figure><h4 id="HTTPS解决了哪些问题？"><a href="#HTTPS解决了哪些问题？" class="headerlink" title="HTTPS解决了哪些问题？"></a>HTTPS解决了哪些问题？</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">HTTP是不安全的：<br><span class="hljs-code">    1、明文传输，存在窃听风险。</span><br><span class="hljs-code">    2、不验证对方信息，存在冒充风险。</span><br><span class="hljs-code">    3、不验证报文的完整性，存在篡改风险。</span><br><span class="hljs-code"></span><br><span class="hljs-code">HTTPS通过在HTTP协议和TCP协议之间加入一层SSL协议，解决了上面的问题。</span><br><span class="hljs-code">    1、通过混合加密，解决窃听风险</span><br><span class="hljs-code">    2、通过摘要算法，解决篡改风险</span><br><span class="hljs-code">    3、通过数字证书，解决冒充风险</span><br></code></pre></td></tr></table></figure><h4 id="混合加密方式"><a href="#混合加密方式" class="headerlink" title="混合加密方式"></a>混合加密方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">在通信之前，使用非对称加密的方式确认服务端的身份并交换私钥。具体做法是：用服务端的公钥加密私钥，然后发送给服务端，服务端用私钥解密，获取客户端加密的私钥。<br><br>在通信过程中，使用之前交换的私钥进行对称加密，因为对称加密解密速度更快。<br></code></pre></td></tr></table></figure><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">常用作数字签名，验证数据的完整性。<br><br>MD5<br><span class="hljs-keyword">SHA1、SHA256、SHA512</span><br><span class="hljs-keyword">MAC</span><br></code></pre></td></tr></table></figure><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">1、服务器将自己的公钥注册到<span class="hljs-keyword">CA</span><br>2、<span class="hljs-keyword">CA</span>验证身份并颁发数字证书<br>3、客户端拿到数字证书后用<span class="hljs-keyword">CA</span>的公钥确认证书的真实性<br>4、确认完毕拿到服务端的公钥，并用公钥加密通信的私钥<br>5、服务端用私钥解密，拿到通信的私钥。<br></code></pre></td></tr></table></figure><h4 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span>、客户端向服务端发送加密通信请求，包括以下信息：客户端支持的SSL版本、客户端产生的随机数<span class="hljs-comment">(用于后面产生密钥)</span>、客户端支持的加密方式。<br><br><span class="hljs-number">2</span>、服务端收到请求后，进行响应，包括以下信息：服务端支持的SSL版本，服务端产生的随机数、服务端支持的加密方式<br><br><span class="hljs-number">3</span>、客户端收到回应后，首先通过CA公钥验证服务端的数字证书的真实性，如果没有问题则取出服务端的公钥，然后使用它加密报文，发送以下信息：一个随机数<span class="hljs-comment">(用来生成会话密匙)</span>、加密算法改变通知接下来的信息都通过会话密匙进行加密、客户端握手结束通知表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发送的数据做个摘要，用来供服务端校验。<br><br><span class="hljs-number">4</span>、服务端收到第三个随机数，用协商好的加密算法计算会话密匙，然后向客户端发送以下信息：加密算法的改变、握手结束并将之前发送的内容做个摘要供客户端检查。<br><br>自此以后，双方继续通过HTTP协议通信，只不过用协商好的密钥进行了加密。<br></code></pre></td></tr></table></figure><h3 id="HTTP1-1有什么问题？HTTP2-0有什么改进？"><a href="#HTTP1-1有什么问题？HTTP2-0有什么改进？" class="headerlink" title="HTTP1.1有什么问题？HTTP2.0有什么改进？"></a>HTTP1.1有什么问题？HTTP2.0有什么改进？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown">相比于HTTP1.0的优点：<br><span class="hljs-code">    1、持久连接改善了性能开销</span><br><span class="hljs-code">    2、支持管道网络传输，只要第一个请求发送出去了，不必等待回应就可以继续发送新的请求</span><br><span class="hljs-code"></span><br><span class="hljs-code">缺点：</span><br><span class="hljs-code">    1、请求/响应头部未经压缩就发送，首部信息越多延迟越大。</span><br><span class="hljs-code">    2、发送冗余的首部。每次互相发送相同的首部浪费了带宽。</span><br><span class="hljs-code">    3、可能出现队头阻塞问题。服务端按照顺序响应请求，如果其中一个请求处理的很慢会导致客户端后续请求一直处于阻塞等待状态。</span><br><span class="hljs-code">    4、请求只能由客户端主动发起，服务端只能被动响应。</span><br><span class="hljs-code">    5、没有请求优先级控制。</span><br><span class="hljs-code"></span><br><span class="hljs-code">HTTP2.0如何优化？（简要说明）</span><br><span class="hljs-code">    1、头部压缩：如果发出多个请求，它们的头部字段一样或相似，那么会将重复部分消除。具体来说使用HPACK算法：在客户端和服务端同时维护一张头部字段信息表，每个字段对应一个索引号，通过索引号来代替头部字段。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    2、二进制优化：采用二进制格式替代原先的纯文本形式的报文，增加了数据传输的效率。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    3、数据流</span><br><span class="hljs-code"></span><br><span class="hljs-code">    4、多路复用</span><br><span class="hljs-code"></span><br><span class="hljs-code">    5、主动推送</span><br></code></pre></td></tr></table></figure><h3 id="HTTP1-1的优化手段？"><a href="#HTTP1-1的优化手段？" class="headerlink" title="HTTP1.1的优化手段？"></a>HTTP1.1的优化手段？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1、利用缓存：减少HTTP请求的数据传输。<br><span class="hljs-code">    对于一些重复性的HTTP请求，每次请求得到的数据都是一样的，那么可以将相应的数据缓存在本地磁盘，下次访问直接读取本地磁盘就可以了，就不需要发送HTTP请求了。具体来说：客户端将第一次请求以及响应的数据保存在本地磁盘是，将请求的URL作为key，响应作为value。下次访问相同的URL直接访问本地磁盘就可以了。</span><br><span class="hljs-code"></span><br><span class="hljs-code">2、减少HTTP请求次数</span><br><span class="hljs-code">    1、服务端使⽤ webpack 等打包⼯具将 js、css 等资源合并打包成⼤⽂件</span><br><span class="hljs-code">    2、延迟发送请求：请求⽹⻚的时候，没必要把全部资源都获取到，⽽是只获取当前⽤户所看到的⻚⾯资源，当⽤户向下滑动⻚⾯的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</span><br><span class="hljs-code"></span><br><span class="hljs-code">3、对响应数据进行压缩</span><br></code></pre></td></tr></table></figure><h3 id="HTTP2-0具体细节"><a href="#HTTP2-0具体细节" class="headerlink" title="HTTP2.0具体细节"></a>HTTP2.0具体细节</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>、头部压缩：HTTP协议的报文是由<span class="hljs-selector-attr">[header + body]</span>两个部分组成的，<span class="hljs-selector-tag">body</span>部分可以用<span class="hljs-attribute">Content</span>-Encoding指定的压缩方式进行压缩优化。但是<span class="hljs-selector-tag">header</span>部分没有办法优化。而这些<span class="hljs-selector-tag">header</span>部分存在以下问题：<br>    <span class="hljs-number">1</span>、含有很多固定的重复字段，比如Cookie、Host、User Agent等，这些字段加起来高达几百字节甚至几千字节，有必要压缩。<br>    <span class="hljs-number">2</span>、字段是ASCII编码，虽然易读但是效率低，有必要进行二进制编码。<br><br><br><span class="hljs-number">2</span>、基于stream的并发传输<br><br><span class="hljs-number">3</span>、服务器主动推送资源<br><br></code></pre></td></tr></table></figure><h4 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP-和-UDP-的区别？"><a href="#TCP-和-UDP-的区别？" class="headerlink" title="TCP 和 UDP 的区别？"></a>TCP 和 UDP 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">TCP：面向连接、面向字节流、一对一； UDP：无连接、面向报文、一对一、一对多、 多对多。 <br><br>TCP 的优点：可靠，稳定. 缺点：慢，效率低，占用系统资源高，易被攻击 <br><br>UDP 的优点：快，UDP 是一个无状态的传输协议 缺点： 不可靠，不稳定<br></code></pre></td></tr></table></figure><h3 id="Linux中如何查看TCP连接状态"><a href="#Linux中如何查看TCP连接状态" class="headerlink" title="Linux中如何查看TCP连接状态"></a>Linux中如何查看TCP连接状态</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">netstat -napt</span><br></code></pre></td></tr></table></figure><h3 id="TCP是如何保证可靠传输的？"><a href="#TCP是如何保证可靠传输的？" class="headerlink" title="TCP是如何保证可靠传输的？"></a>TCP是如何保证可靠传输的？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">保证可靠传输最主要的是：<br><span class="hljs-code">    (1) 拥塞控制</span><br><span class="hljs-code">    (2) 流量控制</span><br><span class="hljs-code">    (3) ARQ协议</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    除此之外还有：超时传送、丢弃重复、校验和、分割合适数据包。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">简单来说，一方给另外一方发送消息，只需要保证按序到达、无错误、不丢失、不重复即可认为是可靠传输。</span><br><span class="hljs-code"></span><br><span class="hljs-code">先考虑最简单的情况：</span><br><span class="hljs-code">    为了保证按序到达：发送方发送一个消息就等待对方发送确认信息，确认收到后才发送下一个。因此TCP提供消息确认机制ACK。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了保证无错误：提供检测错误的能力。比如TCP报文段有一个检验和机制，用来确认是否发生错误。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了保证不丢失：发生丢失则重传该消息。TCP提供超时重传机制(每发送一个分组就启动计时器)。若发送方在一个往返时延RTT没有收到确认信息则认为发生了丢失情况，因此重新发送。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    为了避免重复：给每个消息一个序号。TCP提供序号机制。如果发送方发送一个分组经历了很大的时延才到达接收方，可能中途已经触发了超时重传，因此会再次发送该分组，结果第一个分组已经到了，第二个相同的分组就成为了冗余分组，通过添加序号机制能够很方便的分辨冗余分组。</span><br></code></pre></td></tr></table></figure><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nix">为什么需要拥塞控制：<br>    计算机网络是一个共享的环境，在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，就会进入恶性循环。<br><br>作用：发送方维护一个拥塞窗口，它能根据网络环境动态地变换，当发生了超时重传就认为出现了拥塞，从而降低发送量，避免数据填满整个网络。<br><br><br>慢启动：当TCP建立连接后，一点点提升发送量。当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会翻倍，呈指数级增长。<br><br><br>拥塞避免：当 cwnd &gt;= ssthresh(<span class="hljs-number">65535</span>)后，它收到<span class="hljs-number">1</span>个ACK，则cwnd加<span class="hljs-number">1</span>，呈线性增长。<br><br><br>拥塞发生：当发生了重传情况，如果是超时导致的重传，则<span class="hljs-attr">ssthresh</span> = cwnd / <span class="hljs-number">2</span>, <span class="hljs-attr">cwnd</span> = <span class="hljs-number">1</span>, 然后进入慢启动。如果是快速重传，则<span class="hljs-attr">sshtresh</span> = cwnd, <span class="hljs-attr">cwnd</span> = cwnd / <span class="hljs-number">2</span>，然后进入快恢复。<br><br><br>快恢复：<br>    <span class="hljs-number">1</span>、拥塞窗口 <span class="hljs-attr">cwnd</span> = ssthresh + <span class="hljs-number">3</span><br>    <span class="hljs-number">2</span>、重传丢失的数据包<br>    <span class="hljs-number">3</span>、如果再收到重复的 ACK，那么 cwnd 增加 <span class="hljs-number">1</span><br>    <span class="hljs-number">4</span>、如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法<br></code></pre></td></tr></table></figure><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">TCP报文段有个窗口字段，该字段控制发送方的发送上限。<br><br>作用：抑制发送方的发送速率，避免发送速率比接收方应用程序的读取速率大，导致接收缓冲区的溢出。<br><br>接收方控制发送窗口的大小，当服务端过于繁忙时，发送窗口可能会变为0。这个时候，发送方会启动一个计时器，超时就会发送一个探测报文，如果发送窗口不为0，则发送报文，如果仍然为0，则重启计时器。<br></code></pre></td></tr></table></figure><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">回退<span class="hljs-built_in">N</span>帧协议：接收方的接收窗口设置为<span class="hljs-number">1</span>，即使发送方以流水线的形式发送多个消息，接收方也是按序接收，出现失序分组则会丢弃，同时返回最后一个正确分组的编号。当发送方收到确认消息，它会将从确认序号继续发送。其缺点是：当窗口很大的时候可能需要重传大量分组。<br><br>选择重传协议：接收方的接收窗口不再是<span class="hljs-number">1</span>，一般设置为发送窗口大小的一半。接收方接受分组的时候，出现在接收窗口内的分组，即使没有按序到达也会先缓存起来，并返回确认信息。直到序号更小的分组到达才一起交付给上层。因此，发送方只需要重新发送未正确接收的分组即可。<br></code></pre></td></tr></table></figure><h4 id="TCP队头堵塞问题？、"><a href="#TCP队头堵塞问题？、" class="headerlink" title="TCP队头堵塞问题？、"></a>TCP队头堵塞问题？、</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TCP</span>队头堵塞问题是由TCP自身机制导致的，我们知道TCP是按序接收分组的，它需要等到接收缓冲区满了才把整个缓冲区的数据向上交付，比如现在缓冲区大小为<span class="hljs-number">5</span>, 已经收到了<span class="hljs-number">2345</span>四个分组，而由于<span class="hljs-number">1</span>号分组没有正确接收，那么它会一直堵塞，直到<span class="hljs-number">1</span>号分组正确接收才将整个缓冲区数据向上交付。<br></code></pre></td></tr></table></figure><h3 id="三次握手？"><a href="#三次握手？" class="headerlink" title="三次握手？"></a>三次握手？</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">第一次握手：客户端随机初始化序列号写入TCP报文段的序列号中，将SYN置为1，向服务端发送请求连接报文，然后进入SYN_SEND状态。<br><br>第二次握手：服务端随机初始化序列号写入TCP报文段的序列号中，将客户端的序列号<span class="hljs-string">+1</span>写入到确认号中，将SYN和ACK置为1，向客户端发送确认报文，然后进入SYN_RECV状态。<br><br>第三次握手：客户端检查服务端返回的确认报文中确认号是否为之前发送的序列号<span class="hljs-string">+1</span>，ACK是否为1，如果不是则将RST置为1发送给服务端，表示废弃此次连接。否则将序列号<span class="hljs-string">+1</span>，确认号置为服务端的序列号<span class="hljs-string">+1</span>，ACK置为1返回给服务端，然后客户端进入ESTABLISHED状态，服务端收到确认报文后也进入ESTABLISHED状态，握手完成。<br></code></pre></td></tr></table></figure><h4 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">两个原因：<br><span class="hljs-code">    1、三次握手才能阻止历史连接，避免资源浪费</span><br><span class="hljs-code">        考虑这样一种情况：客户端连续发送了两个连接请求，但是第一个请求由于在网络中堵塞，直到第二个连接关闭后才到达，这个时候服务端以为是客户端发送的新请求，从而会回复ACK确认报文。如果只有两次握手，此时客户端就无法告知服务端该连接是无效的历史连接，导致服务端一直收不到回应从而反复重发直到放弃，造成了资源的浪费。如果有三次握手的话，客户端可以判断该连接是历史重复连接，从而给服务端回复RST报文，通知服务端中断该连接。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    2、三次握手才能同步双方的序列号</span><br><span class="hljs-code">        经过三次握手，通信双方才能确定对方可以正确接收自己的序列号。</span><br><span class="hljs-code">        而两次握手只有客户端确定自己的初始序列号被对方接收，而服务端不确定自己的初始序列号能被对方接收。</span><br></code></pre></td></tr></table></figure><h4 id="序列号有什么作用？"><a href="#序列号有什么作用？" class="headerlink" title="序列号有什么作用？"></a>序列号有什么作用？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">序列号在可靠传输中非常的重要。通过序列号：<br>    1、接收方能够确定冗余分组<br>    2、接收方能够根据序列号按序接收<br>    3、可以标识发送出去的数据包中， 哪些是已经被对方收到的<br></code></pre></td></tr></table></figure><h4 id="初始序列号是如何产生的？"><a href="#初始序列号是如何产生的？" class="headerlink" title="初始序列号是如何产生的？"></a>初始序列号是如何产生的？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ISN</span> = M + F<br>M是一个计时器。每隔四毫米加<span class="hljs-number">1</span><br>F是一个哈希算法。根据源 <span class="hljs-built_in">IP</span>、目的 <span class="hljs-built_in">IP</span>、源端口、目的端口生成一个随机数值。<br></code></pre></td></tr></table></figure><h4 id="第三次握手时，客户端的ACK报文没有到达服务端会怎样？"><a href="#第三次握手时，客户端的ACK报文没有到达服务端会怎样？" class="headerlink" title="第三次握手时，客户端的ACK报文没有到达服务端会怎样？"></a>第三次握手时，客户端的ACK报文没有到达服务端会怎样？</h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cos">服务端没有收到ACK，会触发超时重传机制。连续发送五次都没有收到回应则会进入<span class="hljs-keyword">CLOSE</span>状态。<br><br>对于客户端来说，对重传的ACK报文进行响应后：<br>    <span class="hljs-number">1</span>、如果服务端仍然处于SYN_RECV状态，则收到后会进入ESTABLISH状态。<br>    <span class="hljs-number">2</span>、如果服务端已经处于<span class="hljs-keyword">CLOSE</span>状态，则服务端会以RST包进行应答。<br></code></pre></td></tr></table></figure><h4 id="已经建立连接的客户端发生了故障怎么办？"><a href="#已经建立连接的客户端发生了故障怎么办？" class="headerlink" title="已经建立连接的客户端发生了故障怎么办？"></a>已经建立连接的客户端发生了故障怎么办？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">TCP有一个保活机制。<br>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br></code></pre></td></tr></table></figure><h3 id="四次挥手？"><a href="#四次挥手？" class="headerlink" title="四次挥手？"></a>四次挥手？</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">第一次挥手：客户端将FIN置为<span class="hljs-number">1</span>，向服务端发送请求关闭连接，然后进入FIN_WAIT_1状态。<br><br>第二次挥手：服务端收到请求后，将ACK置为<span class="hljs-number">1</span>，向客户端发送确认报文。服务端进入<span class="hljs-built_in">CLOSE_WAIT</span>状态，客户端收到ACK后进入FIN_WAIT_2状态。<br><br>第三次挥手：服务端处理完数据后，也向客户端发送FIN报文，然后进入LAST_ACK状态。<br><br>第四次挥手：客户端收到FIN报文后，回复ACK报文，然后进入TIME_WAIT状态。服务端收到ACK报文后进入<span class="hljs-built_in">CLOSE</span>状态。等待<span class="hljs-number">2</span>MSL时间后，客户端也进入<span class="hljs-built_in">CLOSE</span>状态。<br></code></pre></td></tr></table></figure><h4 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">关闭连接时，客户端向服务端发送FIN报文，仅仅表示客户端不会再主动发送数据，但是还可以接收数据。<br><br>此时服务端可能还有数据没有处理完毕，因此先回复ACK确认报文，表示收到了客户端的请求避免客户端重发请求，等数据处理完毕之后才发送FIN报文表示同意关闭连接。<br><br>总的来说，由于服务端可能还有数据没有处理完毕，因此不能向三次握手那样将ACK和FIN合并一起发送。<br></code></pre></td></tr></table></figure><h4 id="为什么需要TIME-WAIT状态且等待2MSL？"><a href="#为什么需要TIME-WAIT状态且等待2MSL？" class="headerlink" title="为什么需要TIME_WAIT状态且等待2MSL？"></a>为什么需要TIME_WAIT状态且等待2MSL？</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss">MSL: 报文最大生存时间。它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<br><span class="hljs-number">2</span>MSL:客户端发送数据给服务端，服务端需要处理之后再返回消息。一来一回就是<span class="hljs-number">2</span>倍的MSL。<br><span class="hljs-number">2</span>MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 <span class="hljs-built_in">TIME</span>-<span class="hljs-built_in">WAIT</span> 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <span class="hljs-number">2</span>MSL 时间将重新计时。如果超过<span class="hljs-number">2</span>MSL都没有收到服务端重发FIN，则认为服务端正确接收到了ACK并关闭了。<br><br>TIME_WAIT状态的意义有两个：<br>    <span class="hljs-number">1</span>、防止收到旧连接的数据包而产生数据错乱等严重的问题。<br>        比如：服务端在断开连接之前发送了一个报文被延迟了，这时有相同端口的 TCP 连接被复用后，被延迟的报文抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。<br>        经过 <span class="hljs-number">2</span>MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。<br>    <br>    <span class="hljs-number">2</span>、确保最后的ACK能够被服务端接收，从而帮助服务端正常关闭<br>        比如客户端最后发送的ACK丢失了，服务端就会重发FIN报文，此时如果没有TIME_WAIT状态，客户端已经处于<span class="hljs-built_in">CLOSE</span>状态，那么服务端就收不到回应从而导致多次重发，不能正常关闭。     <br></code></pre></td></tr></table></figure><h3 id="TCP超时重传的超时时间应该如何设置？"><a href="#TCP超时重传的超时时间应该如何设置？" class="headerlink" title="TCP超时重传的超时时间应该如何设置？"></a>TCP超时重传的超时时间应该如何设置？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="内网和外网的区别？ABC三类地址的划分？"><a href="#内网和外网的区别？ABC三类地址的划分？" class="headerlink" title="内网和外网的区别？ABC三类地址的划分？"></a>内网和外网的区别？ABC三类地址的划分？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">外网 <span class="hljs-built_in">IP</span> 是全世界唯一的 <span class="hljs-built_in">IP</span> 地址，仅分配给一个网络设备。公网 <span class="hljs-built_in">IP</span> 地址全世界仅分配给一个网络设备。<br><br>内网 <span class="hljs-built_in">IP</span> 局域网，网线都是连接在同一个 交换机上面的，也就是说它们的 <span class="hljs-built_in">IP</span> 地址是由交换机或者路由器进行分配的。内网用户的电脑都是经过交换机和路由器之后才能连到 外网。Internet 上的用户也无法直接访问到内网用户。不同内网的内网地址可以相同。<br><br><span class="hljs-built_in">IP</span>地址 = 网络地址 + 主机地址。<br>A类网络：以<span class="hljs-number">0</span>开头前<span class="hljs-number">8</span>位。<span class="hljs-number">0</span> ~ <span class="hljs-number">127</span><br>B类地址：以<span class="hljs-number">10</span>开头前<span class="hljs-number">16</span>位。<span class="hljs-number">128</span> ~ <span class="hljs-number">191</span><br>C类地址：以<span class="hljs-number">110</span>开头前<span class="hljs-number">24</span>位。<span class="hljs-number">192</span> ~ <span class="hljs-number">223</span><br></code></pre></td></tr></table></figure><h3 id="网关和子网掩码的关系？"><a href="#网关和子网掩码的关系？" class="headerlink" title="网关和子网掩码的关系？"></a>网关和子网掩码的关系？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">子网掩码：用来判断任意两台计算机的 <span class="hljs-built_in">ip</span> 地址是否属于同一子网络的根据。<br><br>网关实质上是一个在不同子段网路中传输数据的设备。<br><br>子网掩码相同，不需要网关即可通讯，子网掩码不同，需要网关才能通讯。<br></code></pre></td></tr></table></figure><h3 id="MAC地址和IP地址的关系？"><a href="#MAC地址和IP地址的关系？" class="headerlink" title="MAC地址和IP地址的关系？"></a>MAC地址和IP地址的关系？</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">MAC</span> 地址是硬件地址，定位全球唯一主机机器，在网络底层的物理传输过程中，是通过物理地址来识别主机的，它一定是全球唯一的，对应数据链路层。<br><br>IP 地址是网络拓扑地址，定位全球唯一网络结构中的主机。对应网路层。<br></code></pre></td></tr></table></figure><h3 id="IP如何映射到MAC地址？"><a href="#IP如何映射到MAC地址？" class="headerlink" title="IP如何映射到MAC地址？"></a>IP如何映射到MAC地址？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用ARP协议, 位于网络层。<br><br>工作原理:<br>    (<span class="hljs-number">1</span>) 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 <span class="hljs-built_in">IP</span> 地址和 MAC 地址之间的对应关系。当源主机要发送数据时，首先检查 ARP 列表中是否有对应 <span class="hljs-built_in">IP</span> 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 ARP 数据包。<br><br>    (<span class="hljs-number">2</span>) 当本网络的所有主机收到该 ARP 数据包时，首先检查数据包中的 <span class="hljs-built_in">IP</span> 地址是否是自己 的 <span class="hljs-built_in">IP</span> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <span class="hljs-built_in">IP</span> 和 MAC 地址写入到 ARP 列表中, 然后将自己的MAC地址回复给源主机。<br><br>    (<span class="hljs-number">3</span>) 如果目标 <span class="hljs-built_in">IP</span> 与自己不在同一个网段，这种情况需要将包发给默认网关，所以主要获取网关的 MAC 地址。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数DP</title>
    <link href="/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%A1%E6%95%B0DP/"/>
    <url>/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%A1%E6%95%B0DP/</url>
    
    <content type="html"><![CDATA[<h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">一个正整数 <span class="hljs-built_in">n</span> 可以表示成若干个正整数之和，形如：<span class="hljs-built_in">n</span>=<span class="hljs-symbol">n1</span>+<span class="hljs-symbol">n2</span>+…+nk，其中 <span class="hljs-symbol">n1</span>≥<span class="hljs-symbol">n2</span>≥…≥nk,k≥<span class="hljs-number">1</span>。<br><br>我们将这样的一种表示称为正整数 <span class="hljs-built_in">n</span> 的一种划分。<br><br>现在给定一个正整数 <span class="hljs-built_in">n</span>，请你求出 <span class="hljs-built_in">n</span> 共有多少种不同的划分方法。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC312_戳气球</title>
    <link href="/2021/03/22/%E7%AE%97%E6%B3%95/LC0312_%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <url>/2021/03/22/%E7%AE%97%E6%B3%95/LC0312_%E6%88%B3%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs inform7">有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。<br><br>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums<span class="hljs-comment">[i - 1]</span> * nums<span class="hljs-comment">[i]</span> * nums<span class="hljs-comment">[i + 1]</span> 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。<br><br>求所能获得硬币的最大数量。<br><br> <br>示例 1：<br>输入：nums = <span class="hljs-comment">[3,1,5,8]</span><br>输出：167<br>解释：<br>    nums = <span class="hljs-comment">[3,1,5,8]</span> --&gt; <span class="hljs-comment">[3,5,8]</span> --&gt; <span class="hljs-comment">[3,8]</span> --&gt; <span class="hljs-comment">[8]</span> --&gt; <span class="hljs-comment">[]</span><br>    coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167<br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[1,5]</span><br>输出：10<br></code></pre></td></tr></table></figure><h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 打完所有[i+1, j-1]的气球所能获得的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以最后一个气球作为分界点</span><br><span class="hljs-comment">             (第i+1个 | 第i+2个 | 第k个 | ... | 第j-1个)</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    则dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 辅助数组。首尾添加1</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];<br>    temp[<span class="hljs-number">0</span>] = temp[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        temp[i+<span class="hljs-number">1</span>] = nums[i];<br>    <br>    <span class="hljs-comment">// 枚举长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">3</span>; len &lt;= n + <span class="hljs-number">2</span>; len++) &#123;<br>        <span class="hljs-comment">// 枚举左边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;= n + <span class="hljs-number">2</span> - len; l++) &#123;<br>            <span class="hljs-comment">// 确定右边界</span><br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 枚举切割点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l + <span class="hljs-number">1</span>; k &lt; r; k++)<br>                dp[l][r] = Math.max(dp[l][r], dp[l][k] + dp[k][r] + temp[l] * temp[k] * temp[r]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">设有 <span class="hljs-built_in">N</span> 堆石子排成一排，现在要将这 <span class="hljs-built_in">N</span> 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和,找出一种合理的方法，使总的代价最小，输出最小代价。<br></code></pre></td></tr></table></figure><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 所有将第i堆到第j堆合并为一个的方案中的代价的最小值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以最后一次的分界线来分类。</span><br><span class="hljs-comment">             (第i堆和[i+1, j]合并 | [i, i + 1]与[i + 2, j]合并 | ... | [i, j - 1] 和第j堆合并)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j] = dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1];</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] pre;<br><span class="hljs-keyword">int</span>[][] dp;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 处理前缀和</span><br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] + nums[i];<br>    <br>    dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br><br>    helper(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 合并区间[l, r]的最小代价</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (dp[l][r] != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> dp[l][r];<br>    <br>    <span class="hljs-comment">// 枚举每个分界线</span><br>    <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt; r; k++) &#123;<br>        res = Math.min(res, helper(nums, l, k) + helper(nums, k + <span class="hljs-number">1</span>, r) + pre[r] - pre[l - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[l][r] = res;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性DP</title>
    <link href="/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2021/03/22/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。<br><br>        7<br>     <span class="hljs-number"> 3 </span>  8<br>   <span class="hljs-number"> 8 </span> <span class="hljs-number"> 1 </span>  0<br> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 7 </span> <span class="hljs-number"> 4 </span>  4<br>4  <span class="hljs-number"> 5 </span> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 6 </span>  5<br></code></pre></td></tr></table></figure><h4 id="方法1：自顶向下"><a href="#方法1：自顶向下" class="headerlink" title="方法1：自顶向下"></a>方法1：自顶向下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    7</span><br><span class="hljs-comment">    3 8</span><br><span class="hljs-comment">    8 1 0</span><br><span class="hljs-comment">    2 7 4 4</span><br><span class="hljs-comment">    4 5 2 6 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 所有从(0, 0)走到(i, j)的路径的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从上面来 | 从左上方来)</span><br><span class="hljs-comment">             max(dp[i-1][j] | dp[i-1][j-1]) + matrix[i][j]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++) <br>            dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= col; k++)<br>        xMax = Math.max(dp[row][k], xMax);<br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br><span class="hljs-comment">// 优化：跟01背包相似，都与第i-1层的第j个和第j-1个有关</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[col + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j-<span class="hljs-number">1</span>]) + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= col; k++)<br>        xMax = Math.max(dp[k], xMax);<br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法2：自底向上"><a href="#方法2：自底向上" class="headerlink" title="方法2：自底向上"></a>方法2：自底向上</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    7</span><br><span class="hljs-comment">    3 8</span><br><span class="hljs-comment">    8 1 0</span><br><span class="hljs-comment">    2 7 4 4</span><br><span class="hljs-comment">    4 5 2 6 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    dp[i][j]: 所有从最底部走到(i, j)的路径的最大值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(从下面来 | 从右下方来)</span><br><span class="hljs-comment">             max(dp[i+1][j] | dp[i+1][j+1]) + matrix[i][j]</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个长度为 <span class="hljs-built_in">N</span> 的数列，求数值严格单调递增的子序列的长度最长是多少。<br><br>子序列：不要求连续<br></code></pre></td></tr></table></figure><h4 id="方法1：朴素版"><a href="#方法1：朴素版" class="headerlink" title="方法1：朴素版"></a>方法1：朴素版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i]：以下标i结尾的最长上升子序列的长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(比nums[0]大 | 比nums[1]大 | ... | 比nums[i-1]大)</span><br><span class="hljs-comment">            max(dp[0] | dp[1] | ... | dp[n - 1]) + 1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        xMax = Math.max(dp[i], xMax);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="方法2：二分法优化"><a href="#方法2：二分法优化" class="headerlink" title="方法2：二分法优化"></a>方法2：二分法优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于二分法的优化。</span><br><span class="hljs-comment">    g[i]: 最大长度为i的递增子序列中序列的最小值</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    那么在遍历nums[i]的过程中，只需要在g[]中寻找 &lt; nums[i] 的右边界r，那么 dp[i] = r + 1; g[r + 1] = nums[i]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    g[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前最大长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <br>        <span class="hljs-comment">// 在g[]中寻找 &lt; nums[i] 的右边界</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g[mid] &lt; nums[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前最大长度</span><br>        len = Math.max(len, r + <span class="hljs-number">1</span>);<br>        g[r + <span class="hljs-number">1</span>] = nums[i];<br>        dp[i] = r + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="延申：打印字典序最小的最长上升子序列"><a href="#延申：打印字典序最小的最长上升子序列" class="headerlink" title="延申：打印字典序最小的最长上升子序列"></a>延申：打印字典序最小的最长上升子序列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 假如说我们已经拿到了dp[] 和 xMax</span><br><br>    <span class="hljs-comment">// 如果出现dp[i] = 3, dp[i + 1] = 3, 那么显然nums[i+1] &lt; nums[i]。因此后者才是字典序最小的。</span><br><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[xMax];<br>    <span class="hljs-keyword">int</span> k = xMax - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = xMax; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// dp[i] == j, 则添加进res中</span><br>        <span class="hljs-keyword">if</span> (dp[i] == j) &#123;<br>            res[k--] = nums[i];<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个长度分别为 N 和 M 的字符串 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，求既是 <span class="hljs-selector-tag">A</span> 的子序列又是 <span class="hljs-selector-tag">B</span> 的子序列的字符串长度最长是多少。<br></code></pre></td></tr></table></figure><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    dp[i][j]: 所有 即出现在第一个序列的前i个字符中，且出现在第二个序列的前j个字符中 的子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：以 a[i] 和 b[j] 是否包含在子序列中为划分依据</span><br><span class="hljs-comment">         max (包含a[i] | 包含b[j] | 都包含 | 都不包含)</span><br><span class="hljs-comment">         max (dp[i][j-1] | dp[i-1][j] | dp[i-1][j-1] + 1 | dp[i-1][j-1])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>    <span class="hljs-comment">// 子序列没有连续的要求</span><br>    <span class="hljs-comment">// dp[i][j]: 字符串1的前i个字符和字符串2前j个字符的最长公共子序列的长度</span><br><br>    <span class="hljs-keyword">int</span> n = text1.length();<br>    <span class="hljs-keyword">int</span> m = text2.length();<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 包含s1[i]或者s2[j]</span><br>            dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>]);<br><br>            <span class="hljs-comment">// 如果s1[i] == s2[j], 则包含s1[i]和s2[j]</span><br>            <span class="hljs-keyword">if</span> (text1.charAt(i) == text2.charAt(j))<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>], dp[i][j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个字符串 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，现在要将 <span class="hljs-selector-tag">A</span> 经过若干操作变为 <span class="hljs-selector-tag">B</span>，可进行的操作有：<br>    删除–将字符串 <span class="hljs-selector-tag">A</span> 中的某个字符删除。<br>    插入–在字符串 <span class="hljs-selector-tag">A</span> 的某个位置插入某个字符。<br>    替换–将字符串 <span class="hljs-selector-tag">A</span> 中的某个字符替换为另一个字符。<br>现在请你求出，将 <span class="hljs-selector-tag">A</span> 变为 <span class="hljs-selector-tag">B</span> 至少需要进行多少次操作。<br></code></pre></td></tr></table></figure><h4 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = word1.length();<br>    <span class="hljs-keyword">int</span> n = word2.length();<br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 需要增dp[i][j+1]、删dp[i+1][j]、改dp[i][j]的情况</span><br>            dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(dp[i][j+<span class="hljs-number">1</span>], Math.min(dp[i][j], dp[i+<span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-comment">// 相等则啥也不用改</span><br>            <span class="hljs-keyword">if</span> (word1.charAt(i) == word2.charAt(j))<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Math.min(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>], dp[i][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2021/03/20/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/20/Acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    01背包模型：</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品只能选择一次。</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">        (选第i物品[前提是能装得下] | 不选第i个物品)</span><br><span class="hljs-comment">        (dp[i - 1][j - v[i]] + w[i] | dp[i - 1][j])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版本</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag01</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-comment">// 不选择第i个物品</span><br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br><br>            <span class="hljs-comment">// 选取第i个物品</span><br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) <br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    优化版</span><br><span class="hljs-comment">    dp[i]这一层仅使用到了dp[i-1]这一层，因此可以优化为一维。</span><br><span class="hljs-comment">    由于第i层的是通过第i-1层的第j位和第j-v[i]位来更新，因此优化成1维的时候，必须保证j-v[i]还没有被覆盖。因此需要从大到小进行更新。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag01</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;= v[i]; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    完全背包模型:</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品可以选取无数次。</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">            (不选第i个物品 | 选1个 | 选2个 | ... | 选k个)</span><br><span class="hljs-comment">            (dp[i-1][j] | dp[i-1][j - v[i]] + w[i] | dp[i-1][j - 2 * v[i]] + 2 * w[i] | ... | dp[i-1][j - k * v[i]] + k * w[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k++)<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化1：</span><br><span class="hljs-comment">    dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2v] + 2w + .... + dp[i-1][j-kv] + kw)</span><br><span class="hljs-comment">    dp[i][j-v] = max(          dp[i-1][j-v], dp[i-1][j-2v] + w, ... + dp[i-1][j-kv] + (k-1)w)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    因此dp[i][j] = max(dp[i-1][j], dp[i][j-v] + w) </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i+<span class="hljs-number">1</span>][j-v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化2：</span><br><span class="hljs-comment">        dp[i][j]需要第i-1层的第j个和第i层的第j-v[i]个有关。因此可以优化成一维。</span><br><span class="hljs-comment">        需要保证j从小到大更新。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag03</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v[i]; j &lt;= V; j++) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    多重背包模型：</span><br><span class="hljs-comment">        有N个物品和一个容量为V的背包，每个物品最多包含s个。</span><br><span class="hljs-comment">        s[i]: 第i个物品的个数</span><br><span class="hljs-comment">        v[i]: 第i个物品的体积</span><br><span class="hljs-comment">        w[i]: 第i个物品的价值</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：</span><br><span class="hljs-comment">            (不选第i个物品 | 选1个 | 选2个 | ... | 选s个)</span><br><span class="hljs-comment">            (dp[i-1][j] | dp[i-1][j - v[i]] + w[i] | dp[i-1][j - 2 * v[i]] + 2 * w[i] | ... | dp[i-1][j - s * v[i]] + s * w[i])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] s, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - k * v[i]] + k * w[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">// 优化版：二进制优化, 将s[i]分解成1、2、4、8..., 然后转换成01背包问题</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (k &lt;= s) &#123;<br>    v[cnt] = a * k;<br>    w[cnt] = b * k;<br>    s -= k;<br>    k *= <span class="hljs-number">2</span>;<br>    cnt++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>    v[cnt] = a * s;<br>    w[cnt] = b * s;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合背包"><a href="#组合背包" class="headerlink" title="组合背包"></a>组合背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    组合背包模型：</span><br><span class="hljs-comment">        有N组物品和一个容量为V的背包，每个组只能选择一个。</span><br><span class="hljs-comment">        v[i][k]: 第i组的第k个物品的体积</span><br><span class="hljs-comment">        w[i][k]: 第i组的第k个物品的价值</span><br><span class="hljs-comment">        s[i]: 第i组一共有多少个物品</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    集合含义：dp[i][j]代表前i个物品中容量不超过j的最大价值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    集合划分：(不从第i组选择 | 从第i组选第1个物品 | ... | 从第i组选第k个物品)</span><br><span class="hljs-comment">             (dp[i-1][j] | dp[i-1][j - v[i-1][1]] + w[i-1][1] | ... | dp[i-1][j - v[i-1][k]] + w[i-1][k])</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 朴素版</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Bag04</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] v, <span class="hljs-keyword">int</span>[][] w, <span class="hljs-keyword">int</span>[] s, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][V + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<br>            <span class="hljs-comment">// 不选择</span><br>            dp[i+<span class="hljs-number">1</span>][j] = dp[i][j];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k++) &#123;<br>                dp[i+<span class="hljs-number">1</span>][j] = Math.max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j - v[i][k] + w[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    优化：第i层的第j个只与第i-1层的第j个和第i-1层的第j-v[i][k]有关，因此优化方案与01背包一样</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i][k])<br>                dp[j] = Math.max(dp[j], dp[j - v[i][k] + w[i][k]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    <url>/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 堆是一个完全二叉树</span><br><span class="hljs-comment">// 核心操作：down(int x) 和 up(int x)</span><br><span class="hljs-comment">// 如果是从下标0开始，则父亲下标为(x - 1) / 2; 如果是从下标1开始，则父亲下标为 x / 2;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(size);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            data.add(arr[i]);<br>        <br>        <span class="hljs-comment">// 从最后一个叶子节点的父节点开始进行down, 即可O(N)实现堆化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            down(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 上浮操作 : 用于添加元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 当不是根节点时，不断与其父节点进行比较。</span><br>        <span class="hljs-comment">// 如果比根节点更小，则进行交换。继续上浮</span><br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; data.get(index) &lt; data.get((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &#123;<br>            Collections.swap(data, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>            index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始t为当前节点，代表值最小的位置</span><br>        <span class="hljs-keyword">int</span> t = index;<br>        <span class="hljs-comment">// 如果左孩子存在，当前最小节点则与左孩子进行比较。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span> &lt; data.size() &amp;&amp; data.get(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>) &lt; data.get(t))<br>            t = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 如果右孩子存在，当前最小节点则与左孩子进行比较。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span> &lt; data.size() &amp;&amp; data.get(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>) &lt; data.get(t))<br>            t = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 如果当前节点不是最小节点，则进行交换。继续下沉。</span><br>        <span class="hljs-keyword">if</span> (t != index) &#123;<br>            Collections.swap(data, t, index);<br>            down(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-comment">// 末尾添加新元素，然后不断上浮</span><br>        data.add(v);<br>        up(data.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 提取堆顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = data.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 末尾元素与堆顶元素交换，然后不断下沉</span><br>        Collections.swap(data, <span class="hljs-number">0</span>, data.size() - <span class="hljs-number">1</span>);<br>        data.remove(data.size() - <span class="hljs-number">1</span>);<br>        down(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集[Acwing]</title>
    <link href="/2021/03/18/Acwing/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/03/18/Acwing/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Acwing837-连通块中点的数量"><a href="#Acwing837-连通块中点的数量" class="headerlink" title="Acwing837_连通块中点的数量"></a>Acwing837_连通块中点的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 合并两个集合：必须先累加size再合并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            size[find(b)] += size[find(a)];<br>            p[find(a)] = find(b);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回x所在连通块的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size[find(x)];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing240-食物链"><a href="#Acwing240-食物链" class="headerlink" title="Acwing240_食物链"></a>Acwing240_食物链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要额外维护当前节点到根节点的距离</span><br><span class="hljs-comment">// 到根节点距离为0 : 与根节点同类</span><br><span class="hljs-comment">// 到根节点距离为1 : 能够吃根节点</span><br><span class="hljs-comment">// 到根节点距离为2 : 能够被根节点吃</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩过程中维护到根节点的距离</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                root</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">              /   d[p[x]]</span><br><span class="hljs-comment">            p[x]</span><br><span class="hljs-comment">            /</span><br><span class="hljs-comment">           /  d[x]</span><br><span class="hljs-comment">          x</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x]) &#123;<br>            <span class="hljs-keyword">int</span> u = find(p[x]); <span class="hljs-comment">// 寻找它当前根节点的父节点</span><br>            <span class="hljs-comment">// 它到新父节点的距离 = 它原来父节点的距离 + 它原来父节点到新父节点的距离</span><br>            d[x] = (d[x] + d[p[x]]) % M;    <br>            p[x] = u;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 与 b 是否同类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br><br>        <span class="hljs-comment">// 如果a和b已经同属于一个集合了，则判断到根节点的距离是否相等</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == d[b] % M;<br>        <br>        <span class="hljs-comment">// 否则，需要将两者放入同一个集合，并更新d[pa]到pb的距离</span><br>        <span class="hljs-comment">// 由于 a 和 b 同类， 所以 (d[a] + d[pa]) % M == d[b] % M</span><br>        <span class="hljs-comment">// 因此 d[pa] = (d[b] - d[a] + M) % M  --- 加M是以防d[a] - d[b] &lt; 0</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 是否能吃 b</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br>        <br>        <span class="hljs-comment">// 如果已经是同类，则a能吃b的前提是 a到根节点的距离 - 1 == b到根节点的距离</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == (d[b] + <span class="hljs-number">1</span>) % M;<br>        <br>        <span class="hljs-comment">// 否则加入同一集合，并维护a吃b的关系</span><br>        <span class="hljs-comment">// (d[a] + d[pa]) % M == (d[b] + 1) % M;</span><br>        <span class="hljs-comment">// d[pa] = (d[b] + 1 - d[a] + M) % M;</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] + <span class="hljs-number">1</span> - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-comment">// 维护并查集的个数</span><br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            p[i] = i;<br>        <br>        <span class="hljs-keyword">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            p[find(a)] = find(b);<br>            size--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x])<br>            p[x] = find(p[x]);<br>        <br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            <span class="hljs-comment">// 必须数量相加再合并</span><br>            size[find(b)] += size[find(a)];<br>            p[find(a)] = find(b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="维护到祖宗节点的并查集"><a href="#维护到祖宗节点的并查集" class="headerlink" title="维护到祖宗节点的并查集"></a>维护到祖宗节点的并查集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Union</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] p;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            p[i] = i;<br>            d[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩过程中维护到根节点的距离</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                root</span><br><span class="hljs-comment">               /</span><br><span class="hljs-comment">              /   d[p[x]]</span><br><span class="hljs-comment">            p[x]</span><br><span class="hljs-comment">            /</span><br><span class="hljs-comment">           /  d[x]</span><br><span class="hljs-comment">          x</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != p[x]) &#123;<br>            <span class="hljs-keyword">int</span> u = find(p[x]); <span class="hljs-comment">// 寻找它当前根节点的父节点</span><br>            <span class="hljs-comment">// 它到新父节点的距离 = 它原来父节点的距离 + 它原来父节点到新父节点的距离</span><br>            d[x] = (d[x] + d[p[x]]) % M;    <br>            p[x] = u;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 与 b 是否同类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br><br>        <span class="hljs-comment">// 如果a和b已经同属于一个集合了，则判断到根节点的距离是否相等</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == d[b] % M;<br>        <br>        <span class="hljs-comment">// 否则，需要将两者放入同一个集合，并更新d[pa]到pb的距离</span><br>        <span class="hljs-comment">// 由于 a 和 b 同类， 所以 (d[a] + d[pa]) % M == d[b] % M</span><br>        <span class="hljs-comment">// 因此 d[pa] = (d[b] - d[a] + M) % M  --- 加M是以防d[a] - d[b] &lt; 0</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 a 是否能吃 b</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">D2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pa = find(a), pb = find(b);<br>        <br>        <span class="hljs-comment">// 如果已经是同类，则a能吃b的前提是 a到根节点的距离 - 1 == b到根节点的距离</span><br>        <span class="hljs-keyword">if</span> (pa == pb)<br>            <span class="hljs-keyword">return</span> d[a] % M == (d[b] + <span class="hljs-number">1</span>) % M;<br>        <br>        <span class="hljs-comment">// 否则加入同一集合，并维护a吃b的关系</span><br>        <span class="hljs-comment">// (d[a] + d[pa]) % M == (d[b] + 1) % M;</span><br>        <span class="hljs-comment">// d[pa] = (d[b] + 1 - d[a] + M) % M;</span><br>        p[pa] = pb;<br>        d[pa] = (d[b] + <span class="hljs-number">1</span> - d[a] + M) % M;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>并查集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题之操作系统</title>
    <link href="/2021/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span>、进程是系统进行资源分配的基本单位，线程是系统进行任务调度的基本单位。<br><span class="hljs-number">2</span>、进程有自己的独立地址空间，每启动一个进程，操作系统都会为为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段；线程没有独立地址空间，多个线程共享进程的地址空间和数据，每个线程仅维护少量信息<span class="hljs-comment">(程序计数器、栈、寄存器)</span>等。<br><span class="hljs-number">3</span>、在进程切换时，涉及到整个当前进程CPU环境的保存和环境的设置以及新的被调度运行进程的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，可见，进程切换的开销远大于线程切换的开销；<br><span class="hljs-number">4</span>、线程依赖于进程而存在，一个进程至少包含一个线程。多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮。<br><span class="hljs-number">5</span>、线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信<span class="hljs-comment">(IPC)</span>的方式进行；<br></code></pre></td></tr></table></figure><h3 id="同一进程下的线程共享哪些数据？"><a href="#同一进程下的线程共享哪些数据？" class="headerlink" title="同一进程下的线程共享哪些数据？"></a>同一进程下的线程共享哪些数据？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、进程代码段<br>2、进程的公有数据，比如：全局变量和静态变量<br>3、进程打开的文件描述符<br>4、进程的当前目录<br>5、进程ID和进程组ID<br>6、信号处理器&#x2F;信号处理函数：对收到的信号的处理方式<br></code></pre></td></tr></table></figure><h3 id="线程独占那些数据？"><a href="#线程独占那些数据？" class="headerlink" title="线程独占那些数据？"></a>线程独占那些数据？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、线程ID<br>2、线程自身的栈<br>3、一组寄存器<br>4、错误返回码<br>5、程序计数器<br></code></pre></td></tr></table></figure><h3 id="进程调度算法有哪些？"><a href="#进程调度算法有哪些？" class="headerlink" title="进程调度算法有哪些？"></a>进程调度算法有哪些？</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-number">1</span>) 先来先服务<br>(<span class="hljs-number">2</span>) 时间片轮转<br>(<span class="hljs-number">3</span>) 短作业优先<br>(<span class="hljs-number">4</span>) 优先级调度<br>(<span class="hljs-number">5</span>) 多级反馈队列：系统维护多个就绪队列，并为不同队列赋予不同的优先级，优先级越高的队列分配的时间片越少。比如说现在有三个等待队列：<span class="hljs-built_in">Q1</span>,<span class="hljs-built_in">Q2</span>,<span class="hljs-built_in">Q3</span>，优先级依次下降。<br>    <span class="hljs-number">1</span>、一个新的进程首先进入优先级最高的<span class="hljs-built_in">Q1</span>等待调度。<br>    <span class="hljs-number">2</span>、CPU首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。<br>    <span class="hljs-number">3</span>、对于同一个队列中的各个进程，按照时间片轮转法调度。比如<span class="hljs-built_in">Q1</span>队列的时间片为N，那么<span class="hljs-built_in">Q1</span>中的作业在经历了N个时间片后若还没有完成，则进入<span class="hljs-built_in">Q2</span>队列等待，若<span class="hljs-built_in">Q2</span>的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。　<br>    <span class="hljs-number">4</span>、在低优先级的队列中的进程在运行时，又有新到达的作业，CPU马上分配给新到达的作业（抢占式）。<br></code></pre></td></tr></table></figure><h3 id="进程的通信方式有哪些？"><a href="#进程的通信方式有哪些？" class="headerlink" title="进程的通信方式有哪些？"></a>进程的通信方式有哪些？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">进程间的通信方式：<br>    <span class="hljs-comment">(1)</span> 匿名管道：<br>    <span class="hljs-comment">(2)</span> 管道<span class="hljs-comment">(有名管道)</span><br>    <span class="hljs-comment">(3)</span> 消息队列<br>    <span class="hljs-comment">(4)</span> 信号量<br>    <span class="hljs-comment">(5)</span> 共享内存<br>    <span class="hljs-comment">(6)</span> 套接字<br></code></pre></td></tr></table></figure><h3 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">同步是指：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另外一个进程提供的消息，在获得消息之前需要进入阻塞状态。<br><br>互斥是指：多个进程在同一时刻只能有一个获取到互斥资源<span class="hljs-comment">(或者说进入临界区)</span>。<br></code></pre></td></tr></table></figure><h3 id="进程的状态有哪些？"><a href="#进程的状态有哪些？" class="headerlink" title="进程的状态有哪些？"></a>进程的状态有哪些？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">就绪状态：进程已获得除了<span class="hljs-meta">CPU</span>以外的所有资源，等待<span class="hljs-meta">CPU</span>调度。<br>运行状态：进程占用<span class="hljs-meta">CPU</span>资源正在运行。<br>阻塞状态：进程等待除了<span class="hljs-meta">CPU</span>以外的其他资源。<br></code></pre></td></tr></table></figure><h3 id="并行、并发、异步的概念"><a href="#并行、并发、异步的概念" class="headerlink" title="并行、并发、异步的概念"></a>并行、并发、异步的概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">并行：在同一时刻，有多个进程在运行。<br>并发：在一个时间段，有多个进程在运行。微观上串行，宏观上并行。<br>异步：相对于同步，在等待某个进程完成之前不需要进入阻塞状态，而是可以继续做自己的事。<br></code></pre></td></tr></table></figure><h3 id="线程同步的方式有哪些？"><a href="#线程同步的方式有哪些？" class="headerlink" title="线程同步的方式有哪些？"></a>线程同步的方式有哪些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。<br><br>1、互斥量：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；<br><br>2、信号量：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。<br><br>3、事件：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。<br><br>4、临界区：任意时刻只允许一个线程对临界资源进行访问。<br></code></pre></td></tr></table></figure><h3 id="互斥量和临界区有什么区别？"><a href="#互斥量和临界区有什么区别？" class="headerlink" title="互斥量和临界区有什么区别？"></a>互斥量和临界区有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">互斥量可以用作不同进程之间进行同步。<br>临界区只能用于同一进程中的线程进行同步。<br></code></pre></td></tr></table></figure><h3 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">协程是一种用户态的轻量级线程，它的调度与切换不需要内核控制，而是由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到用户空间，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。<br></code></pre></td></tr></table></figure><h3 id="fork函数的作用"><a href="#fork函数的作用" class="headerlink" title="fork函数的作用"></a>fork函数的作用</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">它的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程。<br>调用<span class="hljs-keyword">fork</span>函数后，内核开始做以下工作：<br>    <span class="hljs-number">1</span>、分配新的数据块和内核数据结构给子进程<br>    <span class="hljs-number">2</span>、将父进程中的部分数据和内核数据结构拷贝给子进程<br>    <span class="hljs-number">3</span>、将子进程信息添加到系统进程列表<br>    <span class="hljs-number">4</span>、<span class="hljs-keyword">fork</span>返回，开始调度<br><br>特点：<br>    <span class="hljs-number">1</span>、父子进程并发执行<br>    <span class="hljs-number">2</span>、父子进程拥有独立的地址空间<br>    <span class="hljs-number">3</span>、<span class="hljs-keyword">fork</span>的返回值 : fock函数调用一次却返回两次；向父进程返回子进程的ID，向子进程中返回<span class="hljs-number">0</span>，<br><br>fokr调用失败的原因:<br>    <span class="hljs-number">1</span>、系统中有太多进程。实际用户的进程数超过限制。<br></code></pre></td></tr></table></figure><h3 id="什么是僵尸进程-什么是孤儿进程-有什么危害"><a href="#什么是僵尸进程-什么是孤儿进程-有什么危害" class="headerlink" title="什么是僵尸进程? 什么是孤儿进程? 有什么危害?"></a>什么是僵尸进程? 什么是孤儿进程? 有什么危害?</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">僵尸进程：<br>    一个进程fork了子进程，如果子进程退出，但是它的父进程没有调用wait/waitpid获取子进程的状态信息，那么子进程的进程描述符等一系列信息还会保存在系统中。这样的进程我们称为僵尸进程。<br><br>    危害：僵尸进程是一个早已死亡的进程，但是在进程表中仍占用了一个位置，而进程表的容量是有限的，如果僵尸进程过多的话可能导致系统无法产生新的进程，导致系统瘫痪。<br><br>处理僵尸进程：<br>    (<span class="hljs-number">1</span>) 修改父进程。子进程死亡后会发送SIGCHLD信号给父进程，父进程收到此信号后调用wait/waitpid进行处理。<br>    (<span class="hljs-number">2</span>) 杀死父进程。杀死父进程后，僵尸进程会进化为孤儿进程，继而由<span class="hljs-number">1</span>号进程<span class="hljs-keyword">init</span>接管，<span class="hljs-keyword">init</span>进程会负责处理孤儿进程。<br><br>孤儿进程：<br>    父进程运行结束，但子进程还在运行 (未运行结束) 的子进程就称为孤儿进程。 <br>    <br>    孤儿进程最终会被 <span class="hljs-keyword">init</span> 进程 (进程号为 <span class="hljs-number">1</span>) 所收养，因此 <span class="hljs-keyword">init</span> 进程此时变成孤儿进程 的父进程，并由 <span class="hljs-keyword">init</span> 进程对它们完成状态收集工作。<br></code></pre></td></tr></table></figure><h3 id="CPU上下文切换有几种？系统中断进行了几次上下文切换？"><a href="#CPU上下文切换有几种？系统中断进行了几次上下文切换？" class="headerlink" title="CPU上下文切换有几种？系统中断进行了几次上下文切换？"></a>CPU上下文切换有几种？系统中断进行了几次上下文切换？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">上下文切换是一种将<span class="hljs-meta">CPU</span>资源从一个进程分配给另外一个进程的机制。操作系统需要先保存当前进程的状态(内存空间的指针，指令执行的位置等)，然后才能加载另外一个进程的状态并执行。<br><br><span class="hljs-meta">CPU</span>的上下文切换分为三种：进程上下文切换、线程上下文切换、中断上下文切换。<br><br>(<span class="hljs-number">1</span>) 系统调用过程中也会发生 <span class="hljs-meta">CPU</span> 上下文切换。<span class="hljs-meta">CPU</span> 寄存器会先保存用户态的状态，然后加载内核态相关内容。系统调用结束之后，<span class="hljs-meta">CPU</span> 寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次 <span class="hljs-meta">CPU</span> 上下文切换。<br><br>(<span class="hljs-number">2</span>) 进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调用的上下文则不会，因为其未发生进程的变化。<br><br>(<span class="hljs-number">3</span>) 内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。 线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。而线程自己的私有数据，如栈和寄存器等，上下文切换时需要保存。<br></code></pre></td></tr></table></figure><h3 id="什么是虚拟内存，有什么优点"><a href="#什么是虚拟内存，有什么优点" class="headerlink" title="什么是虚拟内存，有什么优点?"></a>什么是虚拟内存，有什么优点?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">虚拟内存就是逻辑空间，每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。<br><br>虚拟内存的优点是让程序可以获得更多的可用内存，避免直接操作内存导致内存越界等问题。<br></code></pre></td></tr></table></figure><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span>、先进先出<br><span class="hljs-number">2</span>、最近最久未使用<span class="hljs-comment">(LRU)</span><br><span class="hljs-number">3</span>、最少使用<span class="hljs-comment">(LFU)</span><br></code></pre></td></tr></table></figure><h3 id="虚拟内存的实现方式有哪些？分别有什么缺陷？"><a href="#虚拟内存的实现方式有哪些？分别有什么缺陷？" class="headerlink" title="虚拟内存的实现方式有哪些？分别有什么缺陷？"></a>虚拟内存的实现方式有哪些？分别有什么缺陷？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 页式管理：将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如 <span class="hljs-number">4</span>KB、<span class="hljs-number">8</span>KB 或 <span class="hljs-number">16</span>KB 等，并以页面作为内存空间的最小分配单位，一个程序的一个页面可以存放在任意一个物理页面里。页是信息的物理单位。<br><br><span class="hljs-comment">(2)</span> 段式管理。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。段是信息的逻辑单位。<br><br>分页存储的缺点：产生内部碎片 <br>分段存储的缺点：产生外部碎片 <br><br><span class="hljs-comment">(3)</span> 采用段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。这样做的目的就是想同时获得分段和分页的好处，但又避免了单独分段或单独分页的缺陷<br></code></pre></td></tr></table></figure><h3 id="如何实现虚拟内存到物理内存的映射？"><a href="#如何实现虚拟内存到物理内存的映射？" class="headerlink" title="如何实现虚拟内存到物理内存的映射？"></a>如何实现虚拟内存到物理内存的映射？</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sas">内存管理单元（MMU）管理着逻辑地址和物理地址的转换，其中的页表（<span class="hljs-meta">Page</span> <span class="hljs-meta">table</span>）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存。<br><br>简单页表：虚拟地址分为页号 + 偏移量。<br><br>多级页表：<br><br>TLB：<br></code></pre></td></tr></table></figure><h3 id="什么是中断？产生中断的方式有哪些？"><a href="#什么是中断？产生中断的方式有哪些？" class="headerlink" title="什么是中断？产生中断的方式有哪些？"></a>什么是中断？产生中断的方式有哪些？</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。<br><br>(<span class="hljs-number">1</span>) 由计算机硬件异常或故障引起的中断，称为内部异常中断<span class="hljs-comment">;</span><br>(<span class="hljs-number">2</span>) 由程序中执行了引起中断的指令而造成的中断，称为软中断（系统调用相关的中断)<span class="hljs-comment">;</span><br>(<span class="hljs-number">3</span>) 由外部设备请求引起的中断，称为外部中断<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="什么是用户态和核心态？"><a href="#什么是用户态和核心态？" class="headerlink" title="什么是用户态和核心态？"></a>什么是用户态和核心态？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，<span class="hljs-meta">CPU</span>划分了用户态和内核态两个权限等级。<br><br>用户态只能受限地访问内存，且不允许访问外围设备，没有占用<span class="hljs-meta">CPU</span>的能力，<span class="hljs-meta">CPU</span>资源可以被其它程序获取；<br>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。<br><br>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，<span class="hljs-meta">CPU</span>切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。<br></code></pre></td></tr></table></figure><h3 id="什么会导致用户态陷入内核态？"><a href="#什么会导致用户态陷入内核态？" class="headerlink" title="什么会导致用户态陷入内核态？"></a>什么会导致用户态陷入内核态？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 系统调用：操作系统提供的函数就被称为系统调用（system <span class="hljs-keyword">call</span>）。程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、 读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是 系统调用。<br><br><span class="hljs-comment">(2)</span> 异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时 会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如 缺页异常。<br><br><span class="hljs-comment">(3)</span> 外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号， 这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程 序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序 中执行后续操作等。<br></code></pre></td></tr></table></figure><h3 id="陷阱与中断的区别？"><a href="#陷阱与中断的区别？" class="headerlink" title="陷阱与中断的区别？"></a>陷阱与中断的区别？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">陷阱通常由处理机正在执行的现行指令引起,而中断则与现行指令无关的中断源引起。<br><br><span class="hljs-comment">(1)</span> 陷阱指令可以使执行流程从用户态陷入内核并把控制权转移给操作系统，使得用户程序可以调用内核函数和使用硬件从而获得操作系统所提供的服务，比如用视频软件放一个电影，视频软件就发出陷阱使用显示器和声卡从而访问硬件。<br><br><span class="hljs-comment">(2)</span> 中断是由外部事件导致并且它发生的时间是不可预测的，这一点和陷阱不同。外部事件主要是指时钟中断，硬件中断等。CPU 决定切换到另一个进程运行，就会产生一个时钟中断，切换到下一个进程运行。<br></code></pre></td></tr></table></figure><h3 id="同步与互斥的关系？"><a href="#同步与互斥的关系？" class="headerlink" title="同步与互斥的关系？"></a>同步与互斥的关系？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> 互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法 限制访问者对资源的访问顺序，即访问是无序的。 <br><br><span class="hljs-comment">(2)</span> 同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。<br><br>实现同步和互斥的方式<br>    <span class="hljs-comment">(1)</span> 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>    <span class="hljs-comment">(2)</span> 互斥量：为协调共同对一个共享资源的单独访问而设计的。 <br>    <span class="hljs-comment">(3)</span> 信号量：为控制一个具有有限数量用户资源而设计。 <br>    <span class="hljs-comment">(4)</span> 事 件：用来通知线程有一些事件已发生，从而启动后继任务的开始。<br></code></pre></td></tr></table></figure><h3 id="死锁产生的条件？有哪些处理方法？"><a href="#死锁产生的条件？有哪些处理方法？" class="headerlink" title="死锁产生的条件？有哪些处理方法？"></a>死锁产生的条件？有哪些处理方法？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gcode">多个进程持有资源并且一直处于相互等待对方的资源的状态，称为死锁。<br><br>死锁产生的四个必要条件：<br>    互斥条件 <span class="hljs-comment">(Mutual exclusion)</span>：资源不能被共享，只能由一个进程使用。<br>    请求与保持条件 <span class="hljs-comment">(Hold and wait)</span>：已经得到资源的进程可以再次申请新的资源。<br>    非抢占条件 <span class="hljs-comment">(No pre-emption)</span>：已经分配的资源不能从相应的进程中被强制地剥夺。<br>    循环等待条件 <span class="hljs-comment">(Circular wait)</span>：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。<br><br>死锁预防：核心思想是破坏死锁的四个必要条件<br>    <span class="hljs-number">1</span>、破坏互斥条件：使得资源可以被共享<br>    <span class="hljs-number">2</span>、破坏请求与保持条件：资源预分配<br>    <span class="hljs-number">3</span>、破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。<br>    <span class="hljs-number">4</span>、破坏循环等待条件：将所有资源编号，拥有编号较低的进程才能申请大于手上编号的资源。<br><br>死锁避免：动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。<br><br>死锁解除：发生死锁则回滚，让进程重新抢占资源。<br></code></pre></td></tr></table></figure><h3 id="IO多路复用的原理"><a href="#IO多路复用的原理" class="headerlink" title="IO多路复用的原理"></a>IO多路复用的原理</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。<br><br>实现原理：用户将想要监视的文件描述符（<span class="hljs-keyword">File</span> Descriptor）添加到select<span class="hljs-regexp">/poll/</span>epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。<br></code></pre></td></tr></table></figure><h3 id="IO多路复用的select、poll和epoll的区别"><a href="#IO多路复用的select、poll和epoll的区别" class="headerlink" title="IO多路复用的select、poll和epoll的区别"></a>IO多路复用的select、poll和epoll的区别</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">(<span class="hljs-number">1</span>) <span class="hljs-keyword">select</span>: 将文件描述符放入一个集合中，调用<span class="hljs-keyword">select</span>时，将这个集合从用户空间拷贝到内核空间（缺点<span class="hljs-number">1</span>：每次都要复制，开销大），由内核根据就绪状态修改该集合的内容。（缺点<span class="hljs-number">2</span>）集合大小有限制，<span class="hljs-number">32</span>位机默认是<span class="hljs-number">1024</span>（<span class="hljs-number">64</span>位：<span class="hljs-number">2048</span>）；采用水平触发机制。<span class="hljs-keyword">select</span>函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点<span class="hljs-number">3</span>：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降；<br><br>(<span class="hljs-number">2</span>) poll 和<span class="hljs-keyword">select</span>几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；<br><br>(<span class="hljs-number">3</span>) epoll 通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（<span class="hljs-number">1</span>G左右的内存支持<span class="hljs-number">10</span>W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。<br></code></pre></td></tr></table></figure><h3 id="什么时候使用select-poll-什么时候使用epoll"><a href="#什么时候使用select-poll-什么时候使用epoll" class="headerlink" title="什么时候使用select/poll,什么时候使用epoll?"></a>什么时候使用select/poll,什么时候使用epoll?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。<br></code></pre></td></tr></table></figure><h3 id="什么是水平触发和边缘触发"><a href="#什么是水平触发和边缘触发" class="headerlink" title="什么是水平触发和边缘触发"></a>什么是水平触发和边缘触发</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">水平触发（<span class="hljs-variable">LT</span>，<span class="hljs-built_in">Level</span> <span class="hljs-built_in">Trigger</span>）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；<br><br>边缘触发（<span class="hljs-variable">ET</span>，<span class="hljs-variable">Edge</span> <span class="hljs-built_in">Trigger</span>）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读<span class="hljs-operator">/</span>写变为可读<span class="hljs-operator">/</span>写）。<br><br>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。<br>为什么边缘触发一定要用非阻塞（<span class="hljs-variable">non</span><span class="hljs-operator">-</span><span class="hljs-variable">block</span>）<span class="hljs-variable">IO</span>：避免由于一个描述符的阻塞读<span class="hljs-operator">/</span>阻塞写操作让处理其它描述符的任务出现饥饿状态。<br></code></pre></td></tr></table></figure><h3 id="常见的IO模型"><a href="#常见的IO模型" class="headerlink" title="常见的IO模型"></a>常见的IO模型</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">1</span>、同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对<span class="hljs-meta">CPU</span>资源的利用率不够；<br><br><span class="hljs-number">2</span>、同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的<span class="hljs-meta">CPU</span>资源；<br><br><span class="hljs-number">3</span>、IO多路复用<br><br><span class="hljs-number">4</span>、异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。<br></code></pre></td></tr></table></figure><h3 id="如何查看占用内存比较多的进程"><a href="#如何查看占用内存比较多的进程" class="headerlink" title="如何查看占用内存比较多的进程?"></a>如何查看占用内存比较多的进程?</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">ps aux | sort -k4nr | head -N<br><br><span class="hljs-symbol">a:</span>所有进程<br><span class="hljs-symbol">u:</span>执行该进程的用户ID<br><span class="hljs-symbol">x:</span>显示所有程序<br><br><span class="hljs-symbol">sort:</span> 排序<br><span class="hljs-symbol">k4:</span> 按照第四列排序， <span class="hljs-number">4</span>是内存，<span class="hljs-number">3</span>是cpu<br><span class="hljs-symbol">n:</span>按照数值排序<br>r：反向排序<br><br>head：显示行数<br></code></pre></td></tr></table></figure><h3 id="通过进程id查看占用的端口，通过端口查看对应的进程ID？"><a href="#通过进程id查看占用的端口，通过端口查看对应的进程ID？" class="headerlink" title="通过进程id查看占用的端口，通过端口查看对应的进程ID？"></a>通过进程id查看占用的端口，通过端口查看对应的进程ID？</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -nap <span class="hljs-string">| grep 进程id</span><br>netstat -nap <span class="hljs-string">| grep 端口号</span><br></code></pre></td></tr></table></figure><h3 id="常用的Linux命令？如何打开文件并进行查找某个单词？怎么在某个目录下找到包含txt的文件？"><a href="#常用的Linux命令？如何打开文件并进行查找某个单词？怎么在某个目录下找到包含txt的文件？" class="headerlink" title="常用的Linux命令？如何打开文件并进行查找某个单词？怎么在某个目录下找到包含txt的文件？"></a>常用的Linux命令？如何打开文件并进行查找某个单词？怎么在某个目录下找到包含txt的文件？</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">pwd</span>:当前路径<br>sudo + 其他命令：以管理员身份运行<br><span class="hljs-keyword">grep</span> 要搜索的字符串 要搜索的文件 --color：搜索命令，--color高亮显示<br><span class="hljs-keyword">ps</span> aux: 查看当前正在运行的进程<br>kill -<span class="hljs-number">9</span> 进程的pid：杀死进程<br><span class="hljs-keyword">find</span> 目录 参数：寻找目录<br><span class="hljs-keyword">ls</span>：查看目录信息<br>free：查看内存使用情况<br>tar -xvf：解压压缩包。<span class="hljs-keyword">x</span>:解压<br>wge<span class="hljs-variable">t:</span>从远程下载<br>top：监控系统状况，比如CPU、内存的使用。<br><br><span class="hljs-keyword">find</span> /home -name <span class="hljs-string">&quot;*.txt&quot;</span><br><span class="hljs-keyword">cat</span> <span class="hljs-keyword">a</span>.txt | <span class="hljs-keyword">grep</span> redis --color<br></code></pre></td></tr></table></figure><h3 id="怎么判断一个主机是不是开放某个端口？"><a href="#怎么判断一个主机是不是开放某个端口？" class="headerlink" title="怎么判断一个主机是不是开放某个端口？"></a>怎么判断一个主机是不是开放某个端口？</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">telnet</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">3389</span> telnet IP地址 端口<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算器问题</title>
    <link href="/2021/03/11/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/11/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="利用双栈解决所有计算器问题"><a href="#利用双栈解决所有计算器问题" class="headerlink" title="利用双栈解决所有计算器问题"></a>利用双栈解决所有计算器问题</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">利用数字栈nums和字符栈ops解决计算器问题：<br><br>遍历字符串：<br>    若是空格，跳过。<br>    若是&#x27;(&#x27;，压入ops中，等待与之匹配的&#x27;)&#x27;。<br>    若是&#x27;)&#x27;, 取ops和nums进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums。<br>    若是操作符，若ops栈顶的操作符优先级大于该操作符，则先计算栈顶的操作。直到遇到左括号或者没有操作符。否则压入ops中。<br>    若是数字，则一直累计直到遇到非数字，将数字压入nums中。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 建立字符串优先级</span><br>        m.put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);<br>        m.put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);<br>        m.put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-number">2</span>);<br>        m.put(<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 去掉所有空格</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 将所有&quot;(-&quot; 改为 &quot;(0-&quot;</span><br>        s = s.replaceAll(<span class="hljs-string">&quot;\\(-&quot;</span>, <span class="hljs-string">&quot;(0-&quot;</span>);<br><br>        Stack&lt;Character&gt; ops = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        Stack&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.push(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                ops.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 一直计算直到遇到左括号为止</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-keyword">char</span> op = ops.peek();<br>                    <span class="hljs-keyword">if</span> (op != <span class="hljs-string">&#x27;(&#x27;</span>)<br>                        cal(ops, nums);<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        ops.pop();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">int</span> j = i;<br>                    <span class="hljs-keyword">while</span> (j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(j) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                        sum = sum * <span class="hljs-number">10</span> + (s.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                        j++;<br>                    &#125;<br>                    nums.push(sum);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 碰到新操作符</span><br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">char</span> prev = ops.peek();<br>                        <span class="hljs-comment">// 如果之前的运算优先级更大，则先计算</span><br>                        <span class="hljs-keyword">if</span> (m.get(prev) &gt;= m.get(c))<br>                            cal(ops, nums);<br>                        <span class="hljs-keyword">else</span> <br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    ops.push(c);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的计算完</span><br>        <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>)<br>            cal(ops, nums);<br><br>        <span class="hljs-keyword">return</span> nums.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(Stack&lt;Character&gt; ops, Stack&lt;Integer&gt; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> a = nums.pop();<br>        <span class="hljs-keyword">int</span> b = nums.pop();<br>        <span class="hljs-keyword">char</span> op = ops.pop();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) ans = b + a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) ans = b - a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) ans = b * a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;/&#x27;</span>) ans = b / a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>) ans = (<span class="hljs-keyword">int</span>)Math.pow(b, a);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;%&#x27;</span>) ans = b % a;<br>        nums.push(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>计算器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC300_最长上升子序列</title>
    <link href="/2021/03/06/%E7%AE%97%E6%B3%95/LC0300_%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/03/06/%E7%AE%97%E6%B3%95/LC0300_%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    算法思想：</span><br><span class="hljs-comment">        dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment">        从[0, i - 1]从查找，如果遇到 nums[j] &lt; nums[i], 则 dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N ^ 2)</span><br><span class="hljs-comment">    空间复杂度: O(N) </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> xMax = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 记录最长递增子序列</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 初始化为1</span><br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从[0, n - 1]寻找比 nums[i] 小的数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        xMax = Math.max(xMax, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> xMax;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于二分法的优化。</span><br><span class="hljs-comment">    g[i]: 最大长度为i的递增子序列中序列的最小值</span><br><span class="hljs-comment">    dp[i]: 以下标i结尾的最长上升子序列的最大长度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    那么在遍历nums[i]的过程中，只需要在g[]中寻找 &lt; nums[i] 的右边界r，那么 dp[i] = r + 1; g[r + 1] = nums[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    例如：g[3] = 4; // 1 2 4</span><br><span class="hljs-comment">          g[4] = 6; // 1 2 4 6</span><br><span class="hljs-comment">          nums[i] = 5, 则g[4] = 5; // 1 2 4 5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    g[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (g[mid] &lt; nums[i])<br>                l = mid;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前最大长度</span><br>        len = Math.max(len, r + <span class="hljs-number">1</span>);<br>        g[r + <span class="hljs-number">1</span>] = nums[i];<br>        dp[i] = r + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何获取最小字典序"><a href="#如何获取最小字典序" class="headerlink" title="如何获取最小字典序"></a>如何获取最小字典序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    此时dp[i]记录了以i结尾的最长上升子序列的长度；</span><br><span class="hljs-comment">    如果整个序列递增，那么显然dp[i]中的值从小到大依次递增。</span><br><span class="hljs-comment">    如果dp[i]中出现了相等的值，比如：</span><br><span class="hljs-comment">    1 2 5 3;    dp[2] = 3, dp[3] = 3;   显然后者的字典序更小</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[xMax];<br><span class="hljs-keyword">int</span> k = xMax - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, j = xMax; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// dp[i] == j, 则添加进res中</span><br>    <span class="hljs-keyword">if</span> (dp[i] == j) &#123;<br>        res[k--] = nums[i];<br>        j--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表</title>
    <link href="/2021/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/"/>
    <url>/2021/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="跳表简介"><a href="#跳表简介" class="headerlink" title="跳表简介"></a>跳表简介</h2><blockquote><ul><li>在有序链表的基础上添加跳跃功能减少不必要的搜索。</li><li>搜索、删除、添加的时间复杂度为 O(N * logN)。</li><li>跳表按层构造，高层相当于底层的’快速通道’</li></ul></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 定义链表节点Node</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>        K key;<br>        V value;<br>        Node&lt;K, V&gt;[] nexts; <span class="hljs-comment">// 存放后继节点数组</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> Node&lt;K, V&gt; first;   <span class="hljs-comment">// 首部虚拟节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-comment">// 跳表元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEVEL = <span class="hljs-number">32</span>;    <span class="hljs-comment">// 跳表最大层数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> level = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 记录有效层数</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkipList</span><span class="hljs-params">()</span> </span>&#123;<br>        first = <span class="hljs-keyword">new</span> Node&lt;&gt;();<br>        first.nexts = <span class="hljs-keyword">new</span> Node[MAX_LEVEL];<br>    &#125;<br><br>    <span class="hljs-comment">// 生成随机层数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (Math.random() &lt; <span class="hljs-number">0.25</span> &amp;&amp; level &lt; MAX_LEVEL)<br>            level++;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索get-K-key-设计"><a href="#搜索get-K-key-设计" class="headerlink" title="搜索get(K key)设计"></a>搜索get(K key)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1、从首节点开始，一直找到第一个 &gt;= key 的下一个节点</span><br><span class="hljs-comment">    2、如果相等，则直接返回；否则从下一层继续寻找</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;<br><br>    Node&lt;K, V&gt; node = first;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-comment">// 若当前节点的key == key, 则找到了直接返回</span><br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> node.nexts[i].value;<br>        <br>        <span class="hljs-comment">// 没找到则从node.nexts[i-1]开始搜索</span><br>    &#125; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加put-K-key-V-value-设计"><a href="#添加put-K-key-V-value-设计" class="headerlink" title="添加put(K key, V value)设计"></a>添加put(K key, V value)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>  <br>    Node&lt;K, V&gt; node = first;  <br>    Node&lt;K, V&gt;[] prevs = <span class="hljs-keyword">new</span> Node[level];         <span class="hljs-comment">// 存放每次发生跳层的节点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-comment">// 若node.nexts[i].key == key, 则覆盖value</span><br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>) &#123;<br>            node.nexts[i].value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 记录发生跳转的节点</span><br>        prevs[i] = node;    <br>    &#125; <br><br>    <span class="hljs-comment">// 不存在改key, 则此时node是前驱节点, i == -1</span><br>    Node&lt;K, V&gt; newNode = <span class="hljs-keyword">new</span> Node(key, value);<br>    <span class="hljs-keyword">int</span> rdLevel = randomLevel();<br>    newNode.nexts = <span class="hljs-keyword">new</span> Node&lt;&gt;[rdLevel];<br><br>    <span class="hljs-comment">// 调整层数为[0, level - 1]的后继指向</span><br>    <span class="hljs-comment">// 如果rdLevel &gt; level, 则调整头节点next</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rdLevel; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; level) &#123;<br>            newNode.nexts[i] = prevs[i].nexts[i];<br>            prevs[i].nexts[i] = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            first.nexts[i] = newNode;<br>        &#125;<br>    &#125;<br><br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除remove-K-key-设计"><a href="#删除remove-K-key-设计" class="headerlink" title="删除remove(K key)设计"></a>删除remove(K key)设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;<br>    Node&lt;K, V&gt; node = first;  <br>    Node&lt;K, V&gt;[] prevs = <span class="hljs-keyword">new</span> Node[level];         <span class="hljs-comment">// 存放每次发生跳层的节点</span><br>    <span class="hljs-keyword">boolean</span> exist = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 从顶层链表开始, 一直寻找第一个 &gt;= key 的节点</span><br>        <span class="hljs-keyword">while</span> (node.nexts[i] != <span class="hljs-keyword">null</span> &amp;&amp; key.compareTo(node.nexts[i].key) &gt; <span class="hljs-number">0</span>)<br>            node = node.nexts[i];<br>        <br>        <span class="hljs-keyword">if</span> (key.compareTo(node.nexts[i].key) == <span class="hljs-number">0</span>)<br>            exist = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 找到key则进入下一层并记录所有发生跳转的节点</span><br>        prevs[i] = node;    <br>    &#125; <br><br>    <span class="hljs-comment">// 如果没找到则返回null</span><br>    <span class="hljs-keyword">if</span> (!exist) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 调整所有前驱的后继</span><br>    Node&lt;K, V&gt; removeNode = node.nexts[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; removeNode.nexts.length; i++) &#123;<br>        prevs[i].nexts[i] = removeNode.nexts[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 更新跳表的层数, 从头节点出发寻找next[i]不为空的层数</span><br>    <span class="hljs-keyword">int</span> newLevel = level;<br>    <span class="hljs-keyword">while</span> (newLevel &gt; <span class="hljs-number">0</span> &amp;&amp; first.nexts[newLevel] == <span class="hljs-keyword">null</span>)<br>        newLevel--;<br>    <br>    level = newLevel;<br><br>    size--;<br>    <span class="hljs-keyword">return</span> removeNode.value;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>跳表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2021/03/05/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2021/03/05/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>前缀和与差分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="Acwing791-高精度加法"><a href="#Acwing791-高精度加法" class="headerlink" title="Acwing791_高精度加法"></a>Acwing791_高精度加法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-comment">// 将两个大数字符串翻转</span><br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录进位情况</span><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length() || i &lt; b.length(); i++) &#123;<br>        <span class="hljs-comment">// 按位累加</span><br>        <span class="hljs-keyword">if</span> (i &lt; a.length()) t += a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; b.length()) t += b.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        sb.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-number">0</span>) sb.append(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing792-高精度减法"><a href="#Acwing792-高精度减法" class="headerlink" title="Acwing792_高精度减法"></a>Acwing792_高精度减法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sub</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-comment">// 默认 a &gt; b</span><br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录借位情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        t = (a[i] - <span class="hljs-string">&#x27;0&#x27;</span>) - t;<br>        <span class="hljs-keyword">if</span> (i &lt; b.length()) <br>            t -= b[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <span class="hljs-comment">// 此时t若小于0则发生借位, t若大于0则没发生借位</span><br>        <span class="hljs-comment">// (t + 10) % 10, 可以保证无论是否发生借位都可以是正数</span><br>        sb.append((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);   <span class="hljs-comment">// 核心步骤</span><br>        t = t &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = sb.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index--;<br>    <br>    sb.delete(index + <span class="hljs-number">1</span>, sb.length());<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing793-高精度乘法"><a href="#Acwing793-高精度乘法" class="headerlink" title="Acwing793_高精度乘法"></a>Acwing793_高精度乘法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    情况1：大数 x 个位数</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    t += A[i] * b;  t /= 10;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br><br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        t += (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * b;<br><br>        res.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果此时 t == 87, 需要先添加7, 再添加8</span><br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-number">0</span>) &#123;<br>        sb.append(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 12345 x 0, 会存在前导0</span><br>    <span class="hljs-keyword">int</span> index = sb.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index--;<br>    <br>    sb = sb.delete(index + <span class="hljs-number">1</span>, sb.length());<br>    <br>    <span class="hljs-keyword">return</span> res.reverse().toString();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    情况2: 大数 x 大数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    c[i+j] += a[i] * b[j];</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul2</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> StringBuilder(a).reverse().toString();<br>    b = <span class="hljs-keyword">new</span> StringBuilder(b).reverse().toString();<br><br>    <span class="hljs-keyword">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length() + b.length()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.length(); j++) &#123;<br>            c[i][j] += (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (b.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理数组c的进位</span><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.length; i++) &#123;<br>        c[i] = (c[i] + t) % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">int</span> index = c.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; c[index] == <span class="hljs-number">0</span>)<br>        index--;<br>    <br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &gt;= <span class="hljs-number">0</span>; i--)<br>        sb.append(c[i]);<br><br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing794-高精度除法"><a href="#Acwing794-高精度除法" class="headerlink" title="Acwing794_高精度除法"></a>Acwing794_高精度除法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    高精度 / 低精度</span><br><span class="hljs-comment">    核心思想： r = r * 10 + A[i];  r / 10;  r %= b;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 保存余数</span><br><span class="hljs-keyword">int</span>[] res; <span class="hljs-comment">// 保存商</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">div</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>        r = r * <span class="hljs-number">10</span> + (a.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        sb.append(r / b);<br>        r %= b;<br>    &#125;<br><br>    <span class="hljs-comment">// 去除商的前导0</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; sb.length() - <span class="hljs-number">1</span> &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        index++;<br><br>    <span class="hljs-comment">// [index, sb.length() - 1]</span><br>    res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sb.length() - index];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; sb.length(); i++)<br>        res[k++] = sb.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    高精度 / 高精度</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>高精度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="二分法思想"><a href="#二分法思想" class="headerlink" title="二分法思想"></a>二分法思想</h2><blockquote><p>二分法常用于有序状态的数组中，通过中点值与条件的比较一下筛选掉一半的处理规模，从而使时间复杂度从O(N)降到O(logN)</p></blockquote><blockquote><ul><li>整数二分</li><li>小数二分</li></ul></blockquote><h3 id="Acwing789-数的范围"><a href="#Acwing789-数的范围" class="headerlink" title="Acwing789_数的范围"></a>Acwing789_数的范围</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    元素k的起始位置和终止位置，没找到则返回[-1, -1]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1、寻找 &gt;= k 的左边界l和 &lt;= k 的右边界r</span><br><span class="hljs-comment">    2、如果边界处的值不等于k, 则说明k不存在</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] num_score(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <br>    <span class="hljs-comment">// 寻找 &gt;= k 的左边界</span><br>    <span class="hljs-keyword">int</span> l1 = <span class="hljs-number">0</span>, r1 = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l1 &lt; r1) &#123;<br>        <span class="hljs-keyword">int</span> mid1 = (l1 + r1) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 如果中点处的值 &gt;= k, 则缩小右边界的范围，因为[mid1, r1]肯定都 &gt;= k</span><br>        <span class="hljs-keyword">if</span> (nums[mid1] &gt;= k)<br>            r1 = mid1;<br>        <span class="hljs-comment">// 否则说明[l1, mid1]都 &lt; k, 那么 &gt;= k的左边界只可能在[mid1 + 1, r1]之间</span><br>        <span class="hljs-keyword">else</span><br>            l1 = mid1 + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果边界处的值不等于k则说明元素不存在</span><br>    <span class="hljs-keyword">if</span> (nums[l1] != k)  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-comment">// 寻找 &lt;= k 的右边界</span><br>    <span class="hljs-keyword">int</span> l2 = <span class="hljs-number">0</span>, r2 = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l2 &lt; r2) &#123;<br>        <span class="hljs-comment">// 如果是使得l = mid, 则应该 + 1</span><br>        <span class="hljs-keyword">int</span> mid2 = (l2 + r2 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 如果中点处的值 &lt;= k, 则缩小右边界的范围，因为[l2, mid2]肯定都 &lt;= k</span><br>        <span class="hljs-keyword">if</span> (nums[mid2] &lt;= k)<br>            l2 = mid1;<br>        <span class="hljs-comment">// 否则说明[mid2, r2]都 &gt; k, 那么 &gt;= k的左边界只可能在[l2, mid2 - 1]之间</span><br>        <span class="hljs-keyword">else</span><br>            l2 = mid2 - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l1, l2&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing790-数的三次方根"><a href="#Acwing790-数的三次方根" class="headerlink" title="Acwing790_数的三次方根"></a>Acwing790_数的三次方根</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    计算数的三次方根</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">three_sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> l = -<span class="hljs-number">100</span>, r = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 通过精度来控制循环, 一半比要求的精度低两个数量级</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1e-8</span>) &#123;<br>        <span class="hljs-keyword">double</span> mid = (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">double</span> t = mid * mid * mid;<br>        <span class="hljs-keyword">if</span> (t &lt; target)<br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid;<br>    &#125;<br>    <br>    System.out.printf(<span class="hljs-string">&quot;%.6f&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>二分法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="归并排序的思想"><a href="#归并排序的思想" class="headerlink" title="归并排序的思想"></a>归并排序的思想</h2><blockquote><p>归并排序是基于 <strong>分治</strong> 和 <strong>递归</strong> 的思想。</p><ul><li>选取数组中间点为分割点</li><li>递归排序左子数组和右子数组</li><li>归并两个有序的子数组</li></ul></blockquote><h3 id="Acwing787-归并排序模板"><a href="#Acwing787-归并排序模板" class="headerlink" title="Acwing787_归并排序模板"></a>Acwing787_归并排序模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    时间复杂度: O(N * logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：子数组无元素或只剩一个元素</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 选取中间点作为分割点</span><br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 递归排序左右数组</span><br>    merge_sort(nums, l, mid);<br>    merge_sort(nums, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">// 归并两个有序数组</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j])<br>            temp[k++] = nums[i++];<br>        <span class="hljs-keyword">else</span><br>            temp[k++] = nums[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)    temp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)   temp[k++] = nums[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        nums[i] = temp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing788-逆序对的数量"><a href="#Acwing788-逆序对的数量" class="headerlink" title="Acwing788_逆序对的数量"></a>Acwing788_逆序对的数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    利用归并排序的思想，在归并两个有序数组的时候对逆序对进行累加</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度：O(N * logN)</span><br><span class="hljs-comment">    空间复杂度：O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 返回数组区间[l, r]的逆序对数量</span><br><span class="hljs-comment">// 那么总的逆序对为 左边的逆序对 + 右边的逆序对 + 左右数组形成的逆序对</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">mergeSort_findReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：数组无元素或只有一个元素无法形成逆序对，返回0</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 累加左数组的逆序对和右数组的逆序对</span><br>    <span class="hljs-keyword">long</span> res = mergeSort_findReverse(nums, l, mid) + mergeSort_findReverse(nums, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-comment">// 两个有序数组归并的过程中继续累加逆序对</span><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>            temp[k++] = nums[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// i &lt; j 但是 nums[i] &gt; nums[j], 则[i, mid]均大于nums[j]</span><br>            temp[k++] = nums[j++];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)    temp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)   temp[k++] = nums[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        nums[i] = temp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/04/Acwing/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="快排的思想"><a href="#快排的思想" class="headerlink" title="快排的思想"></a>快排的思想</h2><blockquote><p>快速排序是基于 <strong>分治</strong> 和 <strong>递归</strong> 的思想。</p><ul><li>选取分界点x。</li><li>双指针处理，使得 &lt;= x 的都在左边， &gt;= x 的都在右边。</li><li>递归排序左右子数组, 递归出口为子数组无元素或只有一个元素。</li></ul></blockquote><h3 id="Acwing785-快排模板"><a href="#Acwing785-快排模板" class="headerlink" title="Acwing785_快排模板"></a>Acwing785_快排模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    时间复杂度: O(N ^ logN)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归出口：子数组无元素或只剩一个元素</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 1、选取数组中存在的值作为分界值</span><br>    <span class="hljs-keyword">int</span> x = nums[l + (r - l) / <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 2、保证 &lt;= x 的都在左边， &gt;= x 的都在右边</span><br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br><br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> t = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3、递归处理左右子数组</span><br>    quick_sort(nums, l, j);<br>    quick_sort(nums, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Acwing786-寻找第k小的数"><a href="#Acwing786-寻找第k小的数" class="headerlink" title="Acwing786_寻找第k小的数"></a>Acwing786_寻找第k小的数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    基于快排的思想将小的数放在数组右边，大的数放在数组左边</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    当右子数组长度 len &gt;= k时，说明第k大的数是右数组的第k大的数</span><br><span class="hljs-comment">    当右子数组长度 len &lt; k时, 说明第k大的数是左数组的第(k - len)大的数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    递归的向相应的子数组中寻找，直到数组中只剩下一个元素则为目标值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    时间复杂度: O(N)</span><br><span class="hljs-comment">    空间复杂度: O(N)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 当只剩下一个数的时候，说明找到了第K小的数</span><br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> arr[l];<br>    <br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> target = arr[(l + r) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (arr[i] &lt; target);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (arr[j] &gt; target);<br>        <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> len = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (len &gt;= k)<br>        <span class="hljs-keyword">return</span> findKth(arr, l, j, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> findKth(arr, j + <span class="hljs-number">1</span>, r, k - len);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Acwing</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
